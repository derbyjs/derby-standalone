{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "index.js",
    "node_modules/arraydiff/index.js",
    "node_modules/derby-parsing/lib/createPathExpression.js",
    "node_modules/derby-parsing/lib/index.js",
    "node_modules/derby-parsing/lib/markup.js",
    "node_modules/derby-templates/index.js",
    "node_modules/derby-templates/lib/contexts.js",
    "node_modules/derby-templates/lib/expressions.js",
    "node_modules/derby-templates/lib/operatorFns.js",
    "node_modules/derby-templates/lib/options.js",
    "node_modules/derby-templates/lib/templates.js",
    "node_modules/derby-templates/lib/util.js",
    "node_modules/derby/lib/App.js",
    "node_modules/derby/lib/Controller.js",
    "node_modules/derby/lib/DerbyStandalone.js",
    "node_modules/derby/lib/Dom.js",
    "node_modules/derby/lib/Page.js",
    "node_modules/derby/lib/_views.js",
    "node_modules/derby/lib/components.js",
    "node_modules/derby/lib/documentListeners.js",
    "node_modules/derby/lib/eventmodel.js",
    "node_modules/derby/lib/parsing/index.js",
    "node_modules/derby/lib/textDiff.js",
    "node_modules/derby/parsing.js",
    "node_modules/esprima-derby/esprima.js",
    "node_modules/events/events.js",
    "node_modules/fast-deep-equal/index.js",
    "node_modules/html-util/lib/index.js",
    "node_modules/html-util/lib/parse.js",
    "node_modules/path-browserify/index.js",
    "node_modules/process/browser.js",
    "node_modules/punycode/punycode.js",
    "node_modules/qs/lib/formats.js",
    "node_modules/qs/lib/index.js",
    "node_modules/qs/lib/parse.js",
    "node_modules/qs/lib/stringify.js",
    "node_modules/qs/lib/utils.js",
    "node_modules/querystring-es3/decode.js",
    "node_modules/querystring-es3/encode.js",
    "node_modules/querystring-es3/index.js",
    "node_modules/racer/lib/Model/Doc.js",
    "node_modules/racer/lib/Model/LocalDoc.js",
    "node_modules/racer/lib/Model/Model.js",
    "node_modules/racer/lib/Model/ModelStandalone.js",
    "node_modules/racer/lib/Model/collections.js",
    "node_modules/racer/lib/Model/defaultFns.js",
    "node_modules/racer/lib/Model/events.js",
    "node_modules/racer/lib/Model/filter.js",
    "node_modules/racer/lib/Model/fn.js",
    "node_modules/racer/lib/Model/mutators.js",
    "node_modules/racer/lib/Model/paths.js",
    "node_modules/racer/lib/Model/ref.js",
    "node_modules/racer/lib/Model/refList.js",
    "node_modules/racer/lib/Model/setDiff.js",
    "node_modules/racer/lib/util.js",
    "node_modules/saddle/index.js",
    "node_modules/serialize-object/index.js",
    "node_modules/tracks/lib/History.js",
    "node_modules/tracks/lib/browser.js",
    "node_modules/tracks/lib/router.js",
    "node_modules/tracks/vendor/express/router/route.js",
    "node_modules/tracks/vendor/express/utils.js",
    "node_modules/url/url.js",
    "node_modules/url/util.js",
    "node_modules/uuid/rng-browser.js",
    "node_modules/uuid/uuid.js"
  ],
  "names": [],
  "mappings": "AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACh1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5ZA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3iBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACptBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "// Includes full template and expression parsing in bundle\nvar parsing = require('derby/parsing');\nvar path = require('path');\nvar DerbyStandalone = require('derby/lib/DerbyStandalone');\nvar derby = new DerbyStandalone();\nvar App = derby.App;\n\nglobal.derby = module.exports = derby;\n\n// Can be overriden to customize how templates are loaded. However, it must be\n// synchronous, because app.loadViews() is synchronous\nApp.prototype.getTemplate = function(filename) {\n  return document.getElementById(filename);\n};\n\nApp.prototype.loadViews = function(filename, namespace) {\n  var resolved = this._resolveTemplate(filename);\n  if (!resolved) {\n    throw new Error('Cannot find template \"' + filename + '\"');\n  }\n  this._registerTemplate(resolved.template, namespace, resolved.filename);\n};\n\nApp.prototype._registerTemplate = function(template, namespace, filename) {\n  var file = template.innerHTML;\n  var app = this;\n  function onImport(attrs) {\n    var dir = path.dirname(filename);\n    var sourceFilename = path.resolve(dir, attrs.src);\n    var resolved = app._resolveTemplate(sourceFilename);\n    if (!resolved) {\n      throw new Error('Cannot find template \"' + attrs.src + '\" from \"' + filename + '\"');\n    }\n    importNamespace = parsing.getImportNamespace(namespace, attrs, resolved.filename);\n    app._registerTemplate(resolved.template, importNamespace, resolved.filename);\n  }\n  var items = parsing.parseViews(file, namespace, filename, onImport);\n  parsing.registerParsedViews(this, items);\n};\n\nApp.prototype._resolveTemplate = function(filename) {\n  var resolved;\n  resolved = this._attemptResolveTemplate(filename);\n  if (resolved) return resolved;\n  resolved = this._attemptResolveTemplate(filename + '.html');\n  if (resolved) return resolved;\n  resolved = this._attemptResolveTemplate(filename + '/index');\n  if (resolved) return resolved;\n  resolved = this._attemptResolveTemplate(filename + '/index.html');\n  return resolved;\n};\n\nApp.prototype._attemptResolveTemplate = function(filename) {\n  var template = this.getTemplate(filename);\n  if (template) return {template: template, filename: filename};\n};\n\n// DEPRECATED: This function is a legacy format that should be removed. Use\n// loadViews() instead.\nApp.prototype.registerViews = function(selector) {\n  selector || (selector = 'script[type=\"text/template\"]');\n  var templates = document.querySelectorAll(selector);\n  for (var i = 0; i < templates.length; i++) {\n    var template = templates[i];\n    this.views.register(template.id, template.innerHTML, template.dataset);\n  }\n};\n",
    "module.exports = arrayDiff;\n\n// Based on some rough benchmarking, this algorithm is about O(2n) worst case,\n// and it can compute diffs on random arrays of length 1024 in about 34ms,\n// though just a few changes on an array of length 1024 takes about 0.5ms\n\narrayDiff.InsertDiff = InsertDiff;\narrayDiff.RemoveDiff = RemoveDiff;\narrayDiff.MoveDiff = MoveDiff;\n\nfunction InsertDiff(index, values) {\n  this.index = index;\n  this.values = values;\n}\nInsertDiff.prototype.type = 'insert';\nInsertDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    index: this.index,\n    values: this.values\n  };\n};\n\nfunction RemoveDiff(index, howMany) {\n  this.index = index;\n  this.howMany = howMany;\n}\nRemoveDiff.prototype.type = 'remove';\nRemoveDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    index: this.index,\n    howMany: this.howMany\n  };\n};\n\nfunction MoveDiff(from, to, howMany) {\n  this.from = from;\n  this.to = to;\n  this.howMany = howMany;\n}\nMoveDiff.prototype.type = 'move';\nMoveDiff.prototype.toJSON = function() {\n  return {\n    type: this.type,\n    from: this.from,\n    to: this.to,\n    howMany: this.howMany\n  };\n};\n\nfunction strictEqual(a, b) {\n  return a === b;\n}\n\nfunction arrayDiff(before, after, equalFn) {\n  if (!equalFn) equalFn = strictEqual;\n\n  // Find all items in both the before and after array, and represent them\n  // as moves. Many of these \"moves\" may end up being discarded in the last\n  // pass if they are from an index to the same index, but we don't know this\n  // up front, since we haven't yet offset the indices.\n  //\n  // Also keep a map of all the indices accounted for in the before and after\n  // arrays. These maps are used next to create insert and remove diffs.\n  var beforeLength = before.length;\n  var afterLength = after.length;\n  var moves = [];\n  var beforeMarked = {};\n  var afterMarked = {};\n  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {\n    var beforeItem = before[beforeIndex];\n    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {\n      if (afterMarked[afterIndex]) continue;\n      if (!equalFn(beforeItem, after[afterIndex])) continue;\n      var from = beforeIndex;\n      var to = afterIndex;\n      var howMany = 0;\n      do {\n        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;\n        howMany++;\n      } while (\n        beforeIndex < beforeLength &&\n        afterIndex < afterLength &&\n        equalFn(before[beforeIndex], after[afterIndex]) &&\n        !afterMarked[afterIndex]\n      );\n      moves.push(new MoveDiff(from, to, howMany));\n      beforeIndex--;\n      break;\n    }\n  }\n\n  // Create a remove for all of the items in the before array that were\n  // not marked as being matched in the after array as well\n  var removes = [];\n  for (beforeIndex = 0; beforeIndex < beforeLength;) {\n    if (beforeMarked[beforeIndex]) {\n      beforeIndex++;\n      continue;\n    }\n    var index = beforeIndex;\n    var howMany = 0;\n    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {\n      howMany++;\n    }\n    removes.push(new RemoveDiff(index, howMany));\n  }\n\n  // Create an insert for all of the items in the after array that were\n  // not marked as being matched in the before array as well\n  var inserts = [];\n  for (var afterIndex = 0; afterIndex < afterLength;) {\n    if (afterMarked[afterIndex]) {\n      afterIndex++;\n      continue;\n    }\n    var index = afterIndex;\n    var howMany = 0;\n    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {\n      howMany++;\n    }\n    var values = after.slice(index, index + howMany);\n    inserts.push(new InsertDiff(index, values));\n  }\n\n  var insertsLength = inserts.length;\n  var removesLength = removes.length;\n  var movesLength = moves.length;\n  var i, j;\n\n  // Offset subsequent removes and moves by removes\n  var count = 0;\n  for (i = 0; i < removesLength; i++) {\n    var remove = removes[i];\n    remove.index -= count;\n    count += remove.howMany;\n    for (j = 0; j < movesLength; j++) {\n      var move = moves[j];\n      if (move.from >= remove.index) move.from -= remove.howMany;\n    }\n  }\n\n  // Offset moves by inserts\n  for (i = insertsLength; i--;) {\n    var insert = inserts[i];\n    var howMany = insert.values.length;\n    for (j = movesLength; j--;) {\n      var move = moves[j];\n      if (move.to >= insert.index) move.to -= howMany;\n    }\n  }\n\n  // Offset the to of moves by later moves\n  for (i = movesLength; i-- > 1;) {\n    var move = moves[i];\n    if (move.to === move.from) continue;\n    for (j = i; j--;) {\n      var earlier = moves[j];\n      if (earlier.to >= move.to) earlier.to -= move.howMany;\n      if (earlier.to >= move.from) earlier.to += move.howMany;\n    }\n  }\n\n  // Only output moves that end up having an effect after offsetting\n  var outputMoves = [];\n\n  // Offset the from of moves by earlier moves\n  for (i = 0; i < movesLength; i++) {\n    var move = moves[i];\n    if (move.to === move.from) continue;\n    outputMoves.push(move);\n    for (j = i + 1; j < movesLength; j++) {\n      var later = moves[j];\n      if (later.from >= move.from) later.from -= move.howMany;\n      if (later.from >= move.to) later.from += move.howMany;\n    }\n  }\n\n  return removes.concat(outputMoves, inserts);\n}\n",
    "var derbyTemplates = require('derby-templates');\nvar expressions = derbyTemplates.expressions;\nvar operatorFns = derbyTemplates.operatorFns;\nvar esprima = require('esprima-derby');\nvar Syntax = esprima.Syntax;\n\nmodule.exports = createPathExpression;\n\nfunction createPathExpression(source) {\n  var node = esprima.parse(source).expression;\n  return reduce(node);\n}\n\nfunction reduce(node) {\n  var type = node.type;\n  if (type === Syntax.MemberExpression) {\n    return reduceMemberExpression(node);\n  } else if (type === Syntax.Identifier) {\n    return reduceIdentifier(node);\n  } else if (type === Syntax.ThisExpression) {\n    return reduceThis(node);\n  } else if (type === Syntax.CallExpression) {\n    return reduceCallExpression(node);\n  } else if (type === Syntax.Literal) {\n    return reduceLiteral(node);\n  } else if (type === Syntax.UnaryExpression) {\n    return reduceUnaryExpression(node);\n  } else if (type === Syntax.BinaryExpression || type === Syntax.LogicalExpression) {\n    return reduceBinaryExpression(node);\n  } else if (type === Syntax.ConditionalExpression) {\n    return reduceConditionalExpression(node);\n  } else if (type === Syntax.ArrayExpression) {\n    return reduceArrayExpression(node);\n  } else if (type === Syntax.ObjectExpression) {\n    return reduceObjectExpression(node);\n  } else if (type === Syntax.SequenceExpression) {\n    return reduceSequenceExpression(node);\n  } else if (type === Syntax.NewExpression) {\n    return reduceNewExpression(node);\n  }\n  unexpected(node);\n}\n\nfunction reduceMemberExpression(node, afterSegments) {\n  if (node.computed) {\n    // Square brackets\n    if (node.property.type === Syntax.Literal) {\n      return reducePath(node, node.property.value, afterSegments);\n    }\n    var before = reduce(node.object);\n    var inside = reduce(node.property);\n    return new expressions.BracketsExpression(before, inside, afterSegments);\n  }\n  // Dot notation\n  if (node.property.type === Syntax.Identifier) {\n    return reducePath(node, node.property.name);\n  }\n  unexpected(node);\n}\n\nfunction reducePath(node, segment, afterSegments) {\n  var segments = [segment];\n  if (afterSegments) segments = segments.concat(afterSegments);\n  var relative = false;\n  while (node = node.object) {\n    if (node.type === Syntax.MemberExpression) {\n      if (node.computed) {\n        return reduceMemberExpression(node, segments);\n      } else if (node.property.type === Syntax.Identifier) {\n        segments.unshift(node.property.name);\n      } else {\n        unexpected(node);\n      }\n    } else if (node.type === Syntax.Identifier) {\n      segments.unshift(node.name);\n    } else if (node.type === Syntax.ThisExpression) {\n      relative = true;\n    } else if (node.type === Syntax.CallExpression) {\n      return reduceCallExpression(node, segments);\n    } else if (node.type === Syntax.SequenceExpression) {\n      return reduceSequenceExpression(node, segments);\n    } else if (node.type === Syntax.NewExpression) {\n      return reduceNewExpression(node, segments);\n    } else {\n      unexpected(node);\n    }\n  }\n  return (relative) ?\n    new expressions.RelativePathExpression(segments) :\n    createSegmentsExpression(segments);\n}\n\nfunction reduceIdentifier(node) {\n  var segments = [node.name];\n  return createSegmentsExpression(segments);\n}\n\nfunction reduceThis(node) {\n  var segments = [];\n  return new expressions.RelativePathExpression(segments);\n}\n\nfunction createSegmentsExpression(segments) {\n  var firstSegment = segments[0];\n  var firstChar = firstSegment.charAt && firstSegment.charAt(0);\n\n  if (firstChar === '#') {\n    var alias = firstSegment;\n    segments.shift();\n    return new expressions.AliasPathExpression(alias, segments);\n\n  } else if (firstChar === '@') {\n    var attribute = firstSegment.slice(1);\n    segments.shift();\n    return new expressions.AttributePathExpression(attribute, segments);\n\n  } else {\n    return new expressions.PathExpression(segments);\n  }\n}\n\nfunction reduceCallExpression(node, afterSegments) {\n  return reduceFnExpression(node, afterSegments, expressions.FnExpression);\n}\n\nfunction reduceNewExpression(node, afterSegments) {\n  return reduceFnExpression(node, afterSegments, expressions.NewExpression);\n}\n\nfunction reduceFnExpression(node, afterSegments, Constructor) {\n  var args = node.arguments.map(reduce);\n  var callee = node.callee;\n  if (callee.type === Syntax.Identifier) {\n    if (callee.name === '$at') {\n      return new expressions.ScopedModelExpression(args[0]);\n    }\n    var segments = [callee.name];\n    return new Constructor(segments, args, afterSegments);\n  } else if (callee.type === Syntax.MemberExpression) {\n    var segments = reduceMemberExpression(callee).segments;\n    return new Constructor(segments, args, afterSegments);\n  } else {\n    unexpected(node);\n  }\n}\n\nfunction reduceLiteral(node) {\n  return new expressions.LiteralExpression(node.value);\n}\n\nfunction reduceUnaryExpression(node) {\n  // `-` and `+` can be either unary or binary, so all unary operators are\n  // postfixed with `U` to differentiate\n  var operator = node.operator + 'U';\n  var expression = reduce(node.argument);\n  if (expression instanceof expressions.LiteralExpression) {\n    var fn = operatorFns.get[operator];\n    expression.value = fn(expression.value);\n    return expression;\n  }\n  return new expressions.OperatorExpression(operator, [expression]);\n}\n\nfunction reduceBinaryExpression(node) {\n  var operator = node.operator;\n  var left = reduce(node.left);\n  var right = reduce(node.right);\n  if (\n    left instanceof expressions.LiteralExpression &&\n    right instanceof expressions.LiteralExpression\n  ) {\n    var fn = operatorFns.get[operator];\n    var value = fn(left.value, right.value);\n    return new expressions.LiteralExpression(value);\n  }\n  return new expressions.OperatorExpression(operator, [left, right]);\n}\n\nfunction reduceConditionalExpression(node) {\n  var test = reduce(node.test);\n  var consequent = reduce(node.consequent);\n  var alternate = reduce(node.alternate);\n  if (\n    test instanceof expressions.LiteralExpression &&\n    consequent instanceof expressions.LiteralExpression &&\n    alternate instanceof expressions.LiteralExpression\n  ) {\n    var value = (test.value) ? consequent.value : alternate.value;\n    return new expressions.LiteralExpression(value);\n  }\n  return new expressions.OperatorExpression('?', [test, consequent, alternate]);\n}\n\nfunction reduceArrayExpression(node) {\n  var literal = [];\n  var items = [];\n  var isLiteral = true;\n  for (var i = 0; i < node.elements.length; i++) {\n    var expression = reduce(node.elements[i]);\n    items.push(expression);\n    if (isLiteral && expression instanceof expressions.LiteralExpression) {\n      literal.push(expression.value);\n    } else {\n      isLiteral = false;\n    }\n  }\n  return (isLiteral) ?\n    new expressions.LiteralExpression(literal) :\n    new expressions.ArrayExpression(items);\n}\n\nfunction reduceObjectExpression(node) {\n  var literal = {};\n  var properties = {};\n  var isLiteral = true;\n  for (var i = 0; i < node.properties.length; i++) {\n    var property = node.properties[i];\n    var key = getKeyName(property.key);\n    var expression = reduce(property.value);\n    properties[key] = expression;\n    if (isLiteral && expression instanceof expressions.LiteralExpression) {\n      literal[key] = expression.value;\n    } else {\n      isLiteral = false;\n    }\n  }\n  return (isLiteral) ?\n    new expressions.LiteralExpression(literal) :\n    new expressions.ObjectExpression(properties);\n}\n\nfunction getKeyName(key) {\n  return (key.type === Syntax.Identifier) ? key.name :\n    (key.type === Syntax.Literal) ? key.value :\n    unexpected(key);\n}\n\nfunction reduceSequenceExpression(node, afterSegments) {\n  // Note that sequence expressions are not reduced to a literal if they only\n  // contain literals. There isn't any utility to such an expression, so it\n  // isn't worth optimizing.\n  //\n  // The fact that expressions separated by commas always parse into a sequence\n  // is relied upon in parsing template tags that have comma-separated\n  // arguments following a keyword\n  var args = node.expressions.map(reduce);\n  return new expressions.SequenceExpression(args, afterSegments);\n}\n\nfunction unexpected(node) {\n  throw new Error('Unexpected Esprima node: ' + JSON.stringify(node, null, 2));\n}\n",
    "var htmlUtil = require('html-util');\nvar derbyTemplates = require('derby-templates');\nvar templates = derbyTemplates.templates;\nvar expressions = derbyTemplates.expressions;\nvar createPathExpression = require('./createPathExpression');\nvar markup = require('./markup');\n\nexports.createTemplate = createTemplate;\nexports.createStringTemplate = createStringTemplate;\nexports.createExpression = createExpression;\nexports.createPathExpression = createPathExpression;\nexports.markup = markup;\n\n// View.prototype._parse is defined here, so that it doesn't have to\n// be included in the client if templates are all parsed server-side\ntemplates.View.prototype._parse = function() {\n  // Wrap parsing in a try / catch to add context to message when throwing\n  var template;\n  try {\n    if (this.literal) {\n      var source = (this.unminified) ? this.source :\n        // Remove leading and trailing whitespace only lines by default\n        this.source.replace(/^\\s*\\n/, '').replace(/\\s*$/, '');\n      template = new templates.Text(source);\n    } else if (this.string) {\n      template = createStringTemplate(this.source, this);\n    } else {\n      var source = (this.unminified) ? this.source :\n        htmlUtil.minify(this.source).replace(/&sp;/g, ' ');\n      template = createTemplate(source, this);\n    }\n  } catch (err) {\n    var message = '\\n\\nWithin template \"' + this.name + '\":\\n' + this.source;\n    throw appendErrorMessage(err, message);\n  }\n  this.template = template;\n  return template;\n};\n\n// Modified and shared among the following parse functions. It's OK for this\n// to be shared at the module level, since it is only used by synchronous code\nvar parseNode;\n\nfunction createTemplate(source, view) {\n  source = escapeBraced(source);\n  parseNode = new ParseNode(view);\n  htmlUtil.parse(source, {\n    start: parseHtmlStart\n  , end: parseHtmlEnd\n  , text: parseHtmlText\n  , comment: parseHtmlComment\n  , other: parseHtmlOther\n  });\n  // Allow for certain elements at the end of a template to not be closed. This\n  // is especially important so that </body> and </html> tags can be omitted,\n  // since Derby sends an additional script tag after the HTML for the page\n  while (parseNode.parent) {\n    parseNode = parseNode.parent;\n    var last = parseNode.last();\n    if (last instanceof templates.Element) {\n      if (last.tagName === 'body' || last.tagName === 'html') {\n        last.notClosed = true;\n        last.endTag = '';\n        continue;\n      } else {\n        throw new Error('Missing closing HTML tag: ' + last.endTag);\n      }\n    }\n    unexpected();\n  }\n  return new templates.Template(parseNode.content);\n}\n\nfunction createStringTemplate(source, view) {\n  source = escapeBraced(source);\n  parseNode = new ParseNode(view);\n  parseText(source, parseTextLiteral, parseTextExpression, 'string');\n  return new templates.Template(parseNode.content);\n}\n\nfunction parseHtmlStart(tag, tagName, attributes, selfClosing) {\n  var lowerTagName = tagName.toLowerCase();\n  var hooks;\n  if (lowerTagName !== 'view' && !viewForTagName(lowerTagName)) {\n    hooks = elementHooksFromAttributes(attributes);\n  }\n  var attributesMap = parseAttributes(attributes);\n  var namespaceUri = (lowerTagName === 'svg') ?\n    templates.NAMESPACE_URIS.svg : parseNode.namespaceUri;\n  var Constructor = templates.Element;\n  if (lowerTagName === 'tag') {\n    Constructor = templates.DynamicElement;\n    tagName = attributesMap.is;\n    delete attributesMap.is;\n  }\n  if (selfClosing || templates.VOID_ELEMENTS[lowerTagName]) {\n    var element = new Constructor(tagName, attributesMap, null, hooks, selfClosing, null, namespaceUri);\n    parseNode.content.push(element);\n    parseElementClose(lowerTagName);\n  } else {\n    parseNode = parseNode.child();\n    parseNode.namespaceUri = namespaceUri;\n    var element = new Constructor(tagName, attributesMap, parseNode.content, hooks, selfClosing, null, namespaceUri);\n    parseNode.parent.content.push(element);\n  }\n}\n\nfunction parseAttributes(attributes) {\n  var attributesMap;\n  for (var key in attributes) {\n    if (!attributesMap) attributesMap = {};\n\n    var value = attributes[key];\n    var match = /([^:]+):[^:]/.exec(key);\n    var nsUri = match && templates.NAMESPACE_URIS[match[1]];\n    if (value === '' || typeof value !== 'string') {\n      attributesMap[key] = new templates.Attribute(value, nsUri);\n      continue;\n    }\n\n    parseNode = parseNode.child();\n    parseText(value, parseTextLiteral, parseTextExpression, 'attribute');\n\n    if (parseNode.content.length === 1) {\n      var item = parseNode.content[0];\n      attributesMap[key] =\n        (item instanceof templates.Text) ? new templates.Attribute(item.data, nsUri) :\n        (item instanceof templates.DynamicText) ?\n          (item.expression instanceof expressions.LiteralExpression) ?\n            new templates.Attribute(item.expression.value, nsUri) :\n            new templates.DynamicAttribute(item.expression, nsUri) :\n          new templates.DynamicAttribute(item, nsUri);\n\n    } else if (parseNode.content.length > 1) {\n      var template = new templates.Template(parseNode.content, value);\n      attributesMap[key] = new templates.DynamicAttribute(template, nsUri);\n\n    } else {\n      throw new Error('Error parsing ' + key + ' attribute: ' + value);\n    }\n\n    parseNode = parseNode.parent;\n  }\n  return attributesMap;\n}\n\nfunction parseHtmlEnd(tag, tagName) {\n  parseNode = parseNode.parent;\n  var last = parseNode.last();\n  if (!(\n    (last instanceof templates.DynamicElement && tagName.toLowerCase() === 'tag') ||\n    (last instanceof templates.Element && last.tagName === tagName)\n  )) {\n    throw new Error('Mismatched closing HTML tag: ' + tag);\n  }\n  parseElementClose(tagName);\n}\n\nfunction parseElementClose(tagName) {\n  if (tagName === 'view') {\n    var element = parseNode.content.pop();\n    parseViewElement(element);\n    return;\n  }\n  var view = viewForTagName(tagName);\n  if (view) {\n    var element = parseNode.content.pop();\n    parseNamedViewElement(element, view, view.name);\n    return;\n  }\n  var element = parseNode.last();\n  markup.emit('element', element);\n  markup.emit('element:' + tagName, element);\n}\n\nfunction viewForTagName(tagName) {\n  return parseNode.view && parseNode.view.views.tagMap[tagName];\n}\n\nfunction parseHtmlText(data, isRawText) {\n  var environment = (isRawText) ? 'string' : 'html';\n  parseText(data, parseTextLiteral, parseTextExpression, environment);\n}\n\nfunction parseHtmlComment(tag, data) {\n  // Only output comments that start with `<!--[` and end with `]-->`\n  if (!htmlUtil.isConditionalComment(tag)) return;\n  var comment = new templates.Comment(data);\n  parseNode.content.push(comment);\n}\n\nvar doctypeRegExp = /^<!DOCTYPE\\s+([^\\s]+)(?:\\s+(PUBLIC|SYSTEM)\\s+\"([^\"]+)\"(?:\\s+\"([^\"]+)\")?)?\\s*>/i;\n\nfunction parseHtmlOther(tag) {\n  var match = doctypeRegExp.exec(tag);\n  if (match) {\n    var name = match[1];\n    var idType = match[2] && match[2].toLowerCase();\n    var publicId, systemId;\n    if (idType === 'public') {\n      publicId = match[3];\n      systemId = match[4];\n    } else if (idType === 'system') {\n      systemId = match[3];\n    }\n    var doctype = new templates.Doctype(name, publicId, systemId);\n    parseNode.content.push(doctype);\n  } else {\n    unexpected(tag);\n  }\n}\n\nfunction parseTextLiteral(data) {\n  var text = new templates.Text(data);\n  parseNode.content.push(text);\n}\n\nfunction parseTextExpression(source, environment) {\n  var expression = createExpression(source);\n  if (expression.meta.blockType) {\n    parseBlockExpression(expression);\n  } else if (expression.meta.valueType === 'view') {\n    parseViewExpression(expression);\n  } else if (expression.meta.unescaped && environment === 'html') {\n    var html = new templates.DynamicHtml(expression);\n    parseNode.content.push(html);\n  } else {\n    var text = new templates.DynamicText(expression);\n    parseNode.content.push(text);\n  }\n}\n\nfunction parseBlockExpression(expression) {\n  var blockType = expression.meta.blockType;\n\n  // Block ending\n  if (expression.meta.isEnd) {\n    parseNode = parseNode.parent;\n    // Validate that the block ending matches an appropriate block start\n    var last = parseNode.last();\n    var lastExpression = last && (last.expression || (last.expressions && last.expressions[0]));\n    if (!(\n      lastExpression &&\n      (blockType === 'end' && lastExpression.meta.blockType) ||\n      (blockType === lastExpression.meta.blockType)\n    )) {\n      throw new Error('Mismatched closing template tag: ' + expression.meta.source);\n    }\n\n  // Continuing block\n  } else if (blockType === 'else' || blockType === 'else if') {\n    parseNode = parseNode.parent;\n    var last = parseNode.last();\n    parseNode = parseNode.child();\n\n    if (last instanceof templates.ConditionalBlock) {\n      last.expressions.push(expression);\n      last.contents.push(parseNode.content);\n    } else if (last instanceof templates.EachBlock) {\n      if (blockType !== 'else') unexpected(expression.meta.source);\n      last.elseContent = parseNode.content;\n    } else {\n      unexpected(expression.meta.source);\n    }\n\n  // Block start\n  } else {\n    var nextNode = parseNode.child();\n    var block;\n    if (blockType === 'if' || blockType === 'unless') {\n      block = new templates.ConditionalBlock([expression], [nextNode.content]);\n    } else if (blockType === 'each') {\n      block = new templates.EachBlock(expression, nextNode.content);\n    } else {\n      block = new templates.Block(expression, nextNode.content);\n    }\n    parseNode.content.push(block);\n    parseNode = nextNode;\n  }\n}\n\nfunction parseViewElement(element) {\n  // TODO: \"name\" is deprecated in lieu of \"is\". Remove \"name\" in Derby 0.6.0\n  var nameAttribute = element.attributes.is || element.attributes.name;\n  if (!nameAttribute) {\n    throw new Error('The <view> element requires an \"is\" attribute');\n  }\n  delete element.attributes.is;\n  delete element.attributes.name;\n\n  if (nameAttribute.expression) {\n    var viewAttributes = viewAttributesFromElement(element);\n    var componentHooks = componentHooksFromAttributes(viewAttributes);\n    var remaining = element.content || [];\n    var viewInstance = createDynamicViewInstance(nameAttribute.expression, viewAttributes, componentHooks.hooks, componentHooks.initHooks);\n    finishParseViewElement(viewAttributes, remaining, viewInstance);\n  } else {\n    var name = nameAttribute.data;\n    var view = findView(name);\n    parseNamedViewElement(element, view, name);\n  }\n}\n\nfunction findView(name) {\n  var view = parseNode.view.views.find(name, parseNode.view.namespace);\n  if (!view) {\n    var message = parseNode.view.views.findErrorMessage(name);\n    throw new Error(message);\n  }\n  return view;\n}\n\nfunction parseNamedViewElement(element, view, name) {\n  var viewAttributes = viewAttributesFromElement(element);\n  var componentHooks = componentHooksFromAttributes(viewAttributes);\n  var remaining = parseContentAttributes(element.content, view, viewAttributes);\n  var viewInstance = new templates.ViewInstance(view.registeredName, viewAttributes, componentHooks.hooks, componentHooks.initHooks);\n  finishParseViewElement(viewAttributes, remaining, viewInstance);\n}\n\nfunction createDynamicViewInstance(expression, attributes, hooks, initHooks) {\n  var viewInstance = new templates.DynamicViewInstance(expression, attributes, hooks, initHooks);\n  // Wrap the viewInstance in a block with the same expression, so that it is\n  // re-rendered when any of its dependencies change\n  return new templates.Block(expression, [viewInstance]);\n}\n\nfunction finishParseViewElement(viewAttributes, remaining, viewInstance) {\n  setContentAttribute(viewAttributes, remaining);\n  delete viewAttributes.within;\n  parseNode.content.push(viewInstance);\n}\n\nfunction setContentAttribute(attributes, content) {\n  if (attributes.hasOwnProperty('content')) return;\n  if (!content.length) return;\n  attributes.content = attributeValueFromContent(content, attributes.within);\n}\n\nfunction attributeValueFromContent(content, isWithin) {\n  // Optimize common cases where content can be a literal or a single expression\n  if (content.length === 1) {\n    var item = content[0];\n    if (item instanceof templates.Text) {\n      return item.data;\n    }\n    if (item instanceof templates.DynamicText) {\n      var expression = item.expression;\n      if (expression instanceof expressions.LiteralExpression) {\n        return expression.value;\n      }\n      // In the case of within attributes, always use a template, never an\n      // expression. A within value depends on the rendering context, so we\n      // cannot get a single value for the attribute and store it on the\n      // component model when the component is initialized\n      if (isWithin) return item;\n      // Create an expression in cases where it is safe to do so. This allows\n      // derby to get the intended value and store it on the component model\n      return new expressions.ViewParentExpression(expression);\n    }\n  }\n  // Otherwise, wrap a template as needed for the context\n  var template = new templates.Template(content);\n  return (isWithin) ? template : new templates.ViewParent(template);\n}\n\nfunction viewAttributesFromElement(element) {\n  var viewAttributes = {};\n  for (var key in element.attributes) {\n    var attribute = element.attributes[key];\n    var camelCased = dashToCamelCase(key);\n    viewAttributes[camelCased] =\n      (attribute.expression instanceof templates.Template) ?\n        new templates.ViewParent(attribute.expression) :\n      (attribute.expression instanceof expressions.Expression) ?\n        new expressions.ViewParentExpression(attribute.expression) :\n      attribute.data;\n  }\n  return viewAttributes;\n}\n\nfunction parseAsAttribute(key, value) {\n  var expression = createPathExpression(value);\n  if (!(expression instanceof expressions.PathExpression)) {\n    throw new Error(key + ' attribute must be a path: ' + key + '=\"' + value + '\"');\n  }\n  return expression.segments;\n}\n\nfunction parseAsObjectAttribute(key, value) {\n  var expression = createPathExpression(value);\n  if (!(\n    expression instanceof expressions.SequenceExpression &&\n    expression.args.length === 2 &&\n    expression.args[0] instanceof expressions.PathExpression\n  )) {\n    throw new Error(key + ' attribute requires a path and a key argument: ' + key + '=\"' + value + '\"');\n  }\n  var segments = expression.args[0].segments;\n  var expression = expression.args[1];\n  return {segments: segments, expression: expression};\n}\n\nfunction parseOnAttribute(key, value) {\n  // TODO: Argument checking\n  return createPathExpression(value);\n}\n\nfunction elementHooksFromAttributes(attributes, type) {\n  if (!attributes) return;\n  var hooks = [];\n\n  for (var key in attributes) {\n    var value = attributes[key];\n\n    // Parse `as` assignments\n    if (key === 'as') {\n      var segments = parseAsAttribute(key, value);\n      hooks.push(new templates.AsProperty(segments));\n      delete attributes[key];\n      continue;\n    }\n    if (key === 'as-array') {\n      var segments = parseAsAttribute(key, value);\n      hooks.push(new templates.AsArray(segments));\n      delete attributes[key];\n      continue;\n    }\n    if (key === 'as-object') {\n      var parsed = parseAsObjectAttribute(key, value);\n      hooks.push(new templates.AsObject(parsed.segments, parsed.expression));\n      delete attributes[key];\n      continue;\n    }\n\n    // Parse event listeners\n    var match = /^on-(.+)/.exec(key);\n    var eventName = match && match[1];\n    if (eventName) {\n      var expression = parseOnAttribute(key, value);\n      hooks.push(new templates.ElementOn(eventName, expression));\n      delete attributes[key];\n    }\n  }\n\n  if (hooks.length) return hooks;\n}\n\nfunction componentHooksFromAttributes(attributes) {\n  if (!attributes) return {};\n  var hooks = [];\n  var initHooks = [];\n\n  for (var key in attributes) {\n    var value = attributes[key];\n\n    // Parse `as` assignments\n    if (key === 'as') {\n      var segments = parseAsAttribute(key, value);\n      hooks.push(new templates.AsProperty(segments));\n      delete attributes[key];\n      continue;\n    }\n    if (key === 'asArray') {\n      var segments = parseAsAttribute('as-array', value);\n      hooks.push(new templates.AsArrayComponent(segments));\n      delete attributes[key];\n      continue;\n    }\n    if (key === 'asObject') {\n      var parsed = parseAsObjectAttribute('as-object', value);\n      hooks.push(new templates.AsObjectComponent(parsed.segments, parsed.expression));\n      delete attributes[key];\n      continue;\n    }\n\n    // Parse event listeners\n    var match = /^on([A-Z_].*)/.exec(key);\n    var eventName = match && match[1].charAt(0).toLowerCase() + match[1].slice(1);\n    if (eventName) {\n      var expression = parseOnAttribute(key, value);\n      initHooks.push(new templates.ComponentOn(eventName, expression));\n      delete attributes[key];\n    }\n  }\n\n  return {\n    hooks: (hooks.length) ? hooks : null,\n    initHooks: (initHooks.length) ? initHooks : null\n  };\n}\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-./g, function(match) {\n    return match.charAt(1).toUpperCase();\n  });\n}\n\nfunction parseContentAttributes(content, view, viewAttributes) {\n  var remaining = [];\n  if (!content) return remaining;\n  for (var i = 0, len = content.length; i < len; i++) {\n    var item = content[i];\n    var name = (item instanceof templates.Element) && item.tagName;\n\n    if (name === 'attribute') {\n      var name = parseNameAttribute(item);\n      parseAttributeElement(item, name, viewAttributes);\n\n    } else if (view.attributesMap && view.attributesMap[name]) {\n      parseAttributeElement(item, name, viewAttributes);\n\n    } else if (name === 'array') {\n      var name = parseNameAttribute(item);\n      parseArrayElement(item, name, viewAttributes);\n\n    } else if (view.arraysMap && view.arraysMap[name]) {\n      parseArrayElement(item, view.arraysMap[name], viewAttributes);\n\n    } else {\n      remaining.push(item);\n    }\n  }\n  return remaining;\n}\n\nfunction parseNameAttribute(element) {\n  // TODO: \"name\" is deprecated in lieu of \"is\". Remove \"name\" in Derby 0.6.0\n  var nameAttribute = element.attributes.is || element.attributes.name;\n  var name = nameAttribute.data;\n  if (!name) {\n    throw new Error('The <' + element.tagName + '> element requires a literal \"is\" attribute');\n  }\n  delete element.attributes.is;\n  delete element.attributes.name;\n  return name;\n}\n\nfunction parseAttributeElement(element, name, viewAttributes) {\n  var camelName = dashToCamelCase(name);\n  var isWithin = element.attributes && element.attributes.within;\n  viewAttributes[camelName] = attributeValueFromContent(element.content, isWithin);\n}\n\nfunction createAttributesExpression(attributes) {\n  var dynamicAttributes = {};\n  var literalAttributes = {};\n  var isLiteral = true;\n  for (var key in attributes) {\n    var attribute = attributes[key];\n    if (attribute instanceof expressions.Expression) {\n      dynamicAttributes[key] = attribute;\n      isLiteral = false;\n    } else if (attribute instanceof templates.Template) {\n      dynamicAttributes[key] = new expressions.DeferRenderExpression(attribute);\n      isLiteral = false;\n    } else {\n      dynamicAttributes[key] = new expressions.LiteralExpression(attribute);\n      literalAttributes[key] = attribute;\n    }\n  }\n  return (isLiteral) ?\n    new expressions.LiteralExpression(literalAttributes) :\n    new expressions.ObjectExpression(dynamicAttributes);\n}\n\nfunction parseArrayElement(element, name, viewAttributes) {\n  var attributes = viewAttributesFromElement(element);\n  setContentAttribute(attributes, element.content);\n  delete attributes.within;\n  var expression = createAttributesExpression(attributes);\n  var camelName = dashToCamelCase(name);\n  var viewAttribute = viewAttributes[camelName];\n\n  // If viewAttribute is already an ArrayExpression, push the expression for\n  // the current array element\n  if (viewAttribute instanceof expressions.ArrayExpression) {\n    viewAttribute.items.push(expression);\n\n  // Alternatively, viewAttribute will be an array if its items have all been\n  // literal values thus far\n  } else if (Array.isArray(viewAttribute)) {\n    if (expression instanceof expressions.LiteralExpression) {\n      // If the current array element continues to be a literal value, push it\n      // on the existing array\n      viewAttribute.push(expression.value);\n    } else {\n      // However, if the array element produces a non-literal expression,\n      // convert the values in the array into an equivalent ArrayExpression of\n      // LiteralExpressions, then push on this expression as well\n      var items = [];\n      for (var i = 0; i < viewAttribute.length; i++) {\n        items[i] = new expressions.LiteralExpression(viewAttribute[i]);\n      }\n      items.push(expression);\n      viewAttributes[camelName] = new expressions.ArrayExpression(items);\n    }\n\n  // For the first array element encountered, create a containing array or\n  // ArrayExpression. Create an array of raw values in the literal case and an\n  // ArrayExpression of expressions in the non-literal case\n  } else if (viewAttribute == null) {\n    viewAttributes[camelName] = (expression instanceof expressions.LiteralExpression) ?\n      [expression.value] : new expressions.ArrayExpression([expression]);\n\n  } else {\n    unexpected();\n  }\n}\n\nfunction parseViewExpression(expression) {\n  // If there are multiple arguments separated by commas, they will get parsed\n  // as a SequenceExpression\n  var nameExpression, attributesExpression;\n  if (expression instanceof expressions.SequenceExpression) {\n    nameExpression = expression.args[0];\n    attributesExpression = expression.args[1];\n  } else {\n    nameExpression = expression;\n  }\n\n  var viewAttributes = viewAttributesFromExpression(attributesExpression);\n  var componentHooks = componentHooksFromAttributes(viewAttributes);\n\n  // A ViewInstance has a static name, and a DynamicViewInstance gets its name\n  // at render time\n  var viewInstance;\n  if (nameExpression instanceof expressions.LiteralExpression) {\n    var name = nameExpression.get();\n    // Will throw if the view can't be found immediately\n    findView(name);\n    viewInstance = new templates.ViewInstance(name, viewAttributes, componentHooks.hooks, componentHooks.initHooks);\n  } else {\n    viewInstance = createDynamicViewInstance(nameExpression, viewAttributes, componentHooks.hooks, componentHooks.initHooks);\n  }\n  parseNode.content.push(viewInstance);\n}\n\nfunction viewAttributesFromExpression(expression) {\n  if (!expression) return;\n  var object = (expression instanceof expressions.ObjectExpression) ? expression.properties :\n    (expression instanceof expressions.LiteralExpression) ? expression.value : null;\n  if (typeof object !== 'object') unexpected();\n\n  var viewAttributes = {};\n  for (var key in object) {\n    var value = object[key];\n    viewAttributes[key] =\n      (value instanceof expressions.LiteralExpression) ? value.value :\n      (value instanceof expressions.Expression) ?\n        new expressions.ViewParentExpression(value) :\n      value;\n  }\n  return viewAttributes;\n}\n\nfunction ParseNode(view, parent) {\n  this.view = view;\n  this.parent = parent;\n  this.content = [];\n  this.namespaceUri = parent && parent.namespaceUri;\n}\nParseNode.prototype.child = function() {\n  return new ParseNode(this.view, this);\n};\nParseNode.prototype.last = function() {\n  return this.content[this.content.length - 1];\n};\n\nfunction escapeBraced(source) {\n  var out = '';\n  parseText(source, onLiteral, onExpression, 'string');\n  function onLiteral(text) {\n    out += text;\n  }\n  function onExpression(text) {\n    var escaped = text.replace(/[&<]/g, function(match) {\n      return (match === '&') ? '&amp;' : '&lt;';\n    });\n    out += '{{' + escaped + '}}';\n  }\n  return out;\n}\n\nfunction unescapeBraced(source) {\n  return source.replace(/(?:&amp;|&lt;)/g, function(match) {\n    return (match === '&amp;') ? '&' : '<';\n  });\n}\n\nfunction unescapeTextLiteral(text, environment) {\n  return (environment === 'html' || environment === 'attribute') ?\n    htmlUtil.unescapeEntities(text) :\n    text;\n}\n\nfunction parseText(data, onLiteral, onExpression, environment) {\n  var current = data;\n  var last;\n  while (current) {\n    if (current === last) throw new Error('Error parsing template text: ' + data);\n    last = current;\n\n    var start = current.indexOf('{{');\n    if (start === -1) {\n      var unescapedCurrent = unescapeTextLiteral(current, environment);\n      onLiteral(unescapedCurrent);\n      return;\n    }\n\n    var end = matchBraces(current, 2, start, '{', '}');\n    if (end === -1) throw new Error('Mismatched braces in: ' + data);\n\n    if (start > 0) {\n      var before = current.slice(0, start);\n      var unescapedBefore = unescapeTextLiteral(before, environment);\n      onLiteral(unescapedBefore);\n    }\n\n    var inside = current.slice(start + 2, end - 2);\n    if (inside) {\n      var unescapedInside = unescapeBraced(inside);\n      unescapedInside = unescapeTextLiteral(unescapedInside, environment);\n      onExpression(unescapedInside, environment);\n    }\n\n    current = current.slice(end);\n  }\n}\n\nfunction matchBraces(text, num, i, openChar, closeChar) {\n  i += num;\n  while (num) {\n    var close = text.indexOf(closeChar, i);\n    var open = text.indexOf(openChar, i);\n    var hasClose = close !== -1;\n    var hasOpen = open !== -1;\n    if (hasClose && (!hasOpen || (close < open))) {\n      i = close + 1;\n      num--;\n      continue;\n    } else if (hasOpen) {\n      i = open + 1;\n      num++;\n      continue;\n    } else {\n      return -1;\n    }\n  }\n  return i;\n}\n\nvar blockRegExp = /^(if|unless|else if|each|with|on)\\s+([\\s\\S]+?)(?:\\s+as\\s+([^,\\s]+)\\s*(?:,\\s*(\\S+))?)?$/;\nvar valueRegExp = /^(?:(view|unbound|bound|unescaped)\\s+)?([\\s\\S]*)/;\n\nfunction createExpression(source) {\n  source = source.trim();\n  var meta = new expressions.ExpressionMeta(source);\n\n  // Parse block expression //\n\n  // The block expressions `if`, `unless`, `else if`, `each`, `with`, and `on`\n  // must have a single blockType keyword and a path. They may have an optional\n  // alias assignment\n  var match = blockRegExp.exec(source);\n  var path, as, keyAs;\n  if (match) {\n    meta.blockType = match[1];\n    path = match[2];\n    as = match[3];\n    keyAs = match[4];\n\n  // The blocks `else`, `unbound`, and `bound` may not have a path or alias\n  } else if (source === 'else' || source === 'unbound' || source === 'bound') {\n    meta.blockType = source;\n\n  // Any source that starts with a `/` is treated as an end block. Either a\n  // `{{/}}` with no following characters or a `{{/if}}` style ending is valid\n  } else if (source.charAt(0) === '/') {\n    meta.isEnd = true;\n    meta.blockType = source.slice(1).trim() || 'end';\n\n\n  // Parse value expression //\n\n  // A value expression has zero or many keywords and an expression\n  } else {\n    path = source;\n    var keyword;\n    do {\n      match = valueRegExp.exec(path);\n      keyword = match[1];\n      path = match[2];\n      if (keyword === 'unescaped') {\n        meta.unescaped = true;\n      } else if (keyword === 'unbound' || keyword === 'bound') {\n        meta.bindType = keyword;\n      } else if (keyword) {\n        meta.valueType = keyword;\n      }\n    } while (keyword);\n  }\n\n  // Wrap parsing in a try / catch to add context to message when throwing\n  var expression;\n  try {\n    expression = (path) ?\n      createPathExpression(path) :\n      new expressions.Expression();\n    if (as) {\n      meta.as = parseAlias(as);\n    }\n    if (keyAs) {\n      meta.keyAs = parseAlias(keyAs);\n    }\n  } catch (err) {\n    var message = '\\n\\nWithin expression: ' + source;\n    throw appendErrorMessage(err, message);\n  }\n  expression.meta = meta;\n  return expression;\n}\n\nfunction unexpected(source) {\n  throw new Error('Error parsing template: ' + source);\n}\n\nfunction appendErrorMessage(err, message) {\n  if (err instanceof Error) {\n    err.message += message;\n    return err;\n  }\n  return new Error(err + message);\n}\n\nfunction parseAlias(source) {\n  // Try parsing into a path expression. This throws on invalid expressions.\n  var expression = createPathExpression(source);\n  // Verify that it's an AliasPathExpression with no segments, i.e. that\n  // it has the format \"#IDENTIFIER\".\n  if (expression instanceof expressions.AliasPathExpression) {\n    if (expression.segments.length === 0) {\n      return expression.alias;\n    }\n    throw new Error('Alias must not have dots or brackets: ' + source);\n  }\n  throw new Error('Alias must be an identifier starting with \"#\": ' + source);\n}\n",
    "var EventEmitter = require('events').EventEmitter;\nvar templates = require('derby-templates').templates;\nvar createPathExpression = require('./createPathExpression');\n\n// TODO: Should be its own module\n\nvar markup = module.exports = new MarkupParser();\n\nfunction MarkupParser() {\n  EventEmitter.call(this);\n}\nmergeInto(MarkupParser.prototype, EventEmitter.prototype);\n\nmarkup.on('element:a', function(template) {\n  if (hasListenerFor(template, 'click')) {\n    var attributes = template.attributes || (template.attributes = {});\n    if (!attributes.href) {\n      attributes.href = new templates.Attribute('#');\n      addListener(template, 'click', '$preventDefault($event)');\n    }\n  }\n});\n\nmarkup.on('element:form', function(template) {\n  if (hasListenerFor(template, 'submit')) {\n    addListener(template, 'submit', '$preventDefault($event)');\n  }\n});\n\nfunction hasListenerFor(template, eventName) {\n  var hooks = template.hooks;\n  if (!hooks) return false;\n  for (var i = 0, len = hooks.length; i < len; i++) {\n    var hook = hooks[i];\n    if (hook instanceof templates.ElementOn && hook.name === eventName) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction addListener(template, eventName, source) {\n  var hooks = template.hooks || (template.hooks = []);\n  var expression = createPathExpression(source);\n  hooks.push(new templates.ElementOn(eventName, expression));\n}\n\nfunction mergeInto(to, from) {\n  for (var key in from) {\n    to[key] = from[key];\n  }\n  return to;\n}\n",
    "exports.contexts = require('./lib/contexts');\nexports.expressions = require('./lib/expressions');\nexports.operatorFns = require('./lib/operatorFns');\nexports.options = require('./lib/options');\nexports.templates = require('./lib/templates');\n",
    "exports.ContextMeta = ContextMeta;\nexports.Context = Context;\n\nfunction noop() {}\n\n// TODO:\n// Implement removeItemContext\n\nfunction ContextMeta() {\n  this.addBinding = noop;\n  this.removeBinding = noop;\n  this.removeNode = noop;\n  this.addItemContext = noop;\n  this.removeItemContext = noop;\n  this.views = null;\n  this.idNamespace = '';\n  this.idCount = 0;\n  this.pending = [];\n  this.pauseCount = 0;\n}\n\nfunction Context(meta, controller, parent, unbound, expression) {\n  // Required properties //\n\n  // Properties which are globally inherited for the entire page\n  this.meta = meta;\n  // The page or component. Must have a `model` property with a `data` property\n  this.controller = controller;\n\n  // Optional properties //\n\n  // Containing context\n  this.parent = parent;\n  // Boolean set to true when bindings should be ignored\n  this.unbound = unbound;\n  // The expression for a block\n  this.expression = expression;\n  // Alias name for the given expression\n  this.alias = expression && expression.meta && expression.meta.as;\n  // Alias name for the index or iterated key\n  this.keyAlias = expression && expression.meta && expression.meta.keyAs;\n\n  // For Context::eachChild\n  // The context of the each at render time\n  this.item = null;\n\n  // For Context::viewChild\n  // Reference to the current view\n  this.view = null;\n  // Attribute values passed to the view instance\n  this.attributes = null;\n  // MarkupHooks to be called after insert into DOM of component\n  this.hooks = null;\n  // MarkupHooks to be called immediately before init of component\n  this.initHooks = null;\n\n  // For Context::closureChild\n  // Reference to another context established at render time by ContextClosure\n  this.closure = null;\n\n  // Used in EventModel\n  this._id = null;\n}\n\nContext.prototype.id = function() {\n  var count = ++this.meta.idCount;\n  return this.meta.idNamespace + '_' + count.toString(36);\n};\n\nContext.prototype.addBinding = function(binding) {\n  // Don't add bindings that wrap list items. Only their outer range is needed\n  if (binding.itemFor) return;\n  var expression = binding.template.expression;\n  // Don't rerender in unbound sections\n  if (expression ? expression.isUnbound(this) : this.unbound) return;\n  // Don't rerender to changes in a with expression\n  if (expression && expression.meta && expression.meta.blockType === 'with') return;\n  this.meta.addBinding(binding);\n};\nContext.prototype.removeBinding = function(binding) {\n  this.meta.removeBinding(binding);\n};\nContext.prototype.removeNode = function(node) {\n  this.meta.removeNode(node);\n};\n\nContext.prototype.child = function(expression) {\n  // Set or inherit the binding mode\n  var blockType = expression.meta && expression.meta.blockType;\n  var unbound = (blockType === 'unbound') ? true :\n    (blockType === 'bound') ? false :\n    this.unbound;\n  return new Context(this.meta, this.controller, this, unbound, expression);\n};\n\nContext.prototype.componentChild = function(component) {\n  return new Context(this.meta, component, this, this.unbound);\n};\n\n// Make a context for an item in an each block\nContext.prototype.eachChild = function(expression, item) {\n  var context = new Context(this.meta, this.controller, this, this.unbound, expression);\n  context.item = item;\n  this.meta.addItemContext(context);\n  return context;\n};\n\nContext.prototype.viewChild = function(view, attributes, hooks, initHooks) {\n  var context = new Context(this.meta, this.controller, this, this.unbound);\n  context.view = view;\n  context.attributes = attributes;\n  context.hooks = hooks;\n  context.initHooks = initHooks;\n  return context;\n};\n\nContext.prototype.closureChild = function(closure) {\n  var context = new Context(this.meta, this.controller, this, this.unbound);\n  context.closure = closure;\n  return context;\n};\n\nContext.prototype.forRelative = function(expression) {\n  var context = this;\n  while (context && context.expression === expression || context.view) {\n    context = context.parent;\n  }\n  return context;\n};\n\n// Returns the closest context which defined the named alias\nContext.prototype.forAlias = function(alias) {\n  var context = this;\n  while (context) {\n    if (context.alias === alias || context.keyAlias === alias) return context;\n    context = context.parent;\n  }\n};\n\n// Returns the closest containing context for a view attribute name or nothing\nContext.prototype.forAttribute = function(attribute) {\n  var context = this;\n  while (context) {\n    // Find the closest context associated with a view\n    if (context.view) {\n      var attributes = context.attributes;\n      if (!attributes) return;\n      if (attributes.hasOwnProperty(attribute)) return context;\n      // If the attribute isn't found, but the attributes inherit, continue\n      // looking in the next closest view context\n      if (!attributes.inherit && !attributes.extend) return;\n    }\n    context = context.parent;\n  }\n};\n\nContext.prototype.forViewParent = function() {\n  var context = this;\n  while (context) {\n    // When a context with a `closure` property is encountered, skip to its\n    // parent context rather than returning the nearest view's. This reference\n    // is created by wrapping a template in a ContextClosure template\n    if (context.closure) return context.closure.parent;\n    // Find the closest view and return the containing context\n    if (context.view) return context.parent;\n    context = context.parent;\n  }\n};\n\nContext.prototype.getView = function() {\n  var context = this;\n  while (context) {\n    // Find the closest view\n    if (context.view) return context.view;\n    context = context.parent;\n  }\n};\n\n// Returns the `this` value for a context\nContext.prototype.get = function() {\n  var value = (this.expression) ?\n    this.expression.get(this) :\n    this.controller.model.data;\n  if (this.item != null) {\n    return value && value[this.item];\n  }\n  return value;\n};\n\nContext.prototype.pause = function() {\n  this.meta.pauseCount++;\n};\n\nContext.prototype.unpause = function() {\n  if (--this.meta.pauseCount) return;\n  this.flush();\n};\n\nContext.prototype.flush = function() {\n  var pending = this.meta.pending;\n  var len = pending.length;\n  if (!len) return;\n  this.meta.pending = [];\n  for (var i = 0; i < len; i++) {\n    pending[i]();\n  }\n};\n\nContext.prototype.queue = function(cb) {\n  this.meta.pending.push(cb);\n};\n",
    "var serializeObject = require('serialize-object');\nvar operatorFns = require('./operatorFns');\nvar templates = require('./templates');\nvar Template = templates.Template;\nvar util = require('./util');\nvar concat = util.concat;\n\nexports.lookup = lookup;\nexports.templateTruthy = templateTruthy;\nexports.pathSegments = pathSegments;\nexports.renderValue = renderValue;\nexports.renderTemplate = renderTemplate;\nexports.ExpressionMeta = ExpressionMeta;\n\nexports.Expression = Expression;\nexports.LiteralExpression = LiteralExpression;\nexports.PathExpression = PathExpression;\nexports.RelativePathExpression = RelativePathExpression;\nexports.AliasPathExpression = AliasPathExpression;\nexports.AttributePathExpression = AttributePathExpression;\nexports.BracketsExpression = BracketsExpression;\nexports.DeferRenderExpression = DeferRenderExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.FnExpression = FnExpression;\nexports.OperatorExpression = OperatorExpression;\nexports.NewExpression = NewExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ViewParentExpression = ViewParentExpression;\nexports.ScopedModelExpression = ScopedModelExpression;\n\nfunction lookup(segments, value) {\n  if (!segments) return value;\n\n  for (var i = 0, len = segments.length; i < len; i++) {\n    if (value == null) return value;\n    value = value[segments[i]];\n  }\n  return value;\n}\n\n// Unlike JS, `[]` is falsey. Otherwise, truthiness is the same as JS\nfunction templateTruthy(value) {\n  return (Array.isArray(value)) ? value.length > 0 : !!value;\n}\n\nfunction pathSegments(segments) {\n  var result = [];\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    result[i] = (typeof segment === 'object') ? segment.item : segment;\n  }\n  return result;\n}\n\nfunction renderValue(value, context) {\n  return (typeof value !== 'object') ? value :\n    (value instanceof Template) ? renderTemplate(value, context) :\n    (Array.isArray(value)) ? renderArray(value, context) :\n    renderObject(value, context);\n}\nfunction renderTemplate(value, context) {\n  var i = 1000;\n  while (value instanceof Template) {\n    if (--i < 0) throw new Error('Maximum template render passes exceeded');\n    value = value.get(context, true);\n  }\n  return value;\n}\nfunction renderArray(array, context) {\n  for (var i = 0; i < array.length; i++) {\n    if (hasTemplateProperty(array[i])) {\n      return renderArrayProperties(array, context);\n    }\n  }\n  return array;\n}\nfunction renderObject(object, context) {\n  return (hasTemplateProperty(object)) ?\n    renderObjectProperties(object, context) : object;\n}\nfunction hasTemplateProperty(object) {\n  if (!object) return false;\n  if (object.constructor !== Object) return false;\n  for (var key in object) {\n    if (object[key] instanceof Template) return true;\n  }\n  return false;\n}\nfunction renderArrayProperties(array, context) {\n  var out = new Array(array.length);\n  for (var i = 0; i < array.length; i++) {\n    out[i] = renderValue(array[i], context);\n  }\n  return out;\n}\nfunction renderObjectProperties(object, context) {\n  var out = {};\n  for (var key in object) {\n    out[key] = renderValue(object[key], context);\n  }\n  return out;\n}\n\nfunction ExpressionMeta(source, blockType, isEnd, as, keyAs, unescaped, bindType, valueType) {\n  this.source = source;\n  this.blockType = blockType;\n  this.isEnd = isEnd;\n  this.as = as;\n  this.keyAs = keyAs;\n  this.unescaped = unescaped;\n  this.bindType = bindType;\n  this.valueType = valueType;\n}\nExpressionMeta.prototype.module = 'expressions';\nExpressionMeta.prototype.type = 'ExpressionMeta';\nExpressionMeta.prototype.serialize = function() {\n  return serializeObject.instance(\n    this\n  , this.source\n  , this.blockType\n  , this.isEnd\n  , this.as\n  , this.keyAs\n  , this.unescaped\n  , this.bindType\n  , this.valueType\n  );\n};\n\nfunction Expression(meta) {\n  this.meta = meta;\n}\nExpression.prototype.module = 'expressions';\nExpression.prototype.type = 'Expression';\nExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.meta);\n};\nExpression.prototype.toString = function() {\n  return this.meta && this.meta.source;\n};\nExpression.prototype.truthy = function(context) {\n  var blockType = this.meta.blockType;\n  if (blockType === 'else') return true;\n  var value = this.get(context, true);\n  var truthy = templateTruthy(value);\n  return (blockType === 'unless') ? !truthy : truthy;\n};\nExpression.prototype.get = function() {};\n// Return the expression's segment list with context objects\nExpression.prototype.resolve = function() {};\n// Return a list of segment lists or null\nExpression.prototype.dependencies = function() {};\n// Return the pathSegments that the expression currently resolves to or null\nExpression.prototype.pathSegments = function(context) {\n  var segments = this.resolve(context);\n  return segments && pathSegments(segments);\n};\nExpression.prototype.set = function(context, value) {\n  var segments = this.pathSegments(context);\n  if (!segments) throw new Error('Expression does not support setting');\n  context.controller.model._set(segments, value);\n};\nExpression.prototype._resolvePatch = function(context, segments) {\n  return (context && context.expression === this && context.item != null) ?\n    segments.concat(context) : segments;\n};\nExpression.prototype.isUnbound = function(context) {\n  // If the template being rendered has an explicit bindType keyword, such as:\n  // {{unbound #item.text}}\n  var bindType = this.meta && this.meta.bindType;\n  if (bindType === 'unbound') return true;\n  if (bindType === 'bound') return false;\n  // Otherwise, inherit from the context\n  return context.unbound;\n};\nExpression.prototype._lookupAndContextifyValue = function(value, context) {\n  if (this.segments && this.segments.length) {\n    // If expression has segments, e.g. `bar.baz` in `#foo.bar.baz`, then\n    // render the base value (e.g. `#foo`) if it's a template and look up the\n    // value at the indicated path.\n    value = renderTemplate(value, context);\n    value = lookup(this.segments, value);\n  }\n  if (value instanceof Template && !(value instanceof templates.ContextClosure)) {\n    // If we're not immediately rendering the template, then create a ContextClosure\n    // so that the value renders with the correct context later.\n    value = new templates.ContextClosure(value, context);\n  }\n  return value;\n};\n\n\nfunction LiteralExpression(value, meta) {\n  this.value = value;\n  this.meta = meta;\n}\nLiteralExpression.prototype = Object.create(Expression.prototype);\nLiteralExpression.prototype.constructor = LiteralExpression;\nLiteralExpression.prototype.type = 'LiteralExpression';\nLiteralExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.value, this.meta);\n};\nLiteralExpression.prototype.get = function() {\n  return this.value;\n};\n\nfunction PathExpression(segments, meta) {\n  this.segments = segments;\n  this.meta = meta;\n}\nPathExpression.prototype = Object.create(Expression.prototype);\nPathExpression.prototype.constructor = PathExpression;\nPathExpression.prototype.type = 'PathExpression';\nPathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.meta);\n};\nPathExpression.prototype.get = function(context) {\n  // See View::dependencies. This is needed in order to handle the case of\n  // getting dependencies within a component template, in which case we cannot\n  // access model data separate from rendering.\n  if (!context.controller) return;\n  return lookup(this.segments, context.controller.model.data);\n};\nPathExpression.prototype.resolve = function(context) {\n  // See View::dependencies. This is needed in order to handle the case of\n  // getting dependencies within a component template, in which case we cannot\n  // access model data separate from rendering.\n  if (!context.controller) return;\n  var segments = concat(context.controller._scope, this.segments);\n  return this._resolvePatch(context, segments);\n};\nPathExpression.prototype.dependencies = function(context, options) {\n  // See View::dependencies. This is needed in order to handle the case of\n  // getting dependencies within a component template, in which case we cannot\n  // access model data separate from rendering.\n  if (!context.controller) return;\n  var value = lookup(this.segments, context.controller.model.data);\n  var dependencies = getDependencies(value, context, options);\n  return appendDependency(dependencies, this, context);\n};\n\nfunction RelativePathExpression(segments, meta) {\n  this.segments = segments;\n  this.meta = meta;\n}\nRelativePathExpression.prototype = Object.create(Expression.prototype);\nRelativePathExpression.prototype.constructor = RelativePathExpression;\nRelativePathExpression.prototype.type = 'RelativePathExpression';\nRelativePathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.meta);\n};\nRelativePathExpression.prototype.get = function(context) {\n  var relativeContext = context.forRelative(this);\n  var value = relativeContext.get();\n  return this._lookupAndContextifyValue(value, relativeContext);\n};\nRelativePathExpression.prototype.resolve = function(context) {\n  var relativeContext = context.forRelative(this);\n  var base = (relativeContext.expression) ?\n    relativeContext.expression.resolve(relativeContext) :\n    [];\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nRelativePathExpression.prototype.dependencies = function(context, options) {\n  // Return inner dependencies from our ancestor\n  // (e.g., {{ with foo[bar] }} ... {{ this.x }} has 'bar' as a dependency.)\n  var relativeContext = context.forRelative(this);\n  var dependencies = relativeContext.expression &&\n    relativeContext.expression.dependencies(relativeContext, options);\n  return swapLastDependency(dependencies, this, context);\n};\n\nfunction AliasPathExpression(alias, segments, meta) {\n  this.alias = alias;\n  this.segments = segments;\n  this.meta = meta;\n}\nAliasPathExpression.prototype = Object.create(Expression.prototype);\nAliasPathExpression.prototype.constructor = AliasPathExpression;\nAliasPathExpression.prototype.type = 'AliasPathExpression';\nAliasPathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.alias, this.segments, this.meta);\n};\nAliasPathExpression.prototype.get = function(context) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) {\n    return aliasContext.item;\n  }\n  var value = aliasContext.get();\n  return this._lookupAndContextifyValue(value, aliasContext);\n};\nAliasPathExpression.prototype.resolve = function(context) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) return;\n  var base = aliasContext.expression.resolve(aliasContext);\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nAliasPathExpression.prototype.dependencies = function(context, options) {\n  var aliasContext = context.forAlias(this.alias);\n  if (!aliasContext) return;\n  if (aliasContext.keyAlias === this.alias) {\n    // For keyAliases, use a dependency of the entire list, so that it will\n    // always update when the list itself changes. This is over-binding, but\n    // would otherwise be much more complex\n    var base = aliasContext.expression.resolve(aliasContext.parent);\n    if (!base) return;\n    return [base];\n  }\n\n  var dependencies = aliasContext.expression.dependencies(aliasContext, options);\n  return swapLastDependency(dependencies, this, context);\n};\n\nfunction AttributePathExpression(attribute, segments, meta) {\n  this.attribute = attribute;\n  this.segments = segments;\n  this.meta = meta;\n}\nAttributePathExpression.prototype = Object.create(Expression.prototype);\nAttributePathExpression.prototype.constructor = AttributePathExpression;\nAttributePathExpression.prototype.type = 'AttributePathExpression';\nAttributePathExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.attribute, this.segments, this.meta);\n};\nAttributePathExpression.prototype.get = function(context) {\n  var attributeContext = context.forAttribute(this.attribute);\n  if (!attributeContext) return;\n  var value = attributeContext.attributes[this.attribute];\n  if (value instanceof Expression) {\n    value = value.get(attributeContext);\n  }\n  return this._lookupAndContextifyValue(value, attributeContext);\n};\nAttributePathExpression.prototype.resolve = function(context) {\n  var attributeContext = context.forAttribute(this.attribute);\n  if (!attributeContext) return;\n  // Attributes may be a template, an expression, or a literal value\n  var base;\n  var value = attributeContext.attributes[this.attribute];\n  if (value instanceof Expression || value instanceof Template) {\n    base = value.resolve(attributeContext);\n  }\n  if (!base) return;\n  var segments = base.concat(this.segments);\n  return this._resolvePatch(context, segments);\n};\nAttributePathExpression.prototype.dependencies = function(context, options) {\n  var attributeContext = context.forAttribute(this.attribute);\n  if (!attributeContext) return;\n\n  // Attributes may be a template, an expression, or a literal value\n  var value = attributeContext.attributes[this.attribute];\n  var dependencies = getDependencies(value, attributeContext, options);\n  return swapLastDependency(dependencies, this, context);\n};\n\nfunction BracketsExpression(before, inside, afterSegments, meta) {\n  this.before = before;\n  this.inside = inside;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nBracketsExpression.prototype = Object.create(Expression.prototype);\nBracketsExpression.prototype.constructor = BracketsExpression;\nBracketsExpression.prototype.type = 'BracketsExpression';\nBracketsExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.before, this.inside, this.afterSegments, this.meta);\n};\nBracketsExpression.prototype.get = function(context) {\n  var inside = this.inside.get(context);\n  if (inside == null) return;\n  var before = this.before.get(context);\n  if (!before) return;\n  var base = before[inside];\n  return (this.afterSegments) ? lookup(this.afterSegments, base) : base;\n};\nBracketsExpression.prototype.resolve = function(context) {\n  // Get and split the current value of the expression inside the brackets\n  var inside = this.inside.get(context);\n  if (inside == null) return;\n\n  // Concat the before, inside, and optional after segments\n  var base = this.before.resolve(context);\n  if (!base) return;\n  var segments = (this.afterSegments) ?\n    base.concat(inside, this.afterSegments) :\n    base.concat(inside);\n  return this._resolvePatch(context, segments);\n};\nBracketsExpression.prototype.dependencies = function(context, options) {\n  var before = this.before.dependencies(context, options);\n  if (before) before.pop();\n  var inner = this.inside.dependencies(context, options);\n  var dependencies = concat(before, inner);\n  return appendDependency(dependencies, this, context);\n};\n\n// This Expression is used to wrap a template so that when its containing\n// Expression--such as an ObjectExpression or ArrayExpression--is evaluated,\n// it returns the template unrendered and wrapped in the current context.\n// Separating evaluation of the containing expression from template rendering\n// is used to support array attributes of views. This way, we can evaluate an\n// array and iterate through it separately from rendering template content\nfunction DeferRenderExpression(template, meta) {\n  if (!(template instanceof Template)) {\n    throw new Error('DeferRenderExpression requires a Template argument');\n  }\n  this.template = template;\n  this.meta = meta;\n}\nDeferRenderExpression.prototype = Object.create(Expression.prototype);\nDeferRenderExpression.prototype.constructor = DeferRenderExpression;\nDeferRenderExpression.prototype.type = 'DeferRenderExpression';\nDeferRenderExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.template, this.meta);\n};\nDeferRenderExpression.prototype.get = function(context) {\n  return new templates.ContextClosure(this.template, context);\n};\n\nfunction ArrayExpression(items, afterSegments, meta) {\n  this.items = items;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nArrayExpression.prototype = Object.create(Expression.prototype);\nArrayExpression.prototype.constructor = ArrayExpression;\nArrayExpression.prototype.type = 'ArrayExpression';\nArrayExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.items, this.afterSegments, this.meta);\n};\nArrayExpression.prototype.get = function(context) {\n  var items = new Array(this.items.length);\n  for (var i = 0; i < this.items.length; i++) {\n    var value = this.items[i].get(context);\n    items[i] = value;\n  }\n  return (this.afterSegments) ? lookup(this.afterSegments, items) : items;\n};\nArrayExpression.prototype.dependencies = function(context, options) {\n  if (!this.items) return;\n  var dependencies;\n  for (var i = 0; i < this.items.length; i++) {\n    var itemDependencies = this.items[i].dependencies(context, options);\n    dependencies = concat(dependencies, itemDependencies);\n  }\n  return dependencies;\n};\n\nfunction ObjectExpression(properties, afterSegments, meta) {\n  this.properties = properties;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nObjectExpression.prototype = Object.create(Expression.prototype);\nObjectExpression.prototype.constructor = ObjectExpression;\nObjectExpression.prototype.type = 'ObjectExpression';\nObjectExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.properties, this.afterSegments, this.meta);\n};\nObjectExpression.prototype.get = function(context) {\n  var object = {};\n  for (var key in this.properties) {\n    var value = this.properties[key].get(context);\n    object[key] = value;\n  }\n  return (this.afterSegments) ? lookup(this.afterSegments, object) : object;\n};\nObjectExpression.prototype.dependencies = function(context, options) {\n  if (!this.properties) return;\n  var dependencies;\n  for (var key in this.properties) {\n    var propertyDependencies = this.properties[key].dependencies(context, options);\n    dependencies = concat(dependencies, propertyDependencies);\n  }\n  return dependencies;\n};\n\nfunction FnExpression(segments, args, afterSegments, meta) {\n  this.segments = segments;\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n  var parentSegments = segments && segments.slice();\n  this.lastSegment = parentSegments && parentSegments.pop();\n  this.parentSegments = (parentSegments && parentSegments.length) ? parentSegments : null;\n}\nFnExpression.prototype = Object.create(Expression.prototype);\nFnExpression.prototype.constructor = FnExpression;\nFnExpression.prototype.type = 'FnExpression';\nFnExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.segments, this.args, this.afterSegments, this.meta);\n};\nFnExpression.prototype.get = function(context) {\n  var value = this.apply(context);\n  // Lookup property underneath computed value if needed\n  return (this.afterSegments) ? lookup(this.afterSegments, value) : value;\n};\nFnExpression.prototype.apply = function(context, extraInputs) {\n  // See View::dependencies. This is needed in order to handle the case of\n  // getting dependencies within a component template, in which case we cannot\n  // access model data separate from rendering.\n  if (!context.controller) return;\n  var parent = this._lookupParent(context);\n  var fn = parent[this.lastSegment];\n  var getFn = fn.get || fn;\n  var out = this._applyFn(getFn, context, extraInputs, parent);\n  return out;\n};\nFnExpression.prototype._lookupParent = function(context) {\n  // Lookup function on current controller\n  var controller = context.controller;\n  var segments = this.parentSegments;\n  var parent = (segments) ? lookup(segments, controller) : controller;\n  if (parent && parent[this.lastSegment]) return parent;\n  // Otherwise lookup function on page\n  var page = controller.page;\n  if (controller !== page) {\n    parent = (segments) ? lookup(segments, page) : page;\n    if (parent && parent[this.lastSegment]) return parent;\n  }\n  // Otherwise lookup function on global\n  parent = (segments) ? lookup(segments, global) : global;\n  if (parent && parent[this.lastSegment]) return parent;\n  // Throw if not found\n  throw new Error('Function not found for: ' + this.segments.join('.'));\n};\nFnExpression.prototype._getInputs = function(context) {\n  var inputs = [];\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var value = this.args[i].get(context);\n    inputs.push(renderValue(value, context));\n  }\n  return inputs;\n};\nFnExpression.prototype._applyFn = function(fn, context, extraInputs, thisArg) {\n  // Apply if there are no path inputs\n  if (!this.args) {\n    return (extraInputs) ?\n      fn.apply(thisArg, extraInputs) :\n      fn.call(thisArg);\n  }\n  // Otherwise, get the current value for path inputs and apply\n  var inputs = this._getInputs(context);\n  if (extraInputs) {\n    for (var i = 0, len = extraInputs.length; i < len; i++) {\n      inputs.push(extraInputs[i]);\n    }\n  }\n  return fn.apply(thisArg, inputs);\n};\nFnExpression.prototype.dependencies = function(context, options) {\n  var dependencies = [];\n  if (!this.args) return dependencies;\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var argDependencies = this.args[i].dependencies(context, options);\n    if (!argDependencies || argDependencies.length < 1) continue;\n    var end = argDependencies.length - 1;\n    for (var j = 0; j < end; j++) {\n      dependencies.push(argDependencies[j]);\n    }\n    var last = argDependencies[end];\n    if (last[last.length - 1] !== '*') {\n      last = last.concat('*');\n    }\n    dependencies.push(last);\n  }\n  return dependencies;\n};\nFnExpression.prototype.set = function(context, value) {\n  var controller = context.controller;\n  var fn, parent;\n  while (controller) {\n    parent = (this.parentSegments) ?\n      lookup(this.parentSegments, controller) :\n      controller;\n    fn = parent && parent[this.lastSegment];\n    if (fn) break;\n    controller = controller.parent;\n  }\n  var setFn = fn && fn.set;\n  if (!setFn) throw new Error('No setter function for: ' + this.segments.join('.'));\n  var inputs = this._getInputs(context);\n  inputs.unshift(value);\n  var out = setFn.apply(parent, inputs);\n  for (var i in out) {\n    this.args[i].set(context, out[i]);\n  }\n};\n\nfunction NewExpression(segments, args, afterSegments, meta) {\n  FnExpression.call(this, segments, args, afterSegments, meta);\n}\nNewExpression.prototype = Object.create(FnExpression.prototype);\nNewExpression.prototype.constructor = NewExpression;\nNewExpression.prototype.type = 'NewExpression';\nNewExpression.prototype._applyFn = function(Fn, context) {\n  // Apply if there are no path inputs\n  if (!this.args) return new Fn();\n  // Otherwise, get the current value for path inputs and apply\n  var inputs = this._getInputs(context);\n  inputs.unshift(null);\n  return new (Fn.bind.apply(Fn, inputs))();\n};\n\nfunction OperatorExpression(name, args, afterSegments, meta) {\n  this.name = name;\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n  this.getFn = operatorFns.get[name];\n  this.setFn = operatorFns.set[name];\n}\nOperatorExpression.prototype = Object.create(FnExpression.prototype);\nOperatorExpression.prototype.constructor = OperatorExpression;\nOperatorExpression.prototype.type = 'OperatorExpression';\nOperatorExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.args, this.afterSegments, this.meta);\n};\nOperatorExpression.prototype.apply = function(context) {\n  var inputs = this._getInputs(context);\n  return this.getFn.apply(null, inputs);\n};\nOperatorExpression.prototype.set = function(context, value) {\n  var inputs = this._getInputs(context);\n  inputs.unshift(value);\n  var out = this.setFn.apply(null, inputs);\n  for (var i in out) {\n    this.args[i].set(context, out[i]);\n  }\n};\n\nfunction SequenceExpression(args, afterSegments, meta) {\n  this.args = args;\n  this.afterSegments = afterSegments;\n  this.meta = meta;\n}\nSequenceExpression.prototype = Object.create(OperatorExpression.prototype);\nSequenceExpression.prototype.constructor = SequenceExpression;\nSequenceExpression.prototype.type = 'SequenceExpression';\nSequenceExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.args, this.afterSegments, this.meta);\n};\nSequenceExpression.prototype.name = ',';\nSequenceExpression.prototype.getFn = operatorFns.get[','];\nSequenceExpression.prototype.resolve = function(context) {\n  var last = this.args[this.args.length - 1];\n  return last.resolve(context);\n};\nSequenceExpression.prototype.dependencies = function(context, options) {\n  var dependencies = [];\n  for (var i = 0, len = this.args.length; i < len; i++) {\n    var argDependencies = this.args[i].dependencies(context, options);\n    for (var j = 0, jLen = argDependencies.length; j < jLen; j++) {\n      dependencies.push(argDependencies[j]);\n    }\n  }\n  return dependencies;\n};\n\n// For each method that takes a context argument, get the nearest parent view\n// context, then delegate methods to the inner expression\nfunction ViewParentExpression(expression, meta) {\n  this.expression = expression;\n  this.meta = meta;\n}\nViewParentExpression.prototype = Object.create(Expression.prototype);\nViewParentExpression.prototype.constructor = ViewParentExpression;\nViewParentExpression.prototype.type = 'ViewParentExpression';\nViewParentExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.meta);\n};\nViewParentExpression.prototype.get = function(context) {\n  var parentContext = context.forViewParent();\n  return this.expression.get(parentContext);\n};\nViewParentExpression.prototype.resolve = function(context) {\n  var parentContext = context.forViewParent();\n  return this.expression.resolve(parentContext);\n};\nViewParentExpression.prototype.dependencies = function(context, options) {\n  var parentContext = context.forViewParent();\n  return this.expression.dependencies(parentContext, options);\n};\nViewParentExpression.prototype.pathSegments = function(context) {\n  var parentContext = context.forViewParent();\n  return this.expression.pathSegments(parentContext);\n};\nViewParentExpression.prototype.set = function(context, value) {\n  var parentContext = context.forViewParent();\n  return this.expression.set(parentContext, value);\n};\n\nfunction ScopedModelExpression(expression, meta) {\n  this.expression = expression;\n  this.meta = meta;\n}\nScopedModelExpression.prototype = Object.create(Expression.prototype);\nScopedModelExpression.prototype.constructor = ScopedModelExpression;\nScopedModelExpression.prototype.type = 'ScopedModelExpression';\nScopedModelExpression.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.meta);\n};\n// Return a scoped model instead of the value\nScopedModelExpression.prototype.get = function(context) {\n  var segments = this.pathSegments(context);\n  if (!segments) return;\n  return context.controller.model.scope(segments.join('.'));\n};\n// Delegate other methods to the inner expression\nScopedModelExpression.prototype.resolve = function(context) {\n  return this.expression.resolve(context);\n};\nScopedModelExpression.prototype.dependencies = function(context, options) {\n  return this.expression.dependencies(context, options);\n};\nScopedModelExpression.prototype.pathSegments = function(context) {\n  return this.expression.pathSegments(context);\n};\nScopedModelExpression.prototype.set = function(context, value) {\n  return this.expression.set(context, value);\n};\n\nfunction getDependencies(value, context, options) {\n  if (value instanceof Expression || value instanceof Template) {\n    return value.dependencies(context, options);\n  }\n}\n\nfunction appendDependency(dependencies, expression, context) {\n  var segments = expression.resolve(context);\n  if (!segments) return dependencies;\n  if (dependencies) {\n    dependencies.push(segments);\n    return dependencies;\n  }\n  return [segments];\n}\n\nfunction swapLastDependency(dependencies, expression, context) {\n  if (!expression.segments.length) {\n    return dependencies;\n  }\n  var segments = expression.resolve(context);\n  if (!segments) return dependencies;\n  if (dependencies) {\n    dependencies.pop();\n    dependencies.push(segments);\n    return dependencies;\n  }\n  return [segments];\n}\n",
    "// `-` and `+` can be either unary or binary, so all unary operators are\n// postfixed with `U` to differentiate\n\nexports.get = {\n  // Unary operators\n  '!U': function(value) {\n    return !value;\n  }\n, '-U': function(value) {\n    return -value;\n  }\n, '+U': function(value) {\n    return +value;\n  }\n, '~U': function(value) {\n    return ~value;\n  }\n, 'typeofU': function(value) {\n    return typeof value;\n  }\n  // Binary operators\n, '||': function(left, right) {\n    return left || right;\n  }\n, '&&': function(left, right) {\n    return left && right;\n  }\n, '|': function(left, right) {\n    return left | right;\n  }\n, '^': function(left, right) {\n    return left ^ right;\n  }\n, '&': function(left, right) {\n    return left & right;\n  }\n, '==': function(left, right) {\n    return left == right; // jshint ignore:line\n  }\n, '!=': function(left, right) {\n    return left != right; // jshint ignore:line\n  }\n, '===': function(left, right) {\n    return left === right;\n  }\n, '!==': function(left, right) {\n    return left !== right;\n  }\n, '<': function(left, right) {\n    return left < right;\n  }\n, '>': function(left, right) {\n    return left > right;\n  }\n, '<=': function(left, right) {\n    return left <= right;\n  }\n, '>=': function(left, right) {\n    return left >= right;\n  }\n, 'instanceof': function(left, right) {\n    return left instanceof right;\n  }\n, 'in': function(left, right) {\n    return left in right;\n  }\n, '<<': function(left, right) {\n    return left << right;\n  }\n, '>>': function(left, right) {\n    return left >> right;\n  }\n, '>>>': function(left, right) {\n    return left >>> right;\n  }\n, '+': function(left, right) {\n    return left + right;\n  }\n, '-': function(left, right) {\n    return left - right;\n  }\n, '*': function(left, right) {\n    return left * right;\n  }\n, '/': function(left, right) {\n    return left / right;\n  }\n, '%': function(left, right) {\n    return left % right;\n  }\n  // Conditional operator\n, '?': function(test, consequent, alternate) {\n    return (test) ? consequent : alternate;\n  }\n, // Sequence\n  ',': function() {\n    return arguments[arguments.length - 1];\n  }\n};\n\nexports.set = {\n  // Unary operators\n  '!U': function(value) {\n    return [!value];\n  }\n, '-U': function(value) {\n    return [-value];\n  }\n  // Binary operators\n, '==': function(value, left, right) {\n    if (value) return [right];\n  }\n, '===': function(value, left, right) {\n    if (value) return [right];\n  }\n, 'in': function(value, left, right) {\n    right[left] = true;\n    return {1: right};\n  }\n, '+': function(value, left, right) {\n    return [value - right];\n  }\n, '-': function(value, left, right) {\n    return [value + right];\n  }\n, '*': function(value, left, right) {\n    return [value / right];\n  }\n, '/': function(value, left, right) {\n    return [value * right];\n  }\n};\n",
    "var templates = require('./templates');\n\nexports.DependencyOptions = DependencyOptions;\n\nfunction DependencyOptions(options) {\n  this.setIgnoreTemplate(options && options.ignoreTemplate);\n}\nDependencyOptions.shouldIgnoreTemplate = function(template, options) {\n  return (options) ? options.ignoreTemplate === template : false;\n};\nDependencyOptions.prototype.setIgnoreTemplate = function(template) {\n  while (template instanceof templates.ContextClosure) {\n    template = template.template;\n  }\n  this.ignoreTemplate = template;\n};\n",
    "var saddle = require('saddle');\nvar serializeObject = require('serialize-object');\nvar DependencyOptions = require('./options').DependencyOptions;\nvar util = require('./util');\nvar concat = util.concat;\nvar hasKeys = util.hasKeys;\nvar traverseAndCreate = util.traverseAndCreate;\n\n(function() {\n  for (var key in saddle) {\n    exports[key] = saddle[key];\n  }\n})();\n\nexports.Marker = Marker;\nexports.View = View;\nexports.ViewInstance = ViewInstance;\nexports.DynamicViewInstance = DynamicViewInstance;\nexports.ViewParent = ViewParent;\nexports.ContextClosure = ContextClosure;\n\nexports.Views = Views;\n\nexports.MarkupHook = MarkupHook;\nexports.ElementOn = ElementOn;\nexports.ComponentOn = ComponentOn;\nexports.AsProperty = AsProperty;\nexports.AsObject = AsObject;\nexports.AsObjectComponent = AsObjectComponent;\nexports.AsArray = AsArray;\nexports.AsArrayComponent = AsArrayComponent;\n\nexports.emptyTemplate = new saddle.Template([]);\n\n// Add ::isUnbound to Template && Binding\nsaddle.Template.prototype.isUnbound = function(context) {\n  return context.unbound;\n};\nsaddle.Binding.prototype.isUnbound = function() {\n  return this.template.expression.isUnbound(this.context);\n};\n\n// Add Template::resolve\nsaddle.Template.prototype.resolve = function() {};\n\n// The Template::dependencies method is specific to how Derby bindings work,\n// so extend all of the Saddle Template types here\nsaddle.Template.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  return concatArrayDependencies(null, this.content, context, options);\n};\nsaddle.Doctype.prototype.dependencies = function() {};\nsaddle.Text.prototype.dependencies = function() {};\nsaddle.DynamicText.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  return getDependencies(this.expression, context, options);\n};\nsaddle.Comment.prototype.dependencies = function() {};\nsaddle.DynamicComment.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  return getDependencies(this.expression, context, options);\n};\nsaddle.Html.prototype.dependencies = function() {};\nsaddle.DynamicHtml.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  return getDependencies(this.expression, context, options);\n};\nsaddle.Element.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var dependencies = concatMapDependencies(null, this.attributes, context, options);\n  if (!this.content) return dependencies;\n  return concatArrayDependencies(dependencies, this.content, context, options);\n};\nsaddle.DynamicElement.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var dependencies = saddle.Element.prototype.dependencies(context, options);\n  return concatDependencies(dependencies, this.tagName, context, options);\n};\nsaddle.Block.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var dependencies = (this.expression.meta && this.expression.meta.blockType === 'on') ?\n    getDependencies(this.expression, context, options) : null;\n  var blockContext = context.child(this.expression);\n  return concatArrayDependencies(dependencies, this.content, blockContext, options);\n};\nsaddle.ConditionalBlock.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var condition = this.getCondition(context);\n  if (condition == null) {\n    return getDependencies(this.expressions[0], context, options);\n  }\n  var dependencies = concatSubArrayDependencies(null, this.expressions, context, options, condition);\n  var expression = this.expressions[condition];\n  var content = this.contents[condition];\n  var blockContext = context.child(expression);\n  return concatArrayDependencies(dependencies, content, blockContext, options);\n};\nsaddle.EachBlock.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var dependencies = getDependencies(this.expression, context, options);\n  var items = this.expression.get(context);\n  if (items && items.length) {\n    for (var i = 0; i < items.length; i++) {\n      var itemContext = context.eachChild(this.expression, i);\n      dependencies = concatArrayDependencies(dependencies, this.content, itemContext, options);\n    }\n  } else if (this.elseContent) {\n    dependencies = concatArrayDependencies(dependencies, this.elseContent, context, options);\n  }\n  return dependencies;\n};\nsaddle.Attribute.prototype.dependencies = function() {};\nsaddle.DynamicAttribute.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  return getDependencies(this.expression, context, options);\n};\n\nfunction concatSubArrayDependencies(dependencies, expressions, context, options, end) {\n  for (var i = 0; i <= end; i++) {\n    dependencies = concatDependencies(dependencies, expressions[i], context, options);\n  }\n  return dependencies;\n}\nfunction concatArrayDependencies(dependencies, expressions, context, options) {\n  for (var i = 0; i < expressions.length; i++) {\n    dependencies = concatDependencies(dependencies, expressions[i], context, options);\n  }\n  return dependencies;\n}\nfunction concatMapDependencies(dependencies, expressions, context, options) {\n  for (var key in expressions) {\n    dependencies = concatDependencies(dependencies, expressions[key], context, options);\n  }\n  return dependencies;\n}\nfunction concatDependencies(dependencies, expression, context, options) {\n  var expressionDependencies = getDependencies(expression, context, options);\n  return concat(dependencies, expressionDependencies);\n}\nfunction getDependencies(expression, context, options) {\n  return expression.dependencies(context, options);\n}\n\nvar markerHooks = [{\n  emit: function(context, node) {\n    node.$component = context.controller;\n    context.controller.markerNode = node;\n  }\n}];\nfunction Marker(data) {\n  saddle.Comment.call(this, data, markerHooks);\n}\nMarker.prototype = Object.create(saddle.Comment.prototype);\nMarker.prototype.constructor = Marker;\nMarker.prototype.type = 'Marker';\nMarker.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data);\n};\nMarker.prototype.get = function() {\n  return '';\n};\n\nfunction ViewAttributesMap(source) {\n  var items = source.split(/\\s+/);\n  for (var i = 0, len = items.length; i < len; i++) {\n    this[items[i]] = true;\n  }\n}\nfunction ViewArraysMap(source) {\n  var items = source.split(/\\s+/);\n  for (var i = 0, len = items.length; i < len; i++) {\n    var item = items[i].split('/');\n    this[item[0]] = item[1] || item[0];\n  }\n}\nfunction View(views, name, source, options) {\n  this.views = views;\n  this.name = name;\n  this.source = source;\n  this.options = options;\n\n  var nameSegments = (this.name || '').split(':');\n  var lastSegment = nameSegments.pop();\n  this.namespace = nameSegments.join(':');\n  this.registeredName = (lastSegment === 'index') ? this.namespace : this.name;\n\n  this.attributesMap = options && options.attributes &&\n    new ViewAttributesMap(options.attributes);\n  this.arraysMap = options && options.arrays &&\n    new ViewArraysMap(options.arrays);\n  // The empty string is considered true for easier HTML attribute parsing\n  this.unminified = options && (options.unminified || options.unminified === '');\n  this.string = options && (options.string || options.string === '');\n  this.literal = options && (options.literal || options.literal === '');\n  this.template = null;\n  this.componentFactory = null;\n}\nView.prototype = Object.create(saddle.Template.prototype);\nView.prototype.constructor = View;\nView.prototype.type = 'View';\nView.prototype.serialize = function() {\n  return null;\n};\nView.prototype._isComponent = function(context) {\n  if (!this.componentFactory) return false;\n  if (context.attributes && context.attributes.extend) return false;\n  return true;\n};\nView.prototype._initComponent = function(context) {\n  return (this._isComponent(context)) ?\n    this.componentFactory.init(context) : context;\n};\nView.prototype._queueCreate = function(context, viewContext) {\n  if (this._isComponent(context)) {\n    var componentFactory = this.componentFactory;\n    context.queue(function queuedCreate() {\n      componentFactory.create(viewContext);\n    });\n\n    if (!context.hooks) return;\n    context.queue(function queuedComponentHooks() {\n      // Kick off hooks if view instance specified `on` or `as` attributes\n      for (var i = 0, len = context.hooks.length; i < len; i++) {\n        context.hooks[i].emit(context, viewContext.controller);\n      }\n    });\n  }\n};\nView.prototype.get = function(context, unescaped) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  return template.get(viewContext, unescaped);\n};\nView.prototype.getFragment = function(context, binding) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  var fragment = template.getFragment(viewContext, binding);\n  this._queueCreate(context, viewContext);\n  return fragment;\n};\nView.prototype.appendTo = function(parent, context) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  template.appendTo(parent, viewContext);\n  this._queueCreate(context, viewContext);\n};\nView.prototype.attachTo = function(parent, node, context) {\n  var viewContext = this._initComponent(context);\n  var template = this.template || this.parse();\n  var node = template.attachTo(parent, node, viewContext);\n  this._queueCreate(context, viewContext);\n  return node;\n};\nView.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var template = this.template || this.parse();\n  // We can't figure out relative path dependencies within a component without\n  // rendering it, because each component instance's scope is dynamically set\n  // based on its unique `id` property. To represent this, set the context\n  // controller to `null`.\n  //\n  // Under normal rendering conditions, contexts should always have reference\n  // to a controller. Expression::get() methods use the reference to\n  // `context.controller.model.data` to lookup values, and paths are resolved\n  // based on `context.controller.model._scope`.\n  //\n  // To handle this, Expression methods guard against a null controller by not\n  // returning any dependencies for model paths. In addition, they return\n  // `undefined` from get, which affect dependencies computed for\n  // ConditionalBlock and EachBlock, as their dependencies will differ based\n  // on the value of model data.\n  //\n  // TODO: This likely under-estimates the true dependencies within a\n  // template. However, to provide a more complete view of dependencies, we'd\n  // need information we only have at render time, namely, the scope and data\n  // within the component model. This may indicate that Derby should use a\n  // more Functional Reactive Programming (FRP)-like approach of having\n  // dependencies be returned from getFragment and attach methods along with\n  // DOM nodes rather than computing dependencies separately from rendering.\n  var viewContext = (this._isComponent(context)) ?\n    context.componentChild(null) : context;\n  return template.dependencies(viewContext, options);\n};\nView.prototype.parse = function() {\n  this._parse();\n  if (this.componentFactory) {\n    var marker = new Marker(this.name);\n    this.template.content.unshift(marker);\n  }\n  return this.template;\n};\n// View.prototype._parse is defined in parsing.js, so that it doesn't have to\n// be included in the client if templates are all parsed server-side\nView.prototype._parse = function() {\n  throw new Error('View parsing not available');\n};\n\nfunction ViewInstance(name, attributes, hooks, initHooks) {\n  this.name = name;\n  this.attributes = attributes;\n  this.hooks = hooks;\n  this.initHooks = initHooks;\n  this.view = null;\n}\nViewInstance.prototype = Object.create(saddle.Template.prototype);\nViewInstance.prototype.constructor = ViewInstance;\nViewInstance.prototype.type = 'ViewInstance';\nViewInstance.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.attributes, this.hooks, this.initHooks);\n};\nViewInstance.prototype.get = function(context, unescaped) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.get(viewContext, unescaped);\n};\nViewInstance.prototype.getFragment = function(context, binding) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.getFragment(viewContext, binding);\n};\nViewInstance.prototype.appendTo = function(parent, context) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  view.appendTo(parent, viewContext);\n};\nViewInstance.prototype.attachTo = function(parent, node, context) {\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.attachTo(parent, node, viewContext);\n};\nViewInstance.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var view = this._find(context);\n  var viewContext = context.viewChild(view, this.attributes, this.hooks, this.initHooks);\n  return view.dependencies(viewContext, options);\n};\nViewInstance.prototype._find = function(context) {\n  if (this.view) return this.view;\n  var contextView = context.getView();\n  var namespace = contextView && contextView.namespace;\n  this.view = context.meta.views.find(this.name, namespace);\n  if (!this.view) {\n    var message = context.meta.views.findErrorMessage(this.name, contextView);\n    throw new Error(message);\n  }\n  return this.view;\n};\n\nfunction DynamicViewInstance(nameExpression, attributes, hooks, initHooks) {\n  this.nameExpression = nameExpression;\n  this.attributes = attributes;\n  this.hooks = hooks;\n  this.initHooks = initHooks;\n}\nDynamicViewInstance.prototype = Object.create(ViewInstance.prototype);\nDynamicViewInstance.prototype.constructor = DynamicViewInstance;\nDynamicViewInstance.prototype.type = 'DynamicViewInstance';\nDynamicViewInstance.prototype.serialize = function() {\n  return serializeObject.instance(this, this.nameExpression, this.attributes, this.hooks, this.initHooks);\n};\nDynamicViewInstance.prototype._find = function(context) {\n  var name = this.nameExpression.get(context);\n  var contextView = context.getView();\n  var namespace = contextView && contextView.namespace;\n  var view = name && context.meta.views.find(name, namespace);\n  return view || exports.emptyTemplate;\n};\nDynamicViewInstance.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var nameDependencies = this.nameExpression.dependencies(context);\n  var viewDependencies = ViewInstance.prototype.dependencies.call(this, context, options);\n  return concat(nameDependencies, viewDependencies);\n};\n\n// Without a ContextClosure, ViewParent will return the nearest context that\n// is the parent of a view instance. When a context with a `closure` property\n// is encountered first, ViewParent will find the specific referenced context,\n// even if it is further up the context hierarchy.\nfunction ViewParent(template) {\n  this.template = template;\n}\nViewParent.prototype = Object.create(saddle.Template.prototype);\nViewParent.prototype.constructor = ViewParent;\nViewParent.prototype.type = 'ViewParent';\nViewParent.prototype.serialize = function() {\n  return serializeObject.instance(this, this.template);\n};\nViewParent.prototype.get = function(context, unescaped) {\n  var parentContext = context.forViewParent();\n  return this.template.get(parentContext, unescaped);\n};\nViewParent.prototype.getFragment = function(context, binding) {\n  var parentContext = context.forViewParent();\n  return this.template.getFragment(parentContext, binding);\n};\nViewParent.prototype.appendTo = function(parent, context) {\n  var parentContext = context.forViewParent();\n  this.template.appendTo(parent, parentContext);\n};\nViewParent.prototype.attachTo = function(parent, node, context) {\n  var parentContext = context.forViewParent();\n  return this.template.attachTo(parent, node, parentContext);\n};\nViewParent.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this, options)) return;\n  var parentContext = context.forViewParent();\n  return this.template.dependencies(parentContext, options);\n};\n\n// At render time, this template creates a context child and sets its\n// `closure` property to a fixed reference. It is used in combination with\n// ViewParent in order to control which context is returned.\n//\n// Instances of this template cannot be serialized. It is intended for use\n// dynamically during rendering only.\nfunction ContextClosure(template, context) {\n  this.template = template;\n  this.context = context;\n}\nContextClosure.prototype = Object.create(saddle.Template.prototype);\nContextClosure.prototype.constructor = ContextClosure;\nContextClosure.prototype.serialize = function() {\n  throw new Error('ContextClosure cannot be serialized');\n};\nContextClosure.prototype.get = function(context, unescaped) {\n  var closureContext = context.closureChild(this.context);\n  return this.template.get(closureContext, unescaped);\n};\nContextClosure.prototype.getFragment = function(context, binding) {\n  var closureContext = context.closureChild(this.context);\n  return this.template.getFragment(closureContext, binding);\n};\nContextClosure.prototype.appendTo = function(parent, context) {\n  var closureContext = context.closureChild(this.context);\n  this.template.appendTo(parent, closureContext);\n};\nContextClosure.prototype.attachTo = function(parent, node, context) {\n  var closureContext = context.closureChild(this.context);\n  return this.template.attachTo(parent, node, closureContext);\n};\nContextClosure.prototype.dependencies = function(context, options) {\n  if (DependencyOptions.shouldIgnoreTemplate(this.template, options)) return;\n  var closureContext = context.closureChild(this.context);\n  return this.template.dependencies(closureContext, options);\n};\nContextClosure.prototype.equals = function(other) {\n  return (other instanceof ContextClosure) &&\n    (this.context === other.context) &&\n    (this.template.equals(other.template));\n};\n\nfunction ViewsMap() {}\nfunction Views() {\n  this.nameMap = new ViewsMap();\n  this.tagMap = new ViewsMap();\n  // TODO: elementMap is deprecated and should be removed with Derby 0.6.0\n  this.elementMap = this.tagMap;\n}\nViews.prototype.find = function(name, namespace) {\n  var map = this.nameMap;\n\n  // Exact match lookup\n  var exactName = (namespace) ? namespace + ':' + name : name;\n  var match = map[exactName];\n  if (match) return match;\n\n  // Relative lookup\n  var segments = name.split(':');\n  var segmentsDepth = segments.length;\n  if (namespace) segments = namespace.split(':').concat(segments);\n  // Iterate through segments, leaving the `segmentsDepth` segments and\n  // removing the second to `segmentsDepth` segment to traverse up the\n  // namespaces. Decrease `segmentsDepth` if not found and repeat again.\n  while (segmentsDepth > 0) {\n    var testSegments = segments.slice();\n    while (testSegments.length > segmentsDepth) {\n      testSegments.splice(-1 - segmentsDepth, 1);\n      var testName = testSegments.join(':');\n      var match = map[testName];\n      if (match) return match;\n    }\n    segmentsDepth--;\n  }\n};\nViews.prototype.register = function(name, source, options) {\n  var mapName = name.replace(/:index$/, '');\n  var view = this.nameMap[mapName];\n  if (view) {\n    // Recreate the view if it already exists. We re-apply the constructor\n    // instead of creating a new view object so that references to object\n    // can be cached after finding the first time\n    var componentFactory = view.componentFactory;\n    View.call(view, this, name, source, options);\n    view.componentFactory = componentFactory;\n  } else {\n    view = new View(this, name, source, options);\n  }\n  this.nameMap[mapName] = view;\n  // TODO: element is deprecated and should be removed with Derby 0.6.0\n  var tagName = options && (options.tag || options.element);\n  if (tagName) this.tagMap[tagName] = view;\n  return view;\n};\nViews.prototype.serialize = function(options) {\n  var out = 'function(derbyTemplates, views) {' +\n    'var expressions = derbyTemplates.expressions;' +\n    'var templates = derbyTemplates.templates;';\n  var forServer = options && options.server;\n  var minify = options && options.minify;\n  for (var name in this.nameMap) {\n    var view = this.nameMap[name];\n    var template = view.template || view.parse();\n    if (!forServer && view.options) {\n      // Do not serialize views with the `serverOnly` option, except when\n      // serializing for a server script\n      if (view.options.serverOnly) continue;\n      // For views with the `server` option, serialize them with a blank\n      // template body. This allows them to be used from other views on the\n      // browser, but they will output nothing on the browser\n      if (view.options.server) template = exports.emptyTemplate;\n    }\n    out += 'views.register(' + serializeObject.args([\n      view.name\n    , (minify) ? null : view.source\n    , (hasKeys(view.options)) ? view.options : null\n    ]) + ').parse = function() {return this.template = ' + template.serialize() + '};';\n  }\n  return out + '}';\n};\nViews.prototype.findErrorMessage = function(name, contextView) {\n  var names = Object.keys(this.nameMap);\n  var message = 'Cannot find view \"' + name + '\" in' +\n    [''].concat(names).join('\\n  ') + '\\n';\n  if (contextView) {\n    message += '\\nWithin template \"' + contextView.name + '\":\\n' + contextView.source;\n  }\n  return message;\n};\n\n\nfunction MarkupHook() {}\nMarkupHook.prototype.module = saddle.Template.prototype.module;\n\nfunction ElementOn(name, expression) {\n  this.name = name;\n  this.expression = expression;\n}\nElementOn.prototype = Object.create(MarkupHook.prototype);\nElementOn.prototype.constructor = ElementOn;\nElementOn.prototype.type = 'ElementOn';\nElementOn.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.expression);\n};\nElementOn.prototype.emit = function(context, element) {\n  var elementOn = this;\n  if (this.name === 'create') {\n    this.apply(context, element);\n\n  } else if (this.name === 'destroy') {\n    var destroyListeners = element.$destroyListeners || (element.$destroyListeners = []);\n    destroyListeners.push(function elementOnDestroy() {\n      elementOn.apply(context, element);\n    });\n\n  } else {\n    element.addEventListener(this.name, function elementOnListener(event) {\n      return elementOn.apply(context, element, event);\n    }, false);\n  }\n};\nElementOn.prototype.apply = function(context, element, event) {\n  var modelData = context.controller.model.data;\n  modelData.$event = event;\n  modelData.$element = element;\n  var out = this.expression.apply(context);\n  delete modelData.$event;\n  delete modelData.$element;\n  return out;\n};\n\nfunction ComponentOn(name, expression) {\n  this.name = name;\n  this.expression = expression;\n}\nComponentOn.prototype = Object.create(MarkupHook.prototype);\nComponentOn.prototype.constructor = ComponentOn;\nComponentOn.prototype.type = 'ComponentOn';\nComponentOn.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.expression);\n};\nComponentOn.prototype.emit = function(context, component) {\n  var expression = this.expression;\n  component.on(this.name, function componentOnListener() {\n    var args = arguments.length && Array.prototype.slice.call(arguments);\n    return expression.apply(context, args);\n  });\n};\n\nfunction AsProperty(segments) {\n  this.segments = segments;\n  this.lastSegment = segments.pop();\n}\nAsProperty.prototype = Object.create(MarkupHook.prototype);\nAsProperty.prototype.constructor = AsProperty;\nAsProperty.prototype.type = 'AsProperty';\nAsProperty.prototype.serialize = function() {\n  var segments = this.segments.concat(this.lastSegment);\n  return serializeObject.instance(this, segments);\n};\nAsProperty.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  node[this.lastSegment] = target;\n};\n\nfunction AsObject(segments, keyExpression) {\n  AsProperty.call(this, segments);\n  this.keyExpression = keyExpression;\n}\nAsObject.prototype = Object.create(AsProperty.prototype);\nAsObject.prototype.constructor = AsObject;\nAsObject.prototype.type = 'AsObject';\nAsObject.prototype.serialize = function() {\n  var segments = this.segments.concat(this.lastSegment);\n  return serializeObject.instance(this, segments, this.keyExpression);\n};\nAsObject.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  var object = node[this.lastSegment] || (node[this.lastSegment] = {});\n  var key = this.keyExpression.get(context);\n  object[key] = target;\n  this.addListeners(target, object, key);\n};\nAsObject.prototype.addListeners = function(target, object, key) {\n  this.addDestroyListener(target, function asObjectDestroy() {\n    delete object[key];\n  });\n};\nAsObject.prototype.addDestroyListener = function(target, listener) {\n  var listeners = target.$destroyListeners || (target.$destroyListeners = []);\n  listeners.push(listener);\n};\n\nfunction AsObjectComponent(segments, keyExpression) {\n  AsObject.call(this, segments, keyExpression);\n}\nAsObjectComponent.prototype = Object.create(AsObject.prototype);\nAsObjectComponent.prototype.constructor = AsObjectComponent;\nAsObjectComponent.prototype.type = 'AsObjectComponent';\nAsObjectComponent.prototype.addDestroyListener = function(target, listener) {\n  target.on('destroy', listener);\n};\n\nfunction AsArray(segments) {\n  AsProperty.call(this, segments);\n}\nAsArray.prototype = Object.create(AsProperty.prototype);\nAsArray.prototype.constructor = AsArray;\nAsArray.prototype.type = 'AsArray';\nAsArray.prototype.emit = function(context, target) {\n  var node = traverseAndCreate(context.controller, this.segments);\n  var array = node[this.lastSegment] || (node[this.lastSegment] = []);\n\n  // Iterate backwards, since rendering will usually append\n  for (var i = array.length; i--;) {\n    var item = array[i];\n    // Don't add an item if already in the array\n    if (item === target) return;\n    var mask = this.comparePosition(target, item);\n    // If the emitted target is after the current item in the document,\n    // insert it next in the array\n    // Node.DOCUMENT_POSITION_FOLLOWING = 4\n    if (mask & 4) {\n      array.splice(i + 1, 0, target);\n      this.addListeners(target, array);\n      return;\n    }\n  }\n  // Add to the beginning if before all items\n  array.unshift(target);\n  this.addListeners(target, array);\n};\nAsArray.prototype.addListeners = function(target, array) {\n  this.addDestroyListener(target, function asArrayDestroy() {\n    var index = array.indexOf(target);\n    if (index !== -1) array.splice(index, 1);\n  });\n};\nAsArray.prototype.comparePosition = function(target, item) {\n  return item.compareDocumentPosition(target);\n};\nAsArray.prototype.addDestroyListener = AsObject.prototype.addDestroyListener;\n\nfunction AsArrayComponent(segments) {\n  AsArray.call(this, segments);\n}\nAsArrayComponent.prototype = Object.create(AsArray.prototype);\nAsArrayComponent.prototype.constructor = AsArrayComponent;\nAsArrayComponent.prototype.type = 'AsArrayComponent';\nAsArrayComponent.prototype.comparePosition = function(target, item) {\n  return item.markerNode.compareDocumentPosition(target.markerNode);\n};\nAsArrayComponent.prototype.addDestroyListener = AsObjectComponent.prototype.addDestroyListener;\n",
    "\nexports.concat = function(a, b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a.concat(b);\n};\n\nexports.hasKeys = function(value) {\n  if (!value) return false;\n  for (var key in value) {\n    return true;\n  }\n  return false;\n};\n\nexports.traverseAndCreate = function(node, segments) {\n  var len = segments.length;\n  if (!len) return node;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    node = node[segment] || (node[segment] = {});\n  }\n  return node;\n};\n",
    "/*\n * App.js\n *\n * Provides the glue between views, controllers, and routes for an\n * application's functionality. Apps are responsible for creating pages.\n *\n */\n\nvar path = require('path');\nvar EventEmitter = require('events').EventEmitter;\nvar tracks = require('tracks');\nvar util = require('racer/lib/util');\nvar derbyTemplates = require('derby-templates');\nvar templates = derbyTemplates.templates;\nvar components = require('./components');\nvar PageBase = require('./Page');\nvar serializedViews = require('./_views');\n\nmodule.exports = App;\n\nfunction App(derby, name, filename, options) {\n  EventEmitter.call(this);\n  this.derby = derby;\n  this.name = name;\n  this.filename = filename;\n  this.scriptHash = '{{DERBY_SCRIPT_HASH}}';\n  this.bundledAt = '{{DERBY_BUNDLED_AT}}';\n  this.Page = createAppPage(derby);\n  this.proto = this.Page.prototype;\n  this.views = new templates.Views();\n  this.tracksRoutes = tracks.setup(this);\n  this.model = null;\n  this.page = null;\n  this._pendingComponentMap = {};\n  this._init(options);\n}\n\nfunction createAppPage(derby) {\n  var Page = (derby && derby.Page) || PageBase;\n  // Inherit from Page/PageForServer so that we can add controller functions as prototype\n  // methods on this app's pages\n  function AppPage() {\n    Page.apply(this, arguments);\n  }\n  AppPage.prototype = Object.create(Page.prototype);\n  return AppPage;\n}\n\nutil.mergeInto(App.prototype, EventEmitter.prototype);\n\n// Overriden on server\nApp.prototype._init = function() {\n  this._waitForAttach = true;\n  this._cancelAttach = false;\n  this.model = new this.derby.Model();\n  serializedViews(derbyTemplates, this.views);\n  // Must init async so that app.on('model') listeners can be added.\n  // Must also wait for content ready so that bundle is fully downloaded.\n  this._contentReady();\n};\nApp.prototype._finishInit = function() {\n  var script = this._getScript();\n  var data = JSON.parse(script.nextSibling.innerHTML);\n  this.model.createConnection(data);\n  this.emit('model', this.model);\n  util.isProduction = data.nodeEnv === 'production';\n  if (!util.isProduction) this._autoRefresh();\n  this.model.unbundle(data);\n  var page = this.createPage();\n  page.params = this.model.get('$render.params');\n  this.emit('ready', page);\n  this._waitForAttach = false;\n  // Instead of attaching, do a route and render if a link was clicked before\n  // the page finished attaching\n  if (this._cancelAttach) {\n    this.history.refresh();\n    return;\n  }\n  // Since an attachment failure is *fatal* and could happen as a result of a\n  // browser extension like AdBlock, an invalid template, or a small bug in\n  // Derby or Saddle, re-render from scratch on production failures\n  if (util.isProduction) {\n    try {\n      page.attach();\n    } catch (err) {\n      this.history.refresh();\n      console.warn('attachment error', err.stack);\n    }\n  } else {\n    page.attach();\n  }\n  this.emit('load', page);\n};\n// Modified from: https://github.com/addyosmani/jquery.parts/blob/master/jquery.documentReady.js\nApp.prototype._contentReady = function() {\n  // Is the DOM ready to be used? Set to true once it occurs.\n  var isReady = false;\n  var app = this;\n\n  // The ready event handler\n  function onDOMContentLoaded() {\n    if (document.addEventListener) {\n      document.removeEventListener('DOMContentLoaded', onDOMContentLoaded, false);\n    } else {\n      // we're here because readyState !== 'loading' in oldIE\n      // which is good enough for us to call the dom ready!\n      document.detachEvent('onreadystatechange', onDOMContentLoaded);\n    }\n    onDOMReady();\n  }\n\n  // Handle when the DOM is ready\n  function onDOMReady() {\n    // Make sure that the DOM is not already loaded\n    if (isReady) return;\n    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n    if (!document.body) return setTimeout(onDOMReady, 0);\n    // Remember that the DOM is ready\n    isReady = true;\n    // Make sure this is always async and then finishin init\n    setTimeout(function() {\n      app._finishInit();\n    }, 0);\n  }\n\n  // The DOM ready check for Internet Explorer\n  function doScrollCheck() {\n    if (isReady) return;\n    try {\n      // If IE is used, use the trick by Diego Perini\n      // http://javascript.nwbox.com/IEContentLoaded/\n      document.documentElement.doScroll('left');\n    } catch (err) {\n      setTimeout(doScrollCheck, 0);\n      return;\n    }\n    // and execute any waiting functions\n    onDOMReady();\n  }\n\n  // Catch cases where called after the browser event has already occurred.\n  if (document.readyState !== 'loading') return onDOMReady();\n\n  // Mozilla, Opera and webkit nightlies currently support this event\n  if (document.addEventListener) {\n    // Use the handy event callback\n    document.addEventListener('DOMContentLoaded', onDOMContentLoaded, false);\n    // A fallback to window.onload, that will always work\n    window.addEventListener('load', onDOMContentLoaded, false);\n    // If IE event model is used\n  } else if (document.attachEvent) {\n    // ensure firing before onload,\n    // maybe late but safe also for iframes\n    document.attachEvent('onreadystatechange', onDOMContentLoaded);\n    // A fallback to window.onload, that will always work\n    window.attachEvent('onload', onDOMContentLoaded);\n    // If IE and not a frame\n    // continually check to see if the document is ready\n    var toplevel;\n    try {\n      toplevel = window.frameElement == null;\n    } catch (err) {}\n    if (document.documentElement.doScroll && toplevel) {\n      doScrollCheck();\n    }\n  }\n};\n\nApp.prototype._getScript = function() {\n  return document.querySelector('script[data-derby-app]');\n};\n\nApp.prototype.use = util.use;\nApp.prototype.serverUse = util.serverUse;\n\nApp.prototype.loadViews = function() {};\n\nApp.prototype.loadStyles = function() {};\n\n// This function is overriden by requiring 'derby/parsing'\nApp.prototype.addViews = function() {\n  throw new Error(\n    'Parsing not available. Registering a view from source should not be used ' +\n    'in application code. Instead, specify a filename with view.file.'\n  );\n};\n\nApp.prototype.component = function(name, constructor, isDependency) {\n  if (typeof name === 'function') {\n    constructor = name;\n    name = null;\n  }\n  if (typeof constructor !== 'function') {\n    throw new Error('Missing component constructor argument');\n  }\n\n  var viewProp = constructor.view;\n  var viewIs, viewFilename, viewSource, viewDependencies;\n  // Always using an object for the static `view` property is preferred\n  if (viewProp && typeof viewProp === 'object') {\n    viewIs = viewProp.is;\n    viewFilename = viewProp.file;\n    viewSource = viewProp.source;\n    viewDependencies = viewProp.dependencies;\n  } else {\n    // Ignore other properties when `view` is an object. It is possible that\n    // properties could be inherited from a parent component when extending it.\n    //\n    // DEPRECATED: constructor.prototype.name and constructor.prototype.view\n    // use the equivalent static properties instead\n    viewIs = constructor.is || constructor.prototype.name;\n    viewFilename = constructor.view || constructor.prototype.view;\n  }\n  var viewName = name || viewIs ||\n    (viewFilename && path.basename(viewFilename, '.html'));\n\n  if (!viewName) {\n    throw new Error('No view specified for component');\n  }\n  if (viewFilename && viewSource) {\n    throw new Error('Component may not specify both a view file and source');\n  }\n\n  // TODO: DRY. This is copy-pasted from derby-templates\n  var mapName = viewName.replace(/:index$/, '');\n  var currentView = this.views.nameMap[mapName];\n  var currentConstructor = (currentView && currentView.componentFactory) ?\n    currentView.componentFactory.constructor :\n    this._pendingComponentMap[mapName];\n\n  // Avoid registering the same component twice; we want to avoid the overhead\n  // of loading view files from disk again. This is also what prevents\n  // circular dependencies from infinite looping\n  if (currentConstructor === constructor) return;\n\n  // Calling app.component() overrides existing views or components. Prevent\n  // dependencies from doing this without warning\n  if (isDependency && currentView) {\n    throw new Error('Dependencies cannot override existing views. Already registered \"' + viewName + '\"');\n  }\n\n  // This map is used to prevent infinite loops from circular dependencies\n  this._pendingComponentMap[mapName] = constructor;\n\n  // Recursively register component dependencies\n  if (viewDependencies) {\n    for (var i = 0; i < viewDependencies.length; i++) {\n      var dependency = viewDependencies[i];\n      if (Array.isArray(dependency)) {\n        this.component(dependency[0], dependency[1], true);\n      } else {\n        this.component(null, dependency, true);\n      }\n    }\n  }\n\n  // Register or find views specified by the component\n  var view;\n  if (viewFilename) {\n    this.loadViews(viewFilename, viewName);\n    view = this.views.find(viewName);\n\n  } else if (viewSource) {\n    this.addViews(viewSource, viewName);\n    view = this.views.find(viewName);\n\n  } else if (name) {\n    view = this.views.find(viewName);\n\n  } else {\n    view = this.views.register(viewName, '');\n  }\n  if (!view) {\n    var message = this.views.findErrorMessage(viewName);\n    throw new Error(message);\n  }\n\n  // Inherit from Component\n  components.extendComponent(constructor);\n  // Associate the appropriate view with the component constructor\n  view.componentFactory = components.createFactory(constructor);\n\n  delete this._pendingComponentMap[mapName];\n\n  // Make chainable\n  return this;\n};\n\nApp.prototype.createPage = function() {\n  if (this.page) {\n    this.emit('destroyPage', this.page);\n    this.page.destroy();\n  }\n  var page = new this.Page(this, this.model);\n  this.page = page;\n  return page;\n};\n\nApp.prototype.onRoute = function(callback, page, next, done) {\n  if (this._waitForAttach) {\n    // Cancel any routing before the initial page attachment. Instead, do a\n    // render once derby is ready\n    this._cancelAttach = true;\n    return;\n  }\n  this.emit('route', page);\n  // HACK: To update render in transitional routes\n  page.model.set('$render.params', page.params);\n  page.model.set('$render.url', page.params.url);\n  page.model.set('$render.query', page.params.query);\n  // If transitional\n  if (done) {\n    var app = this;\n    var _done = function() {\n      app.emit('routeDone', page, 'transition');\n      done();\n    };\n    callback.call(page, page, page.model, page.params, next, _done);\n    return;\n  }\n  callback.call(page, page, page.model, page.params, next);\n};\n\nApp.prototype._autoRefresh = function() {\n  var app = this;\n  var connection = this.model.connection;\n  connection.on('connected', function() {\n    connection.send({\n      derby: 'app',\n      name: app.name,\n      hash: app.scriptHash\n    });\n  });\n  connection.on('receive', function(request) {\n    if (request.data.derby) {\n      var message = request.data;\n      request.data = null;\n      app._handleMessage(message.derby, message);\n    }\n  });\n};\n\nApp.prototype._handleMessage = function(action, message) {\n  if (action === 'refreshViews') {\n    var fn = new Function('return ' + message.views)(); // jshint ignore:line\n    fn(derbyTemplates, this.views);\n    var ns = this.model.get('$render.ns');\n    this.page.render(ns);\n\n  } else if (action === 'refreshStyles') {\n    var styleElement = document.querySelector('style[data-filename=\"' +\n      message.filename + '\"]');\n    if (styleElement) styleElement.innerHTML = message.css;\n\n  } else if (action === 'reload') {\n    this.model.whenNothingPending(function() {\n      window.location = window.location;\n    });\n  }\n};\n",
    "var EventEmitter = require('events').EventEmitter;\nvar util = require('racer/lib/util');\nvar Dom = require('./Dom');\n\nmodule.exports = Controller;\n\nfunction Controller(app, page, model) {\n  EventEmitter.call(this);\n  this.dom = new Dom(this);\n  this.app = app;\n  this.page = page;\n  this.model = model;\n  model.data.$controller = this;\n}\n\nutil.mergeInto(Controller.prototype, EventEmitter.prototype);\n\nController.prototype.emitCancellable = function() {\n  var cancelled = false;\n  function cancel() {\n    cancelled = true;\n  }\n\n  var args = Array.prototype.slice.call(arguments);\n  args.push(cancel);\n  this.emit.apply(this, args);\n\n  return cancelled;\n};\n\nController.prototype.emitDelayable = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var callback = args.pop();\n\n  var delayed = false;\n  function delay() {\n    delayed = true;\n    return callback;\n  }\n\n  args.push(delay);\n  this.emit.apply(this, args);\n  if (!delayed) callback();\n\n  return delayed;\n};\n",
    "var EventEmitter = require('events').EventEmitter;\nvar Model = require('racer/lib/Model/ModelStandalone');\nvar util = require('racer/lib/util');\nvar App = require('./App');\nvar Page = require('./Page');\nvar components = require('./components');\n\nmodule.exports = DerbyStandalone;\n\nrequire('./documentListeners').add(document);\n\n// Standard Derby inherits from Racer, but we only set up the event emitter and\n// expose the Model and util here instead\nfunction DerbyStandalone() {\n  EventEmitter.call(this);\n}\nutil.mergeInto(DerbyStandalone.prototype, EventEmitter.prototype);\nDerbyStandalone.prototype.Model = Model;\nDerbyStandalone.prototype.util = util;\n\nDerbyStandalone.prototype.App = AppStandalone;\nDerbyStandalone.prototype.Page = Page;\nDerbyStandalone.prototype.Component = components.Component;\n\nDerbyStandalone.prototype.createApp = function() {\n  return new this.App(this);\n};\n\nfunction AppStandalone(derby) {\n  App.call(this, derby);\n}\nAppStandalone.prototype = Object.create(App.prototype);\nAppStandalone.prototype.constructor = AppStandalone;\n\nAppStandalone.prototype._init = function() {\n  this.model = new this.derby.Model();\n  this.createPage();\n};\n",
    "module.exports = Dom;\n\nfunction Dom(controller) {\n  this.controller = controller;\n  this._listeners = null;\n}\n\nDom.prototype._initListeners = function() {\n  var dom = this;\n  this.controller.on('destroy', function domOnDestroy() {\n    var listeners = dom._listeners;\n    if (!listeners) return;\n    for (var i = listeners.length; i--;) {\n      listeners[i].remove();\n    }\n    dom._listeners = null;\n  });\n  return this._listeners = [];\n};\n\nDom.prototype._listenerIndex = function(domListener) {\n  var listeners = this._listeners;\n  if (!listeners) return -1;\n  for (var i = listeners.length; i--;) {\n    if (listeners[i].equals(domListener)) return i;\n  }\n  return -1;\n};\n\nDom.prototype.addListener = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  var domListener =\n    (type === 'destroy') ? new DestroyListener(target, listener) :\n    new DomListener(type, target, listener, useCapture);\n  if (-1 === this._listenerIndex(domListener)) {\n    var listeners = this._listeners || this._initListeners();\n    listeners.push(domListener);\n  }\n  domListener.add();\n};\nDom.prototype.on = Dom.prototype.addListener;\n\nDom.prototype.once = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  this.addListener(type, target, wrappedListener, useCapture);\n  var dom = this;\n  function wrappedListener() {\n    dom.removeListener(type, target, wrappedListener, useCapture);\n    return listener.apply(this, arguments);\n  }\n};\n\nDom.prototype.removeListener = function(type, target, listener, useCapture) {\n  if (typeof target === 'function') {\n    useCapture = listener;\n    listener = target;\n    target = document;\n  }\n  var domListener = new DomListener(type, target, listener, useCapture);\n  domListener.remove();\n  var i = this._listenerIndex(domListener);\n  if (i > -1) this._listeners.splice(i, 1);\n};\n\nfunction DomListener(type, target, listener, useCapture) {\n  this.type = type;\n  this.target = target;\n  this.listener = listener;\n  this.useCapture = !!useCapture;\n}\nDomListener.prototype.equals = function(domListener) {\n  return this.listener === domListener.listener &&\n    this.target === domListener.target &&\n    this.type === domListener.type &&\n    this.useCapture === domListener.useCapture;\n};\nDomListener.prototype.add = function() {\n  this.target.addEventListener(this.type, this.listener, this.useCapture);\n};\nDomListener.prototype.remove = function() {\n  this.target.removeEventListener(this.type, this.listener, this.useCapture);\n};\n\nfunction DestroyListener(target, listener) {\n  DomListener.call(this, 'destroy', target, listener);\n}\nDestroyListener.prototype = new DomListener();\nDestroyListener.prototype.add = function() {\n  var listeners = this.target.$destroyListeners || (this.target.$destroyListeners = []);\n  if (listeners.indexOf(this.listener) === -1) {\n    listeners.push(this.listener);\n  }\n};\nDestroyListener.prototype.remove = function() {\n  var listeners = this.target.$destroyListeners;\n  if (!listeners) return;\n  var index = listeners.indexOf(this.listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n};\n",
    "var derbyTemplates = require('derby-templates');\nvar contexts = derbyTemplates.contexts;\nvar expressions = derbyTemplates.expressions;\nvar templates = derbyTemplates.templates;\nvar DependencyOptions = derbyTemplates.options.DependencyOptions;\nvar util = require('racer/lib/util');\nvar components = require('./components');\nvar EventModel = require('./eventmodel');\nvar textDiff = require('./textDiff');\nvar Controller = require('./Controller');\nvar documentListeners = require('./documentListeners');\n\nmodule.exports = Page;\n\nfunction Page(app, model) {\n  Controller.call(this, app, this, model);\n  this.params = null;\n  if (this.init) this.init(model);\n  this.context = this._createContext();\n  this._eventModel = null;\n  this._removeModelListeners = null;\n  this._components = {};\n  this._addListeners();\n}\n\nutil.mergeInto(Page.prototype, Controller.prototype);\n\nPage.prototype.$bodyClass = function(ns) {\n  if (!ns) return;\n  var classNames = [];\n  var segments = ns.split(':');\n  for (var i = 0, len = segments.length; i < len; i++) {\n    var className = segments.slice(0, i + 1).join('-');\n    classNames.push(className);\n  }\n  return classNames.join(' ');\n};\n\nPage.prototype.$preventDefault = function(e) {\n  e.preventDefault();\n};\n\nPage.prototype.$stopPropagation = function(e) {\n  e.stopPropagation();\n};\n\nPage.prototype._setRenderParams = function(ns) {\n  this.model.set('$render.ns', ns);\n  this.model.set('$render.params', this.params);\n  this.model.set('$render.url', this.params && this.params.url);\n  this.model.set('$render.query', this.params && this.params.query);\n};\n\nPage.prototype._setRenderPrefix = function(ns) {\n  var prefix = (ns) ? ns + ':' : '';\n  this.model.set('$render.prefix', prefix);\n};\n\nPage.prototype.get = function(viewName, ns, unescaped) {\n  this._setRenderPrefix(ns);\n  var view = this.getView(viewName, ns);\n  return view.get(this.context, unescaped);\n};\n\nPage.prototype.getFragment = function(viewName, ns) {\n  this._setRenderPrefix(ns);\n  var view = this.getView(viewName, ns);\n  return view.getFragment(this.context);\n};\n\nPage.prototype.getView = function(viewName, ns) {\n  return this.app.views.find(viewName, ns);\n};\n\nPage.prototype.render = function(ns) {\n  this.app.emit('render', this);\n  this.context.pause();\n  this._setRenderParams(ns);\n  var titleFragment = this.getFragment('TitleElement', ns);\n  var bodyFragment = this.getFragment('BodyElement', ns);\n  var titleElement = document.getElementsByTagName('title')[0];\n  titleElement.parentNode.replaceChild(titleFragment, titleElement);\n  document.body.parentNode.replaceChild(bodyFragment, document.body);\n  this.context.unpause();\n  if (this.create) this.create(this.model, this.dom);\n  this.app.emit('routeDone', this, 'render');\n};\n\nPage.prototype.attach = function() {\n  this.context.pause();\n  var ns = this.model.get('$render.ns');\n  var titleView = this.getView('TitleElement', ns);\n  var bodyView = this.getView('BodyElement', ns);\n  var titleElement = document.getElementsByTagName('title')[0];\n  titleView.attachTo(titleElement.parentNode, titleElement, this.context);\n  bodyView.attachTo(document.body.parentNode, document.body, this.context);\n  this.context.unpause();\n  if (this.create) this.create(this.model, this.dom);\n};\n\nPage.prototype._createContext = function() {\n  var contextMeta = new contexts.ContextMeta();\n  contextMeta.views = this.app && this.app.views;\n  var context = new contexts.Context(contextMeta, this);\n  context.expression = new expressions.PathExpression([]);\n  context.alias = '#root';\n  return context;\n};\n\nPage.prototype._addListeners = function() {\n  var eventModel = this._eventModel = new EventModel();\n  this._addModelListeners(eventModel);\n  this._addContextListeners(eventModel);\n};\n\nPage.prototype.destroy = function() {\n  this.emit('destroy');\n  this._removeModelListeners();\n  for (var id in this._components) {\n    var component = this._components[id];\n    component.destroy();\n  }\n  // Remove all data, refs, listeners, and reactive functions\n  // for the previous page\n  var silentModel = this.model.silent();\n  silentModel.destroy('_page');\n  silentModel.destroy('$components');\n  // Unfetch and unsubscribe from all queries and documents\n  silentModel.unloadAll && silentModel.unloadAll();\n};\n\nPage.prototype._addModelListeners = function(eventModel) {\n  var model = this.model;\n  if (!model) return;\n  // Registering model listeners with the *Immediate events helps to prevent\n  // a bug with binding updates where a model listener causes a change to the\n  // path being listened on, directly or indirectly.\n\n  // TODO: Remove this when upgrading Racer to the next major version. Feature\n  // detect which type of event listener to register by emitting a test event\n  if (useLegacyListeners(model)) {\n    return this._addModelListenersLegacy(eventModel);\n  }\n\n  // `util.castSegments(segments)` is needed to cast string segments into\n  // numbers, since EventModel#child does typeof checks against segments. This\n  // could be done once in Racer's Model#emit, instead of in every listener.\n  var changeListener = model.on('changeImmediate', function onChange(segments, event) {\n    // The pass parameter is passed in for special handling of updates\n    // resulting from stringInsert or stringRemove\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments, event.previous, event.pass);\n  });\n  var loadListener = model.on('loadImmediate', function onLoad(segments) {\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments);\n  });\n  var unloadListener = model.on('unloadImmediate', function onUnload(segments, event) {\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments, event.previous);\n  });\n  var insertListener = model.on('insertImmediate', function onInsert(segments, event) {\n    segments = util.castSegments(segments.slice());\n    eventModel.insert(segments, event.index, event.values.length);\n  });\n  var removeListener = model.on('removeImmediate', function onRemove(segments, event) {\n    segments = util.castSegments(segments.slice());\n    eventModel.remove(segments, event.index, event.values.length);\n  });\n  var moveListener = model.on('moveImmediate', function onMove(segments, event) {\n    segments = util.castSegments(segments.slice());\n    eventModel.move(segments, event.from, event.to, event.howMany);\n  });\n\n  this._removeModelListeners = function() {\n    model.removeListener('changeImmediate', changeListener);\n    model.removeListener('loadImmediate', loadListener);\n    model.removeListener('unloadImmediate', unloadListener);\n    model.removeListener('insertImmediate', insertListener);\n    model.removeListener('removeImmediate', removeListener);\n    model.removeListener('moveImmediate', moveListener);\n  };\n};\nfunction useLegacyListeners(model) {\n  var useLegacy = true;\n  // model.once is broken in older racer, so manually remove event\n  var listener = model.on('changeImmediate', function(segments, event) {\n    model.removeListener('changeImmediate', listener);\n    // Older Racer emits an array of eventArgs, whereas newer racer emits an event object\n    useLegacy = Array.isArray(event);\n  });\n  model.set('$derby.testEvent', true);\n  return useLegacy;\n}\nPage.prototype._addModelListenersLegacy = function(eventModel) {\n  var model = this.model;\n  if (!model) return;\n\n  // `util.castSegments(segments)` is needed to cast string segments into\n  // numbers, since EventModel#child does typeof checks against segments. This\n  // could be done once in Racer's Model#emit, instead of in every listener.\n  var changeListener = model.on('changeImmediate', function onChange(segments, eventArgs) {\n    // eventArgs[0] is the new value, which Derby bindings don't use directly.\n    var previous = eventArgs[1];\n    // The pass parameter is passed in for special handling of updates\n    // resulting from stringInsert or stringRemove\n    var pass = eventArgs[2];\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments, previous, pass);\n  });\n  var loadListener = model.on('loadImmediate', function onLoad(segments) {\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments);\n  });\n  var unloadListener = model.on('unloadImmediate', function onUnload(segments) {\n    segments = util.castSegments(segments.slice());\n    eventModel.set(segments);\n  });\n  var insertListener = model.on('insertImmediate', function onInsert(segments, eventArgs) {\n    var index = eventArgs[0];\n    var values = eventArgs[1];\n    segments = util.castSegments(segments.slice());\n    eventModel.insert(segments, index, values.length);\n  });\n  var removeListener = model.on('removeImmediate', function onRemove(segments, eventArgs) {\n    var index = eventArgs[0];\n    var values = eventArgs[1];\n    segments = util.castSegments(segments.slice());\n    eventModel.remove(segments, index, values.length);\n  });\n  var moveListener = model.on('moveImmediate', function onMove(segments, eventArgs) {\n    var from = eventArgs[0];\n    var to = eventArgs[1];\n    var howMany = eventArgs[2];\n    segments = util.castSegments(segments.slice());\n    eventModel.move(segments, from, to, howMany);\n  });\n\n  this._removeModelListeners = function() {\n    model.removeListener('changeImmediate', changeListener);\n    model.removeListener('loadImmediate', loadListener);\n    model.removeListener('unloadImmediate', unloadListener);\n    model.removeListener('insertImmediate', insertListener);\n    model.removeListener('removeImmediate', removeListener);\n    model.removeListener('moveImmediate', moveListener);\n  };\n};\n\nPage.prototype._addContextListeners = function(eventModel) {\n  this.context.meta.addBinding = addBinding;\n  this.context.meta.removeBinding = removeBinding;\n  this.context.meta.removeNode = removeNode;\n  this.context.meta.addItemContext = addItemContext;\n  this.context.meta.removeItemContext = removeItemContext;\n\n  function addItemContext(context) {\n    var segments = context.expression.resolve(context);\n    eventModel.addItemContext(segments, context);\n  }\n  function removeItemContext(context) {\n    // TODO\n  }\n  function addBinding(binding) {\n    patchTextBinding(binding);\n    var expressions = binding.template.expressions;\n    if (expressions) {\n      for (var i = 0, len = expressions.length; i < len; i++) {\n        addDependencies(eventModel, expressions[i], binding);\n      }\n    } else {\n      var expression = binding.template.expression;\n      addDependencies(eventModel, expression, binding);\n    }\n  }\n  function removeBinding(binding) {\n    var bindingWrappers = binding.meta;\n    if (!bindingWrappers) return;\n    for (var i = bindingWrappers.length; i--;) {\n      eventModel.removeBinding(bindingWrappers[i]);\n    }\n  }\n  function removeNode(node) {\n    var component = node.$component;\n    if (component) component.destroy();\n    var destroyListeners = node.$destroyListeners;\n    if (destroyListeners) {\n      for (var i = 0; i < destroyListeners.length; i++) {\n        destroyListeners[i]();\n      }\n    }\n  }\n};\n\nfunction addDependencies(eventModel, expression, binding) {\n  var bindingWrapper = new BindingWrapper(eventModel, expression, binding);\n  bindingWrapper.updateDependencies();\n}\n\n// The code here uses object-based set pattern where objects are keyed using\n// sequentially generated IDs.\nvar nextId = 1;\nfunction BindingWrapper(eventModel, expression, binding) {\n  this.eventModel = eventModel;\n  this.expression = expression;\n  this.binding = binding;\n  this.id = nextId++;\n  this.eventModels = null;\n  this.dependencies = null;\n  this.ignoreTemplateDependency = (\n    binding instanceof components.ComponentAttributeBinding\n  ) || (\n    (binding.template instanceof templates.DynamicText) &&\n    (binding instanceof templates.RangeBinding)\n  );\n  if (binding.meta) {\n    binding.meta.push(this);\n  } else {\n    binding.meta = [this];\n  }\n}\nBindingWrapper.prototype.updateDependencies = function() {\n  var dependencyOptions;\n  if (this.ignoreTemplateDependency && this.binding.condition instanceof templates.Template) {\n    dependencyOptions = new DependencyOptions();\n    dependencyOptions.setIgnoreTemplate(this.binding.condition);\n  }\n  var dependencies = this.expression.dependencies(this.binding.context, dependencyOptions);\n  if (this.dependencies) {\n    // Do nothing if dependencies haven't changed\n    if (equalDependencies(this.dependencies, dependencies)) return;\n    // Otherwise, remove current dependencies\n    this.eventModel.removeBinding(this);\n  }\n  // Add new dependencies\n  if (!dependencies) return;\n  this.dependencies = dependencies;\n  for (var i = 0, len = dependencies.length; i < len; i++) {\n    var dependency = dependencies[i];\n    if (dependency) this.eventModel.addBinding(dependency, this);\n  }\n};\nBindingWrapper.prototype.update = function(previous, pass) {\n  this.binding.update(previous, pass);\n  this.updateDependencies();\n};\nBindingWrapper.prototype.insert = function(index, howMany) {\n  this.binding.insert(index, howMany);\n  this.updateDependencies();\n};\nBindingWrapper.prototype.remove = function(index, howMany) {\n  this.binding.remove(index, howMany);\n  this.updateDependencies();\n};\nBindingWrapper.prototype.move = function(from, to, howMany) {\n  this.binding.move(from, to, howMany);\n  this.updateDependencies();\n};\n\nfunction equalDependencies(a, b) {\n  var lenA = a ? a.length : -1;\n  var lenB = b ? b.length : -1;\n  if (lenA !== lenB) return false;\n  for (var i = 0; i < lenA; i++) {\n    var itemA = a[i];\n    var itemB = b[i];\n    var lenItemA = itemA ? itemA.length : -1;\n    var lenItemB = itemB ? itemB.length : -1;\n    if (lenItemA !== lenItemB) return false;\n    for (var j = 0; j < lenItemB; j++) {\n      if (itemA[j] !== itemB[j]) return false;\n    }\n  }\n  return true;\n}\n\nfunction patchTextBinding(binding) {\n  if (\n    binding instanceof templates.AttributeBinding &&\n    binding.name === 'value' &&\n    (binding.element.tagName === 'INPUT' || binding.element.tagName === 'TEXTAREA') &&\n    documentListeners.inputSupportsSelection(binding.element) &&\n    binding.template.expression.resolve(binding.context)\n  ) {\n    binding.update = textInputUpdate;\n  }\n}\n\nfunction textInputUpdate(previous, pass) {\n  textUpdate(this, this.element, previous, pass);\n}\nfunction textUpdate(binding, element, previous, pass) {\n  if (pass) {\n    if (pass.$event && pass.$event.target === element) {\n      return;\n    } else if (pass.$stringInsert) {\n      return textDiff.onStringInsert(\n        element,\n        previous,\n        pass.$stringInsert.index,\n        pass.$stringInsert.text\n      );\n    } else if (pass.$stringRemove) {\n      return textDiff.onStringRemove(\n        element,\n        previous,\n        pass.$stringRemove.index,\n        pass.$stringRemove.howMany\n      );\n    }\n  }\n  binding.template.update(binding.context, binding);\n}\n",
    "// This file is intentionally empty.\n// It's used in browserifying as the placeholder for serialized views.\n",
    "/*\n * components.js\n *\n * Components associate custom script functionality with a view. They can be\n * distributed as standalone modules containing templates, scripts, and styles.\n * They can also be used to modularize application functionality.\n *\n */\n\nvar util = require('racer/lib/util');\nvar derbyTemplates = require('derby-templates');\nvar templates = derbyTemplates.templates;\nvar expressions = derbyTemplates.expressions;\nvar Controller = require('./Controller');\nvar slice = [].slice;\n\nexports.Component = Component;\nexports.ComponentAttribute = ComponentAttribute;\nexports.ComponentAttributeBinding = ComponentAttributeBinding;\nexports.ComponentFactory = ComponentFactory;\nexports.SingletonComponentFactory = SingletonComponentFactory;\nexports.createFactory = createFactory;\nexports.extendComponent = extendComponent;\n\nfunction Component(context, data) {\n  var parent = context.controller;\n  var id = context.id();\n  var scope = ['$components', id];\n  var model = parent.model.root.eventContext(id);\n  model._at = scope.join('.');\n  data.id = id;\n  model._set(scope, data);\n  // Store a reference to the component's scope such that the expression\n  // getters are relative to the component\n  model.data = data;\n\n  Controller.call(this, parent.app, parent.page, model);\n  this.parent = parent;\n  this.context = context.componentChild(this);\n  this.id = id;\n  this._scope = scope;\n\n  // Add reference to this component on the page so that all components\n  // associated with a page can be destroyed when the page transitions\n  this.page._components[id] = this;\n  this.isDestroyed = false;\n}\n\nutil.mergeInto(Component.prototype, Controller.prototype);\n\nComponent.prototype.destroy = function() {\n  this.emit('destroy');\n  this.model.removeContextListeners();\n  this.model.destroy();\n  delete this.page._components[this.id];\n  var components = this.page._eventModel.object.$components;\n  if (components) delete components.object[this.id];\n  this.isDestroyed = true;\n};\n\n// Apply calls to the passed in function with the component as the context.\n// Stop calling back once the component is destroyed, which avoids possible bugs\n// and memory leaks.\nComponent.prototype.bind = function(callback) {\n  var component = this;\n  this.on('destroy', function() {\n    // Reduce potential for memory leaks by removing references to the component\n    // and the passed in callback, which could have closure references\n    component = null;\n    // Cease calling back after component is removed from the DOM\n    callback = null;\n  });\n  return function componentBindWrapper() {\n    if (!callback) return;\n    return callback.apply(component, arguments);\n  };\n};\n\n// When passing in a numeric delay, calls the function at most once per that\n// many milliseconds. Like Underscore, the function will be called on the\n// leading and the trailing edge of the delay as appropriate. Unlike Underscore,\n// calls are consistently called via setTimeout and are never synchronous. This\n// should be used for reducing the frequency of ongoing updates, such as scroll\n// events or other continuous streams of events.\n//\n// Additionally, implements an interface intended to be used with\n// window.requestAnimationFrame or process.nextTick. If one of these is passed,\n// it will be used to create a single async call following any number of\n// synchronous calls. This mode is typically used to coalesce many synchronous\n// events (such as multiple model events) into a single async event.\n//\n// Like component.bind(), will no longer call back once the component is\n// destroyed, which avoids possible bugs and memory leaks.\nComponent.prototype.throttle = function(callback, delayArg) {\n  var component = this;\n  this.on('destroy', function() {\n    // Reduce potential for memory leaks by removing references to the component\n    // and the passed in callback, which could have closure references\n    component = null;\n    // Cease calling back after component is removed from the DOM\n    callback = null;\n  });\n\n  // throttle(callback)\n  // throttle(callback, 150)\n  if (delayArg == null || typeof delayArg === 'number') {\n    var delay = delayArg || 0;\n    var nextArgs;\n    var previous;\n    var boundCallback = function() {\n      var args = nextArgs;\n      nextArgs = null;\n      previous = +new Date();\n      if (callback && args) {\n        callback.apply(component, args);\n      }\n    };\n    return function componentThrottleWrapper() {\n      var queueCall = !nextArgs;\n      nextArgs = slice.call(arguments);\n      if (queueCall) {\n        var now = +new Date();\n        var remaining = Math.max(previous + delay - now, 0);\n        setTimeout(boundCallback, remaining);\n      }\n    };\n  }\n\n  // throttle(callback, window.requestAnimationFrame)\n  // throttle(callback, process.nextTick)\n  if (typeof delayArg === 'function') {\n    var nextArgs;\n    var boundCallback = function() {\n      var args = nextArgs;\n      nextArgs = null;\n      if (callback && args) {\n        callback.apply(component, args);\n      }\n    };\n    return function componentThrottleWrapper() {\n      var queueCall = !nextArgs;\n      nextArgs = slice.call(arguments);\n      if (queueCall) delayArg(boundCallback);\n    };\n  }\n\n  throw new Error('Second argument must be a delay function or number');\n};\n\n// Suppresses calls until the function is no longer called for that many\n// milliseconds. This should be used for delaying updates triggered by user\n// input, such as window resizing, or typing text that has a live preview or\n// client-side validation. This should not be used for inputs that trigger\n// server requests, such as search autocomplete; use debounceAsync for those\n// cases instead.\n//\n// Like component.bind(), will no longer call back once the component is\n// destroyed, which avoids possible bugs and memory leaks.\nComponent.prototype.debounce = function(callback, delay) {\n  delay = delay || 0;\n  if (typeof delay !== 'number') {\n    throw new Error('Second argument must be a number');\n  }\n  var component = this;\n  this.on('destroy', function() {\n    // Reduce potential for memory leaks by removing references to the component\n    // and the passed in callback, which could have closure references\n    component = null;\n    // Cease calling back after component is removed from the DOM\n    callback = null;\n  });\n  var nextArgs;\n  var timeout;\n  var boundCallback = function() {\n    var args = nextArgs;\n    nextArgs = null;\n    timeout = null;\n    if (callback && args) {\n      callback.apply(component, args);\n    }\n  };\n  return function componentDebounceWrapper() {\n    nextArgs = slice.call(arguments);\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(boundCallback, delay);\n  };\n};\n\n// Forked from: https://github.com/juliangruber/async-debounce\n//\n// Like debounce(), suppresses calls until the function is no longer called for\n// that many milliseconds. In addition, suppresses calls while the callback\n// function is running. In other words, the callback will not be called again\n// until the supplied done() argument is called. When the debounced function is\n// called while the callback is running, the callback will be called again\n// immediately after done() is called. Thus, the callback will always receive\n// the last value passed to the debounced function.\n//\n// This avoids the potential for multiple callbacks to execute in parallel and\n// complete out of order. It also acts as an adaptive rate limiter. Use this\n// method to debounce any field that triggers an async call as the user types.\n//\n// Like component.bind(), will no longer call back once the component is\n// destroyed, which avoids possible bugs and memory leaks.\nComponent.prototype.debounceAsync = function(callback, delay) {\n  var applyArguments = callback.length !== 1;\n  delay = delay || 0;\n  if (typeof delay !== 'number') {\n    throw new Error('Second argument must be a number');\n  }\n  var component = this;\n  this.on('destroy', function() {\n    // Reduce potential for memory leaks by removing references to the component\n    // and the passed in callback, which could have closure references\n    component = null;\n    // Cease calling back after component is removed from the DOM\n    callback = null;\n  });\n  var running = false;\n  var nextArgs;\n  var timeout;\n  function done() {\n    var args = nextArgs;\n    nextArgs = null;\n    timeout = null;\n    if (callback && args) {\n      running = true;\n      args.push(done);\n      callback.apply(component, args);\n    } else {\n      running = false;\n    }\n  }\n  return function componentDebounceAsyncWrapper() {\n    nextArgs = (applyArguments) ? slice.call(arguments) : [];\n    if (timeout) clearTimeout(timeout);\n    if (running) return;\n    timeout = setTimeout(done, delay);\n  };\n};\n\nComponent.prototype.get = function(viewName, unescaped) {\n  var view = this.getView(viewName);\n  return view.get(this.context, unescaped);\n};\n\nComponent.prototype.getFragment = function(viewName) {\n  var view = this.getView(viewName);\n  return view.getFragment(this.context);\n};\n\nComponent.prototype.getView = function(viewName) {\n  var contextView = this.context.getView();\n  return (viewName) ?\n    this.app.views.find(viewName, contextView.namespace) : contextView;\n};\n\nComponent.prototype.getAttribute = function(key) {\n  var attributeContext = this.context.forAttribute(key);\n  if (!attributeContext) return;\n  var value = attributeContext.attributes[key];\n  if (value instanceof expressions.Expression) {\n    value = value.get(attributeContext);\n  }\n  return expressions.renderValue(value, this.context);\n};\n\nComponent.prototype.setAttribute = function(key, value) {\n  this.context.parent.attributes[key] = value;\n};\n\nComponent.prototype.setNullAttribute = function(key, value) {\n  var attributes = this.context.parent.attributes;\n  if (attributes[key] == null) attributes[key] = value;\n};\n\nfunction ComponentAttribute(expression, model, key) {\n  this.expression = expression;\n  this.model = model;\n  this.key = key;\n}\nComponentAttribute.prototype.update = function(context, binding) {\n  var value = this.expression.get(context);\n  binding.condition = value;\n  this.model.setDiff(this.key, value);\n};\nfunction ComponentAttributeBinding(expression, model, key, context) {\n  this.template = new ComponentAttribute(expression, model, key);\n  this.context = context;\n  this.condition = expression.get(context);\n}\nComponentAttributeBinding.prototype = Object.create(templates.Binding.prototype);\nComponentAttributeBinding.prototype.constructor = ComponentAttributeBinding;\n\nfunction setModelAttributes(context, model) {\n  var attributes = context.parent.attributes;\n  if (!attributes) return;\n  // Set attribute values on component model\n  for (var key in attributes) {\n    var value = attributes[key];\n    setModelAttribute(context, model, key, value);\n  }\n}\n\nfunction setModelAttribute(context, model, key, value) {\n  // If an attribute is an Expression, set its current value in the model\n  // and keep it up to date. When it is a resolvable path, use a Racer ref,\n  // which makes it a two-way binding. Otherwise, set to the current value\n  // and create a binding that will set the value in the model as the\n  // expression's dependencies change.\n  if (value instanceof expressions.Expression) {\n    var segments = value.pathSegments(context);\n    if (segments) {\n      model.root.ref(model._at + '.' + key, segments.join('.'), {updateIndices: true});\n    } else {\n      var binding = new ComponentAttributeBinding(value, model, key, context);\n      context.addBinding(binding);\n      model.set(key, binding.condition);\n    }\n    return;\n  }\n\n  // If an attribute is a Template, set a template object in the model.\n  // Eagerly rendering a template can cause excessive rendering when the\n  // developer wants to pass in a complex chunk of HTML, and if we were to\n  // set a string in the model that represents the template value, we'd lose\n  // the ability to use the value in the component's template, since HTML\n  // would be escaped and we'd lose the ability to create proper bindings.\n  //\n  // This may be of surprise to developers, since it may not be intuitive\n  // whether a passed in value will produce an expression or a template. To\n  // get the rendered value consistently, the component's getAttribute(key)\n  // method may be used to get the value that would be rendered.\n  if (value instanceof templates.Template) {\n    var template = new templates.ContextClosure(value, context);\n    model.set(key, template);\n    return;\n  }\n\n  // For all other value types, set the passed in value directly. Passed in\n  // values will only be set initially, so model paths should be used if\n  // bindings are desired.\n  model.set(key, value);\n}\n\nfunction createFactory(constructor) {\n  // DEPRECATED: constructor.prototype.singleton is deprecated. \"singleton\"\n  // static property on the constructor is preferred\n  return (constructor.singleton || constructor.prototype.singleton) ?\n    new SingletonComponentFactory(constructor) :\n    new ComponentFactory(constructor);\n}\n\nfunction emitInitHooks(context, component) {\n  if (!context.initHooks) return;\n  // Run initHooks for `on` listeners immediately before init\n  for (var i = 0, len = context.initHooks.length; i < len; i++) {\n    context.initHooks[i].emit(context, component);\n  }\n}\n\nfunction ComponentModelData() {\n  this.id = null;\n  this.$controller = null;\n}\n\nfunction ComponentFactory(constructor) {\n  this.constructor = constructor;\n}\nComponentFactory.prototype.init = function(context) {\n  var DataConstructor = this.constructor.DataConstructor || ComponentModelData;\n  var data = new DataConstructor();\n  var component = new this.constructor(context, data);\n  // Detect whether the component constructor already called super by checking\n  // for one of the properties it sets. If not, call the Component constructor\n  if (!component.context) {\n    Component.call(component, context, data);\n  }\n\n  setModelAttributes(component.context, component.model);\n\n  // Do the user-specific initialization. The component constructor should be\n  // an empty function and the actual initialization code should be done in the\n  // component's init method. This means that we don't have to rely on users\n  // properly calling the Component constructor method and avoids having to\n  // play nice with how CoffeeScript extends class constructors\n  emitInitHooks(context, component);\n  component.emit('init', component);\n  if (component.init) component.init(component.model);\n\n  return component.context;\n};\nComponentFactory.prototype.create = function(context) {\n  var component = context.controller;\n  component.emit('create', component);\n  // Call the component's create function after its view is rendered\n  if (component.create) {\n    component.create(component.model, component.dom);\n  }\n};\n\nfunction noop() {}\n\nfunction SingletonComponentFactory(constructor) {\n  this.constructor = constructor;\n  this.component = null;\n  // Disable component from being destroyed, since it is intended to\n  // be used multiple times\n  constructor.prototype.destroy = noop;\n}\nSingletonComponentFactory.prototype.isSingleton = true;\nSingletonComponentFactory.prototype.init = function(context) {\n  if (!this.component) this.component = new this.constructor();\n  return context.componentChild(this.component);\n};\n// Don't call the init or create methods for singleton components\nSingletonComponentFactory.prototype.create = noop;\n\nfunction isBasePrototype(object) {\n  return (object === Object.prototype) ||\n    (object === Function.prototype) ||\n    (object === null);\n}\nfunction getRootPrototype(object) {\n  while (true) {\n    var prototype = Object.getPrototypeOf(object);\n    if (isBasePrototype(prototype)) return object;\n    object = prototype;\n  }\n}\nvar _extendComponent = (Object.setPrototypeOf && Object.getPrototypeOf) ?\n  // Modern version, which supports ES6 classes\n  function(constructor) {\n    // Find the end of the prototype chain\n    var rootPrototype = getRootPrototype(constructor.prototype);\n\n    // This guard is a workaroud to a bug that has occurred in Chakra when\n    // app.component() is invoked twice on the same constructor. In that case,\n    // the `instanceof Component` check in extendComponent incorrectly returns\n    // false after the prototype has already been set to `Component.prototype`.\n    // Then, this code proceeds to set the prototype of Component.prototype\n    // to itself, which throws a \"Cyclic __proto__ value\" error.\n    // https://github.com/Microsoft/ChakraCore/issues/5915\n    if (rootPrototype === Component.prototype) return;\n\n    // Establish inheritance with the pattern that Node's util.inherits() uses\n    // if Object.setPrototypeOf() is available (all modern browsers & IE11).\n    // This inhertance pattern is not equivalent to class extends, but it does\n    // work to make instances of the constructor inherit the desired prototype\n    // https://github.com/nodejs/node/issues/4179\n    Object.setPrototypeOf(rootPrototype, Component.prototype);\n  } :\n  // Fallback for older browsers\n  function(constructor) {\n    // In this version, we iterate over all of the properties on the\n    // constructor's prototype and merge them into a new prototype object.\n    // This flattens the prototype chain, meaning that instanceof will not\n    // work for classes from which the current component inherits\n    var prototype = constructor.prototype;\n    // Otherwise, modify constructor.prototype. This won't work with ES6\n    // classes, since their prototype property is non-writeable. However, it\n    // does work in older browsers that don't support Object.setPrototypeOf(),\n    // and those browsers don't support ES6 classes either\n    constructor.prototype = Object.create(Component.prototype);\n    constructor.prototype.constructor = constructor;\n    util.mergeInto(constructor.prototype, prototype);\n  };\nfunction extendComponent(constructor) {\n  // Don't do anything if the constructor already extends Component\n  if (constructor.prototype instanceof Component) return;\n  // Otherwise, append Component.prototype to constructor's prototype chain\n  _extendComponent(constructor);\n}\n",
    "var textDiff = require('./textDiff');\n\nexports.add = addDocumentListeners;\nexports.inputSupportsSelection = inputSupportsSelection;\n\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#do-not-apply\n// TODO: Date types support\nfunction inputSupportsSelection(input) {\n  var type = input.type;\n  return (\n    type === 'text' ||\n    type === 'textarea' ||\n    type === 'search' ||\n    type === 'url' ||\n    type === 'tel' ||\n    type === 'password'\n  );\n}\nfunction inputIsNumberValue(input) {\n  var type = input.type;\n  return (type === 'number' || (type === 'range' && !input.multiple));\n}\nvar inputValue = function(input) {\n  return inputIsNumberValue(input) ? input.valueAsNumber : input.value;\n};\n\nfunction addDocumentListeners(doc) {\n  doc.addEventListener('input', documentInput, true);\n  doc.addEventListener('change', documentChange, true);\n\n  // Listen to more events for versions of IE with buggy input event implementations\n  if (parseFloat(window.navigator.appVersion.split('MSIE ')[1]) <= 9) {\n    // We're listening on selectionchange because there's no other event emitted when\n    // the user clicks 'delete' from a context menu when right clicking on selected text.\n    // So although this event fires overly aggressively, it's the only real way\n    // to ensure that we can detect all changes to the input value in IE <= 9\n    doc.addEventListener('selectionchange', function(e){\n      if (document.activeElement) {\n        documentInput({target: document.activeElement}); // selectionchange evts don't have the e.target we need\n      }\n    }, true);\n  }\n\n  // For some reason valueAsNumber returns NaN for number inputs in IE\n  // until a new IE version that handles this is released, parse input.value as a fallback\n  var input = document.createElement('input');\n  input.type = 'number';\n  input.value = '7';\n  if (input.valueAsNumber !== input.valueAsNumber) {\n    var oldInputValue = inputValue;\n    inputValue = function(input) {\n      if (input.type === 'number') {\n        return inputIsNumberValue(input) ? parseFloat(input.value) : input.value;\n      } else {\n        return oldInputValue.apply(this, arguments);\n      }\n    };\n  }\n}\n\nfunction documentInput(e) {\n  var target = e.target;\n\n  if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {\n    setInputValue(e, target);\n  }\n}\n\nfunction documentChange(e) {\n  var target = e.target;\n\n  if (target.tagName === 'INPUT') {\n    setBoundProperty(target, 'checked');\n    setInputValue(e, target);\n\n  } else if (target.tagName === 'SELECT') {\n    setOptionBindings(target);\n\n  } else if (target.tagName === 'TEXTAREA') {\n    setInputValue(e, target);\n  }\n}\n\nfunction setBoundProperty(node, property) {\n  var binding = node.$bindAttributes && node.$bindAttributes[property];\n  if (!binding || binding.isUnbound()) return;\n\n  var value = node[property];\n  binding.template.expression.set(binding.context, value);\n}\n\nfunction setInputValue(e, target) {\n  var binding = target.$bindAttributes && target.$bindAttributes.value;\n  if (!binding || binding.isUnbound()) return;\n\n  if (inputSupportsSelection(target)) {\n    var pass = {$event: e};\n    textDiffBinding(binding, target.value, pass);\n  } else {\n    var value = inputValue(target);\n    binding.template.expression.set(binding.context, value);\n  }\n}\n\nfunction textDiffBinding(binding, value, pass) {\n  var expression = binding.template.expression;\n  var segments = expression.pathSegments(binding.context);\n  if (segments) {\n    var model = binding.context.controller.model.pass(pass);\n    textDiff.onTextInput(model, segments, value);\n  } else if (expression.set) {\n    expression.set(binding.context, value);\n  }\n}\n\nfunction setOptionBindings(parent) {\n  for (var node = parent.firstChild; node; node = node.nextSibling) {\n    if (node.tagName === 'OPTION') {\n      setBoundProperty(node, 'selected');\n    } else if (node.hasChildNodes()) {\n      setOptionBindings(node);\n    }\n  }\n}\n",
    "var expressions = require('derby-templates').expressions;\n\n// The many trees of bindings:\n//\n// - Model tree, containing your actual data. Eg:\n//    {users:{fred:{age:40}, wilma:{age:37}}}\n//\n// - Event model tree, whose structure mirrors the model tree. The event model\n//   tree lets us annotate the model tree with listeners which fire when events\n//   change. I think there are three types of listeners:\n//\n//   1. Reference binding binds to whatever is referred to by the path. Eg,\n//   {{each items as item}} binds item by reference as it goes through the\n//   list.\n//   2. Fixed path bindings explicitly bind to whatever is at that path\n//   regardless of how the model changes underneath the event model\n//   3. Listen on a subtree and fire when anything in the subtree changes. This\n//   is used for custom functions.\n//\n// {{foo.id}} would listen on the fixed path ['foo', 'id'].\n//\n//\n// - Context tree represents the changing (embedded) contexts of the templating\n//   engine. This maps to the tree of templates and allows templates to reference\n//   anything in any of their enclosing template scopes.\n//\n\nmodule.exports = EventModel;\n\n// The code here uses object-based set pattern where objects are keyed using\n// sequentially generated IDs.\nvar nextId = 1;\n\n// A binding object is something with update(), insert()/move()/remove() defined.\n\n\n// Given x[y] with model.get(y) == 5:\n//  item = 5\n//  segments = ['y']\n//  outside = the EventModel for x.\n//\n// Note that item could be a Context or another ModelRef - eg:\n//\n// {{ each foo as bar }} ... {{ x[bar] }}  -or-  {{ x[y[z]] }}\nfunction ModelRef(model, item, segments, outside) {\n  this.id = nextId++;\n\n  // We need a reference to the model & our segment list so we can update our\n  // value.\n  this.model = model;\n  this.segments = segments;\n\n  // Our current value.\n  this.item = item;\n\n  // outside is a reference to the EventModel of the thing on the lhs of the\n  // brackets. For example, in x[y].z, outside is the EventModel of x.\n  this.outside = outside;\n\n  // result is the EventModel of the evaluated version of the brackets. In\n  // x[y].z, its the EventModel of x[y].\n  this.result = outside.child(item).refChild(this);\n}\n\nModelRef.prototype.update = function() {\n  var segments = expressions.pathSegments(this.segments);\n  var newItem = expressions.lookup(segments, this.model.data);\n  if (this.item === newItem) return;\n\n  // First remove myself.\n  delete this.outside.child(this.item).refChildren[this.id];\n\n  this.item = newItem;\n\n  var container = this.outside.child(this.item);\n  // I want to just call refChild but that would create a new EM. Instead I\n  // want to just implant my current EM there.\n  if (!container.refChildren) container.refChildren = new RefChildrenMap();\n  container.refChildren[this.id] = this.result;\n\n  // Finally, update all the bindings in the tree.\n  this.result.update();\n};\n\n\nfunction RefOutMap() {}\nfunction RefChildrenMap() {}\nfunction BindingsMap() {}\nfunction ItemContextsMap() {}\nfunction EventModelsMap() {}\n\nfunction EventModel() {\n  this.id = nextId++;\n\n  // Most of these won't ever be filled in, so I'm just leaving them null.\n  //\n  // These contain our EventModel children.\n  this.object = null;\n  this.array = null;\n\n  // This contains any EventModel children which have floating references.\n  this.arrayByReference = null;\n\n  // If the data stored here is ever used to lookup other values, this is an\n  // object mapping remote child ID -> ref.\n  //\n  // Eg given x[y], y.refOut[x.id] = <Binding>\n  this.refOut = null;\n\n  // This is a map from ref id -> event model for events bound to this\n  // EventModel but via a ref. We could just merge them into the main tree, but\n  // this way they're easy to move.\n  //\n  // Eg, given x[y] (y=1), x.1.refChildren[ref id] is an EventModel.\n  this.refChildren = null;\n\n  this.bindings = null;\n\n  // Item contexts are contexts which need their item number changed as this\n  // EventModel object moves around its surrounding list.\n  this.itemContexts = null;\n}\n\nEventModel.prototype.refChild = function(ref) {\n  if (!this.refChildren) this.refChildren = new RefChildrenMap();\n  var id = ref.id;\n\n  if (!this.refChildren[id]) {\n    this.refChildren[id] = new EventModel();\n  }\n  return this.refChildren[id];\n};\n\nEventModel.prototype.arrayLookup = function(model, segmentsBefore, segmentsInside) {\n  var segments = expressions.pathSegments(segmentsInside);\n  var item = expressions.lookup(segments, model.data);\n\n  var source = this.at(segmentsInside);\n\n  // What the array currently resolves to. Given x[y] with y=1, container is\n  // the EM for x\n  var container = this.at(segmentsBefore);\n\n  if (!source.refOut) source.refOut = new RefOutMap();\n\n  var ref = source.refOut[container.id];\n  if (ref == null) {\n    ref = new ModelRef(model, item, segmentsInside, container);\n    source.refOut[container.id] = ref;\n  }\n\n  return ref;\n};\n\n// Returns the EventModel node of the named child.\nEventModel.prototype.child = function(segment) {\n  var container;\n  if (typeof segment === 'string') {\n    // Object\n    if (!this.object) this.object = {};\n    container = this.object;\n\n  } else if (typeof segment === 'number') {\n    // Array by value\n    if (!this.array) this.array = [];\n    container = this.array;\n\n  } else if (segment instanceof ModelRef) {\n    // Array reference. We'll need to lookup the child with the right\n    // value, then look inside its ref children for the right EventModel\n    // (so we can update it later). This is pretty janky, but should be\n    // *correct* even in the face of recursive array accessors.\n    //\n    // This will calculate it based on the current segment values, but refs\n    // cache the EM anyway.\n    //return this.child(segment.item).refChild(segment);\n    return segment.result;\n\n  } else {\n    // Array by reference\n    if (!this.arrayByReference) this.arrayByReference = [];\n    container = this.arrayByReference;\n    segment = segment.item;\n  }\n\n  return container[segment] || (container[segment] = new EventModel());\n};\n\n// Returns the EventModel node at the given segments list. Note that although\n// EventModel nodes are unique, its possible for multiple EventModel nodes to\n// refer to the same section of the model because of references.\n//\n// If you want to update the bindings that refer to a specific path, use\n// each().\n//\n// EventModel objects are created as needed.\nEventModel.prototype.at = function(segments) {\n  // For unbound dependancies.\n  if (segments == null) return this;\n\n  var eventModel = this;\n\n  for (var i = 0; i < segments.length; i++) {\n    eventModel = eventModel.child(segments[i]);\n  }\n\n  return eventModel;\n};\n\nEventModel.prototype.isEmpty = function() {\n  if (hasKeys(this.dependancies)) return false;\n  if (hasKeys(this.itemContexts)) return false;\n\n  if (this.object) {\n    if (hasKeys(this.object)) return false;\n    this.object = null;\n  }\n\n  if (this.arrayByReference) {\n    for (var i = 0; i < this.arrayByReference.length; i++) {\n      if (this.arrayByReference[i] != null) return false;\n    }\n    this.arrayByReference = null;\n  }\n\n  if (this.array) {\n    for (var i = 0; i < this.array.length; i++) {\n      if (this.array[i] != null) return false;\n    }\n    this.array = null;\n  }\n\n  return true;\n};\n\nfunction hasKeys(object) {\n  for (var key in object) {\n    return true;\n  }\n  return false;\n}\n\n\n// **** Updating the EventModel\n\nEventModel.prototype._addItemContext = function(context) {\n  if (!context._id) context._id = nextId++;\n  if (!this.itemContexts) this.itemContexts = new ItemContextsMap();\n  this.itemContexts[context._id] = context;\n};\n\nEventModel.prototype._removeItemContext = function(context) {\n  if (this.itemContexts) {\n    delete this.itemContexts[context._id];\n  }\n};\n\nEventModel.prototype._addBinding = function(binding) {\n  var bindings = this.bindings || (this.bindings = new BindingsMap());\n  binding.eventModels || (binding.eventModels = new EventModelsMap());\n  bindings[binding.id] = binding;\n  binding.eventModels[this.id] = this;\n};\n\n// This is the main hook to add bindings to the event model tree. It should\n// only be called on the root EventModel object.\nEventModel.prototype.addBinding = function(segments, binding) {\n  this.at(segments)._addBinding(binding);\n};\n\n// This is used for objects (contexts in derby's case) that have a .item\n// property which refers to an array index.\nEventModel.prototype.addItemContext = function(segments, context) {\n  this.at(segments)._addItemContext(context);\n};\n\nEventModel.prototype.removeBinding = function(binding) {\n  if (!binding.eventModels) return;\n  for (var id in binding.eventModels) {\n    var eventModel = binding.eventModels[id];\n    if (eventModel.bindings) delete eventModel.bindings[binding.id];\n  }\n  binding.eventModels = null;\n};\n\nEventModel.prototype._each = function(segments, pos, fn) {\n  // Our refChildren are effectively merged into this object.\n  if (this.refChildren) {\n    for (var id in this.refChildren) {\n      var refChild = this.refChildren[id];\n      if (refChild) refChild._each(segments, pos, fn);\n    }\n  }\n\n  if (segments.length === pos) {\n    fn(this);\n    return;\n  }\n\n  var segment = segments[pos];\n  var child;\n  if (typeof segment === 'string') {\n    // Object. Just recurse into our objects set. Its possible to rewrite this\n    // function to simply loop in the case of object lookups, but I don't think\n    // it'll buy us much.\n    child = this.object && this.object[segment];\n    if (child) child._each(segments, pos + 1, fn);\n\n  } else {\n    // Number. Recurse both into the fixed list and the reference list.\n    child = this.array && this.array[segment];\n    if (child) child._each(segments, pos + 1, fn);\n\n    child = this.arrayByReference && this.arrayByReference[segment];\n    if (child) child._each(segments, pos + 1, fn);\n  }\n};\n\n// Called when the scalar value at the path changes. This only calls update()\n// on this node. See update() below if you want to update entire\n// subtrees.\nEventModel.prototype.localUpdate = function(previous, pass) {\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.update(previous, pass);\n    }\n  }\n\n  // If our value changed, we also need to update anything that depends on it\n  // via refOut.\n  if (this.refOut) {\n    for (var id in this.refOut) {\n      var ref = this.refOut[id];\n      if (ref) ref.update();\n    }\n  }\n};\n\n// This is used when an object subtree is replaced / removed.\nEventModel.prototype.update = function(previous, pass) {\n  this.localUpdate(previous, pass);\n\n  if (this.object) {\n    for (var key in this.object) {\n      var binding = this.object[key];\n      if (binding) binding.update();\n    }\n  }\n\n  if (this.array) {\n    for (var i = 0; i < this.array.length; i++) {\n      var binding = this.array[i];\n      if (binding) binding.update();\n    }\n  }\n\n  if (this.arrayByReference) {\n    for (var i = 0; i < this.arrayByReference.length; i++) {\n      var binding = this.arrayByReference[i];\n      if (binding) binding.update();\n    }\n  }\n};\n\n// Updates the indexes in itemContexts of our children in the range of\n// [from, to). from and to both optional.\nEventModel.prototype._updateChildItemContexts = function(from, to) {\n  if (!this.arrayByReference) return;\n\n  if (from == null) from = 0;\n  if (to == null) to = this.arrayByReference.length;\n\n  for (var i = from; i < to; i++) {\n    var contexts = this.arrayByReference[i] &&\n      this.arrayByReference[i].itemContexts;\n    if (contexts) {\n      for (var key in contexts) {\n        contexts[key].item = i;\n      }\n    }\n  }\n};\n\n// Updates our array-by-value values. They have to recursively update every\n// binding in their children. Sad.\nEventModel.prototype._updateArray = function(from, to) {\n  if (!this.array) return;\n\n  if (from == null) from = 0;\n  if (to == null) to = this.array.length;\n\n  for (var i = from; i < to; i++) {\n    var binding = this.array[i];\n    if (binding) binding.update();\n  }\n};\n\nEventModel.prototype._updateObject = function() {\n  if (this.object) {\n    for (var key in this.object) {\n      var binding = this.object[key];\n      if (binding) binding.update();\n    }\n  }\n};\n\nEventModel.prototype._set = function(previous, pass) {\n  // This just updates anything thats bound to the whole subtree. An alternate\n  // implementation could be passed in the new value at this node (which we\n  // cache), then compare with the old version and only update parts of the\n  // subtree which are relevant. I don't know if thats an important\n  // optimization - it really depends on your use case.\n  this.update(previous, pass);\n};\n\n// Insert into this EventModel node.\nEventModel.prototype._insert = function(index, howMany) {\n  // Update fixed paths\n  this._updateArray(index);\n\n  // Update relative paths\n  if (this.arrayByReference && this.arrayByReference.length > index) {\n    // Shift the actual items in the array references array.\n\n    // This probably isn't the best way to implement insert. Other options are\n    // using concat() on slices or though constructing a temporary array and\n    // using splice.call. Hopefully if this method is slow it'll come up during\n    // profiling.\n    for (var i = 0; i < howMany; i++) {\n      this.arrayByReference.splice(index, 0, null);\n    }\n\n    // Update the path in the contexts\n    this._updateChildItemContexts(index + howMany);\n  }\n\n  // Finally call our bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.insert(index, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n// Remove howMany child elements from this EventModel at index.\nEventModel.prototype._remove = function(index, howMany) {\n  // Update fixed paths. Both the removed items and items after it may have changed.\n  this._updateArray(index);\n\n  if (this.arrayByReference) {\n    // Update relative paths. First throw away all the children which have been removed.\n    this.arrayByReference.splice(index, howMany);\n\n    this._updateChildItemContexts(index);\n  }\n\n  // Call bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.remove(index, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n// Move howMany items from `from` to `to`.\nEventModel.prototype._move = function(from, to, howMany) {\n  // first points to the first element that was moved. end points to the list\n  // element past the end of the changed region.\n  var first, end;\n  if (from < to) {\n    first = from;\n    end = to + howMany;\n  } else {\n    first = to;\n    end = from + howMany;\n  }\n\n  // Update fixed paths.\n  this._updateArray(first, end);\n\n  // Update relative paths\n  var arr = this.arrayByReference;\n  if (arr && arr.length > first) {\n    // Remove from the old location\n    var values = arr.splice(from, howMany);\n\n    // Insert at the new location\n    arr.splice.apply(arr, [to, 0].concat(values));\n\n    // Update the path in the contexts\n    this._updateChildItemContexts(first, end);\n  }\n\n  // Finally call our bindings.\n  if (this.bindings) {\n    for (var id in this.bindings) {\n      var binding = this.bindings[id];\n      if (binding) binding.move(from, to, howMany);\n    }\n  }\n  this._updateObject();\n};\n\n\n// Helpers.\n\nEventModel.prototype.mutate = function(segments, fn) {\n  // This finds & returns a list of all event models which exist and could match\n  // the specified path. The path cannot contain contexts like derby expression\n  // segment lists (just because I don't think thats a useful feature and its not\n  // implemented)\n  this._each(segments, 0, fn);\n\n  // Also emit all mutations as sets on star paths, which are how dependencies\n  // for view helper functions are represented. They should react to a path\n  // or any child path being modified\n  for (var i = 0, len = segments.length; i++ < len;) {\n    var wildcardSegments = segments.slice(0, i);\n    wildcardSegments.push('*');\n    this._each(wildcardSegments, 0, childSetWildcard);\n  }\n};\n\nfunction childSetWildcard(child) {\n  child._set();\n}\n\nEventModel.prototype.set = function(segments, previous, pass) {\n  this.mutate(segments, function childSet(child) {\n    child._set(previous, pass);\n  });\n};\n\nEventModel.prototype.insert = function(segments, index, howMany) {\n  this.mutate(segments, function childInsert(child) {\n    child._insert(index, howMany);\n  });\n};\n\nEventModel.prototype.remove = function(segments, index, howMany) {\n  this.mutate(segments, function childRemove(child) {\n    child._remove(index, howMany);\n  });\n};\n\nEventModel.prototype.move = function(segments, from, to, howMany) {\n  this.mutate(segments, function childMove(child) {\n    child._move(from, to, howMany);\n  });\n};\n",
    "// TODO: Refactor and include derby-parsing module in derby itself\nexports = module.exports = require('derby-parsing');\nvar htmlUtil = require('html-util');\nvar path = require('path');\nvar App = require('../App');\n\nApp.prototype.addViews = function(file, namespace) {\n  var views = exports.parseViews(file, namespace);\n  exports.registerParsedViews(this, views);\n};\n\nexports.getImportNamespace = function(namespace, attrs, importFilename) {\n  var extension = path.extname(importFilename);\n  var relativeNamespace = (attrs.ns == null) ?\n    path.basename(attrs.src, extension) :\n    attrs.ns;\n  return (namespace && relativeNamespace) ?\n    namespace + ':' + relativeNamespace :\n    namespace || relativeNamespace || '';\n};\n\nexports.parseViews = function(file, namespace, filename, onImport) {\n  var views = [];\n  var prefix = (namespace) ? namespace + ':' : '';\n\n  htmlUtil.parse(file + '\\n', {\n    // Force view tags to be treated as raw tags,\n    // meaning their contents are not parsed as HTML\n    rawTags: /^(?:[^\\s=\\/!>]+:|style|script)$/i,\n    matchEnd: matchEnd,\n    start: onStart,\n    text: onText\n  });\n\n  function matchEnd(tagName) {\n    if (tagName.slice(-1) === ':') {\n      return /<\\/?[^\\s=\\/!>]+:[\\s>]/i;\n    }\n    return new RegExp('</' + tagName, 'i');\n  }\n\n  // These variables pass state from attributes in the start tag to the\n  // following view template text\n  var name, attrs;\n\n  function onStart(tag, tagName, tagAttrs) {\n    var lastChar = tagName.charAt(tagName.length - 1);\n    if (lastChar !== ':') {\n      throw new Error('Expected tag ending in colon (:) instead of ' + tag);\n    }\n    name = tagName.slice(0, -1);\n    attrs = tagAttrs;\n    if (name === 'import') {\n      if (typeof onImport === 'function') {\n      \tonImport(attrs);\n      } else {\n      \tthrow new Error('Template import implementation not provided');\n      }\n    }\n  }\n\n  function onText(text, isRawText) {\n    if (!name || name === 'import') return;\n    views.push({\n      name: prefix + name,\n      source: text,\n      options: attrs,\n      filename: filename\n    });\n  }\n\n  return views;\n};\n\nexports.registerParsedViews = function(app, items) {\n  for (var i = 0, len = items.length; i < len; i++) {\n    var item = items[i];\n    app.views.register(item.name, item.source, item.options);\n  }\n};\n",
    "exports.onStringInsert = onStringInsert;\nexports.onStringRemove = onStringRemove;\nexports.onTextInput = onTextInput;\n\nfunction onStringInsert(el, previous, index, text) {\n  function transformCursor(cursor) {\n    return (index < cursor) ? cursor + text.length : cursor;\n  }\n  previous || (previous = '');\n  var newText = previous.slice(0, index) + text + previous.slice(index);\n  replaceText(el, newText, transformCursor);\n}\n\nfunction onStringRemove(el, previous, index, howMany) {\n  function transformCursor(cursor) {\n    return (index < cursor) ? cursor - Math.min(howMany, cursor - index) : cursor;\n  }\n  previous || (previous = '');\n  var newText = previous.slice(0, index) + previous.slice(index + howMany);\n  replaceText(el, newText, transformCursor);\n}\n\nfunction replaceText(el, newText, transformCursor) {\n  var selectionStart = transformCursor(el.selectionStart);\n  var selectionEnd = transformCursor(el.selectionEnd);\n\n  var scrollTop = el.scrollTop;\n  el.value = newText;\n  if (el.scrollTop !== scrollTop) {\n    el.scrollTop = scrollTop;\n  }\n  if (document.activeElement === el) {\n    el.selectionStart = selectionStart;\n    el.selectionEnd = selectionEnd;\n  }\n}\n\nfunction onTextInput(model, segments, value) {\n  var previous = model._get(segments) || '';\n  if (previous === value) return;\n  var start = 0;\n  while (previous.charAt(start) === value.charAt(start)) {\n    start++;\n  }\n  var end = 0;\n  while (\n    previous.charAt(previous.length - 1 - end) === value.charAt(value.length - 1 - end) &&\n    end + start < previous.length &&\n    end + start < value.length\n  ) {\n    end++;\n  }\n\n  if (previous.length !== start + end) {\n    var howMany = previous.length - start - end;\n    model._stringRemove(segments, start, howMany);\n  }\n  if (value.length !== start + end) {\n    var inserted = value.slice(start, value.length - end);\n    model._stringInsert(segments, start, inserted);\n  }\n}\n",
    "module.exports = require('./lib/parsing');\n",
    "/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\ncreateLocationMarker: true,\nthrowError: true, generateStatement: true, peek: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseUnaryExpression: true,\nparseStatement: true, parseSourceElement: true */\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        SyntaxTreeDelegate,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        delegate,\n        lookahead,\n        state,\n        extra;\n\n    Token = {\n        UndefinedLiteral: -1,  // DERBY\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9\n    };\n\n    TokenName = {};\n    TokenName[Token.UndefinedLiteral] = 'Undefined';  // DERBY\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        BinaryExpression: 'BinaryExpression',\n        CallExpression: 'CallExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ExpressionStatement: 'ExpressionStatement',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        Literal: 'Literal',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Property: 'Property',\n        SequenceExpression: 'SequenceExpression',\n        ThisExpression: 'ThisExpression',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnexpectedNumber:  'Unexpected number',\n        UnexpectedString:  'Unexpected string',\n        UnexpectedIdentifier:  'Unexpected identifier',\n        UnexpectedReserved:  'Unexpected reserved word',\n        UnexpectedEOS:  'Unexpected end of input',\n        NewlineAfterThrow:  'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp:  'Invalid regular expression: missing /',\n        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n        InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally:  'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith:  'Strict mode code may not include a with statement',\n        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n        StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord:  'Use of future reserved word in strict mode'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0\\u08A2-\\u08AC\\u08E4-\\u08FE\\u0900-\\u0963\\u0966-\\u096F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1D00-\\u1DE6\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA697\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7B\\uAA80-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 48 && ch <= 57);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch === 0x40) || (ch === 0x23) ||     // DERBY: @ (at sign) and # (number sign)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        return false;\n    }\n\n    function isStrictModeReservedWord(id) {\n        return false;\n    }\n\n    function isRestrictedWord(id) {\n        return false;\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        return (id === 'this') ||\n            (id === 'typeof') ||\n            (id === 'instanceof') ||\n            (id === 'in') ||\n            (id === 'new');\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment, attacher;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (state.lastCommentStart >= start) {\n            return;\n        }\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n\n        if (extra.attachComment) {\n            attacher = {\n                comment: comment,\n                leading: null,\n                trailing: null,\n                range: [start, end]\n            };\n            extra.pendingComments.push(attacher);\n        }\n    }\n\n    function skipSingleLineComment() {\n        var start, loc, ch, comment;\n\n        start = index - 2;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - 2\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                if (extra.comments) {\n                    comment = source.slice(start + 2, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + 2, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n                if (index >= length) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            } else if (ch === 0x2A) {\n                // Block comment ends with '*/'.\n                if (source.charCodeAt(index + 1) === 0x2F) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    function skipComment() {\n        var ch, start;\n\n        start = (index === 0);\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                start = true;\n            } else if (ch === 0x2F) { // U+002F is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x2F) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment();\n                    start = true;\n                } else if (ch === 0x2A) {  // U+002A is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else if (start && ch === 0x2D) { // U+002D is '-'\n                // U+003E is '>'\n                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {\n                    // '-->' is a single-line comment\n                    index += 3;\n                    skipSingleLineComment();\n                } else {\n                    break;\n                }\n            } else if (ch === 0x3C) { // U+003C is '<'\n                if (source.slice(index + 1, index + 4) === '!--') {\n                    ++index; // `<`\n                    ++index; // `!`\n                    ++index; // `-`\n                    ++index; // `-`\n                    skipSingleLineComment();\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\n        if (ch === 0x5C) {\n            if (source.charCodeAt(index) !== 0x75) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (U+005C, U+0075) denotes an escaped character.\n            if (ch === 0x5C) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 0x75) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x5C) {\n                // Blackslash (U+005C) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (U+005C) starts an escaped character.\n        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'undefined') {  // DERBY\n            type = Token.Undefined;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        switch (code) {\n\n        // Check for most common single-character punctuators.\n        case 0x2E:  // . dot\n        case 0x28:  // ( open bracket\n        case 0x29:  // ) close bracket\n        case 0x3B:  // ; semicolon\n        case 0x2C:  // , comma\n        case 0x7B:  // { open curly brace\n        case 0x7D:  // } close curly brace\n        case 0x5B:  // [\n        case 0x5D:  // ]\n        case 0x3A:  // :\n        case 0x3F:  // ?\n        case 0x7E:  // ~\n            ++index;\n            if (extra.tokenize) {\n                if (code === 0x28) {\n                    extra.openParenToken = extra.tokens.length;\n                } else if (code === 0x7B) {\n                    extra.openCurlyToken = extra.tokens.length;\n                }\n            }\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (U+003D) marks an assignment or comparison operator.\n            if (code2 === 0x3D) {\n                switch (code) {\n                case 0x25:  // %\n                case 0x26:  // &\n                case 0x2A:  // *:\n                case 0x2B:  // +\n                case 0x2D:  // -\n                case 0x2F:  // /\n                case 0x3C:  // <\n                case 0x3E:  // >\n                case 0x5E:  // ^\n                case 0x7C:  // |\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n\n                case 0x21: // !\n                case 0x3D: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 0x3D) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        range: [start, index]\n                    };\n                default:\n                    break;\n                }\n            }\n            break;\n        }\n\n        // Peek more characters.\n\n        ch2 = source[index + 1];\n        ch3 = source[index + 2];\n        ch4 = source[index + 3];\n\n        // 4-character punctuator: >>>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            if (ch4 === '=') {\n                index += 4;\n                return {\n                    type: Token.Punctuator,\n                    value: '>>>=',\n                    lineNumber: lineNumber,\n                    lineStart: lineStart,\n                    range: [start, index]\n                };\n            }\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>>',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '<<=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: '>>=',\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        // Other 2-character punctuators: ++ -- << >> && ||\n\n        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch1 + ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanOctalLiteral(start) {\n        var number = '0' + source[index++];\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: true,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (isOctalDigit(ch)) {\n                    return scanOctalLiteral(start);\n                }\n\n                // decimal number starts with '0' such as '09' is illegal.\n                if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            range: [start, index]\n        };\n    }\n\n    function scanRegExp() {\n        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;\n\n        lookahead = null;\n        skipComment();\n\n        start = index;\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        pattern = str.substr(1, str.length - 2);\n\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                } else {\n                    str += '\\\\';\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n\n\n\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [start, index]\n            };\n        }\n        return {\n            literal: str,\n            value: value,\n            range: [start, index]\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.Undefined ||  // DERBY\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return collectRegex();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return collectRegex();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return collectRegex();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return collectRegex();\n            }\n            return collectRegex();\n        }\n        if (prevToken.type === 'Keyword') {\n            return collectRegex();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                range: [index, index]\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        // Very common: ( and ) and ;\n        if (ch === 0x28 || ch === 0x29 || ch === 0x3A) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (U+0027) or double quote (U+0022).\n        if (ch === 0x27 || ch === 0x22) {\n            return scanStringLiteral();\n        }\n\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Dot (.) U+002E can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 0x2E) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) U+002F can also start a regex.\n        if (extra.tokenize && ch === 0x2F) {\n            return advanceSlash();\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var start, loc, token, range, value;\n\n        skipComment();\n        start = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            range = [token.range[0], token.range[1]];\n            value = source.slice(token.range[0], token.range[1]);\n            extra.tokens.push({\n                type: TokenName[token.type],\n                value: value,\n                range: range,\n                loc: loc\n            });\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n        index = token.range[1];\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        return token;\n    }\n\n    function peek() {\n        var pos, line, start;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n    }\n\n    SyntaxTreeDelegate = {\n\n        name: 'SyntaxTree',\n\n        markStart: function () {\n            if (extra.loc) {\n                state.markerStack.push(index - lineStart);\n                state.markerStack.push(lineNumber);\n            }\n            if (extra.range) {\n                state.markerStack.push(index);\n            }\n        },\n\n        processComment: function (node) {\n            var i, attacher, pos, len, candidate;\n\n            if (typeof node.type === 'undefined' || node.type === Syntax.Program) {\n                return;\n            }\n\n            // Check for possible additional trailing comments.\n            peek();\n\n            for (i = 0; i < extra.pendingComments.length; ++i) {\n                attacher = extra.pendingComments[i];\n                if (node.range[0] >= attacher.comment.range[1]) {\n                    candidate = attacher.leading;\n                    if (candidate) {\n                        pos = candidate.range[0];\n                        len = candidate.range[1] - pos;\n                        if (node.range[0] <= pos && (node.range[1] - node.range[0] >= len)) {\n                            attacher.leading = node;\n                        }\n                    } else {\n                        attacher.leading = node;\n                    }\n                }\n                if (node.range[1] <= attacher.comment.range[0]) {\n                    candidate = attacher.trailing;\n                    if (candidate) {\n                        pos = candidate.range[0];\n                        len = candidate.range[1] - pos;\n                        if (node.range[0] <= pos && (node.range[1] - node.range[0] >= len)) {\n                            attacher.trailing = node;\n                        }\n                    } else {\n                        attacher.trailing = node;\n                    }\n                }\n            }\n        },\n\n        markEnd: function (node) {\n            if (extra.range) {\n                node.range = [state.markerStack.pop(), index];\n            }\n            if (extra.loc) {\n                node.loc = {\n                    start: {\n                        line: state.markerStack.pop(),\n                        column: state.markerStack.pop()\n                    },\n                    end: {\n                        line: lineNumber,\n                        column: index - lineStart\n                    }\n                };\n                this.postProcess(node);\n            }\n            if (extra.attachComment) {\n                this.processComment(node);\n            }\n            return node;\n        },\n\n        markEndIf: function (node) {\n            if (node.range || node.loc) {\n                if (extra.loc) {\n                    state.markerStack.pop();\n                    state.markerStack.pop();\n                }\n                if (extra.range) {\n                    state.markerStack.pop();\n                }\n            } else {\n                this.markEnd(node);\n            }\n            return node;\n        },\n\n        postProcess: function (node) {\n            if (extra.source) {\n                node.loc.source = extra.source;\n            }\n            return node;\n        },\n\n        createArrayExpression: function (elements) {\n            return {\n                type: Syntax.ArrayExpression,\n                elements: elements\n            };\n        },\n\n        createAssignmentExpression: function (operator, left, right) {\n            return {\n                type: Syntax.AssignmentExpression,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBinaryExpression: function (operator, left, right) {\n            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :\n                        Syntax.BinaryExpression;\n            return {\n                type: type,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createCallExpression: function (callee, args) {\n            return {\n                type: Syntax.CallExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createConditionalExpression: function (test, consequent, alternate) {\n            return {\n                type: Syntax.ConditionalExpression,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createExpressionStatement: function (expression) {\n            return {\n                type: Syntax.ExpressionStatement,\n                expression: expression\n            };\n        },\n\n        createFunctionExpression: function (id, params, defaults, body) {\n            return {\n                type: Syntax.FunctionExpression,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: null,\n                generator: false,\n                expression: false\n            };\n        },\n\n        createIdentifier: function (name) {\n            return {\n                type: Syntax.Identifier,\n                name: name\n            };\n        },\n\n        createLiteral: function (token) {\n            return {\n                type: Syntax.Literal,\n                value: token.value,\n                raw: source.slice(token.range[0], token.range[1])\n            };\n        },\n\n        createMemberExpression: function (accessor, object, property) {\n            return {\n                type: Syntax.MemberExpression,\n                computed: accessor === '[',\n                object: object,\n                property: property\n            };\n        },\n\n        createNewExpression: function (callee, args) {\n            return {\n                type: Syntax.NewExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createObjectExpression: function (properties) {\n            return {\n                type: Syntax.ObjectExpression,\n                properties: properties\n            };\n        },\n\n        createPostfixExpression: function (operator, argument) {\n            return {\n                type: Syntax.UpdateExpression,\n                operator: operator,\n                argument: argument,\n                prefix: false\n            };\n        },\n\n        createProperty: function (kind, key, value) {\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: value,\n                kind: kind\n            };\n        },\n\n        createSequenceExpression: function (expressions) {\n            return {\n                type: Syntax.SequenceExpression,\n                expressions: expressions\n            };\n        },\n\n        createThisExpression: function () {\n            return {\n                type: Syntax.ThisExpression\n            };\n        },\n\n        createUnaryExpression: function (operator, argument) {\n            if (operator === '++' || operator === '--') {\n                return {\n                    type: Syntax.UpdateExpression,\n                    operator: operator,\n                    argument: argument,\n                    prefix: true\n                };\n            }\n            return {\n                type: Syntax.UnaryExpression,\n                operator: operator,\n                argument: argument,\n                prefix: true\n            };\n        }\n    };\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    assert(index < args.length, 'Message reference must be in range');\n                    return args[index];\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.range[0];\n            error.lineNumber = token.lineNumber;\n            error.column = token.range[0] - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        error.description = msg;\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var line;\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(index) === 0x3B) {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            return;\n        }\n\n        if (match(';')) {\n            lex();\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpected(lookahead);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [];\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseAssignmentExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        expect(']');\n\n        return delegate.createArrayExpression(elements);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(param, first) {\n        var previousStrict, body;\n\n        previousStrict = strict;\n        skipComment();\n        delegate.markStart();\n        body = parseFunctionSourceElements();\n        if (first && strict && isRestrictedWord(param[0].name)) {\n            throwErrorTolerant(first, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body));\n    }\n\n    function parseObjectPropertyKey() {\n        var token;\n\n        skipComment();\n        delegate.markStart();\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return delegate.markEnd(delegate.createLiteral(token));\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value));\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, value, param;\n\n        token = lookahead;\n        skipComment();\n        delegate.markStart();\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                value = parsePropertyFunction([]);\n                return delegate.markEnd(delegate.createProperty('get', key, value));\n            }\n            if (token.value === 'set' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead;\n                if (token.type !== Token.Identifier) {\n                    expect(')');\n                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n                    value = parsePropertyFunction([]);\n                } else {\n                    param = [ parseVariableIdentifier() ];\n                    expect(')');\n                    value = parsePropertyFunction(param, token);\n                }\n                return delegate.markEnd(delegate.createProperty('set', key, value));\n            }\n            expect(':');\n            value = parseAssignmentExpression();\n            return delegate.markEnd(delegate.createProperty('init', id, value));\n        }\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpected(token);\n        } else {\n            key = parseObjectPropertyKey();\n            expect(':');\n            value = parseAssignmentExpression();\n            return delegate.markEnd(delegate.createProperty('init', key, value));\n        }\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, key, kind, map = {}, toString = String;\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n            key = '$' + name;\n            if (Object.prototype.hasOwnProperty.call(map, key)) {\n                if (map[key] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    } else if (map[key] & kind) {\n                        throwErrorTolerant({}, Messages.AccessorGetSet);\n                    }\n                }\n                map[key] |= kind;\n            } else {\n                map[key] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return delegate.createObjectExpression(properties);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr;\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        type = lookahead.type;\n        delegate.markStart();\n\n        if (type === Token.Identifier) {\n            expr =  delegate.createIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = delegate.createLiteral(lex());\n        } else if (type === Token.Keyword) {\n            if (matchKeyword('this')) {\n                lex();\n                expr = delegate.createThisExpression();\n            } else if (matchKeyword('function')) {\n                expr = parseFunctionExpression();\n            }\n        } else if (type === Token.BooleanLiteral) {\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = delegate.createLiteral(token);\n        } else if (type === Token.Undefined) {  // DERBY\n            token = lex();\n            token.value = void 0;\n            expr = delegate.createLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            token = lex();\n            token.value = null;\n            expr = delegate.createLiteral(token);\n        } else if (match('[')) {\n            expr = parseArrayInitialiser();\n        } else if (match('{')) {\n            expr = parseObjectInitialiser();\n        } else if (match('/') || match('/=')) {\n            if (typeof extra.tokens !== 'undefined') {\n                expr = delegate.createLiteral(collectRegex());\n            } else {\n                expr = delegate.createLiteral(scanRegExp());\n            }\n            peek();\n        }\n\n        if (expr) {\n            return delegate.markEnd(expr);\n        }\n\n        throwUnexpected(lex());\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseAssignmentExpression());\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token;\n\n        delegate.markStart();\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value));\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args;\n\n        delegate.markStart();\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n\n        return delegate.markEnd(delegate.createNewExpression(callee, args));\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var marker, previousAllowIn, expr, args, property;\n\n        marker = createLocationMarker();\n\n        previousAllowIn = state.allowIn;\n        state.allowIn = true;\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n        state.allowIn = previousAllowIn;\n\n        while (match('.') || match('[') || match('(')) {\n            if (match('(')) {\n                args = parseArguments();\n                expr = delegate.createCallExpression(expr, args);\n            } else if (match('[')) {\n                property = parseComputedMember();\n                expr = delegate.createMemberExpression('[', expr, property);\n            } else {\n                property = parseNonComputedMember();\n                expr = delegate.createMemberExpression('.', expr, property);\n            }\n            if (marker) {\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var marker, previousAllowIn, expr, property;\n\n        marker = createLocationMarker();\n\n        previousAllowIn = state.allowIn;\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n        state.allowIn = previousAllowIn;\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                property = parseComputedMember();\n                expr = delegate.createMemberExpression('[', expr, property);\n            } else {\n                property = parseNonComputedMember();\n                expr = delegate.createMemberExpression('.', expr, property);\n            }\n            if (marker) {\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token;\n\n        delegate.markStart();\n        expr = parseLeftHandSideExpressionAllowCall();\n\n        if (lookahead.type === Token.Punctuator) {\n            if ((match('++') || match('--')) && !peekLineTerminator()) {\n                // 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    throwErrorTolerant({}, Messages.StrictLHSPostfix);\n                }\n\n                if (!isLeftHandSide(expr)) {\n                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n                }\n\n                token = lex();\n                expr = delegate.createPostfixExpression(token.value, expr);\n            }\n        }\n\n        return delegate.markEndIf(expr);\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr;\n\n        delegate.markStart();\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = delegate.createUnaryExpression(token.value, expr);\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return delegate.markEndIf(expr);\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n        marker = createLocationMarker();\n        left = parseUnaryExpression();\n\n        token = lookahead;\n        prec = binaryPrecedence(token, state.allowIn);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n\n        markers = [marker, createLocationMarker()];\n        right = parseUnaryExpression();\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                expr = delegate.createBinaryExpression(operator, left, right);\n                markers.pop();\n                marker = markers.pop();\n                if (marker) {\n                    marker.end();\n                    marker.apply(expr);\n                }\n                stack.push(expr);\n                markers.push(marker);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(createLocationMarker());\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n            marker = markers.pop();\n            if (marker) {\n                marker.end();\n                marker.apply(expr);\n            }\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate;\n\n        delegate.markStart();\n        expr = parseBinaryExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n\n            expr = delegate.markEnd(delegate.createConditionalExpression(expr, consequent, alternate));\n        } else {\n            delegate.markEnd({});\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, left, right, node;\n\n        token = lookahead;\n        delegate.markStart();\n        node = left = parseConditionalExpression();\n\n        if (matchAssign()) {\n            // LeftHandSideExpression\n            if (!isLeftHandSide(left)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            token = lex();\n            right = parseAssignmentExpression();\n            node = delegate.createAssignmentExpression(token.value, left, right);\n        }\n\n        return delegate.markEndIf(node);\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr;\n\n        delegate.markStart();\n        expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expr = delegate.createSequenceExpression([ expr ]);\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expr.expressions.push(parseAssignmentExpression());\n            }\n        }\n\n        return delegate.markEndIf(expr);\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return delegate.createExpressionStatement(expr);\n    }\n\n    function parseProgram() {\n        skipComment();\n        delegate.markStart();\n        strict = false;\n        peek();\n        return delegate.markEnd(parseExpressionStatement());\n    }\n\n    function attachComments() {\n        var i, attacher, comment, leading, trailing;\n\n        for (i = 0; i < extra.pendingComments.length; ++i) {\n            attacher = extra.pendingComments[i];\n            comment = attacher.comment;\n            leading = attacher.leading;\n            if (leading) {\n                if (typeof leading.leadingComments === 'undefined') {\n                    leading.leadingComments = [];\n                }\n                leading.leadingComments.push(attacher.comment);\n            }\n            trailing = attacher.trailing;\n            if (trailing) {\n                if (typeof trailing.trailingComments === 'undefined') {\n                    trailing.trailingComments = [];\n                }\n                trailing.trailingComments.push(attacher.comment);\n            }\n        }\n        extra.pendingComments = [];\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function LocationMarker() {\n        this.marker = [index, lineNumber, index - lineStart, 0, 0, 0];\n    }\n\n    LocationMarker.prototype = {\n        constructor: LocationMarker,\n\n        end: function () {\n            this.marker[3] = index;\n            this.marker[4] = lineNumber;\n            this.marker[5] = index - lineStart;\n        },\n\n        apply: function (node) {\n            if (extra.range) {\n                node.range = [this.marker[0], this.marker[3]];\n            }\n            if (extra.loc) {\n                node.loc = {\n                    start: {\n                        line: this.marker[1],\n                        column: this.marker[2]\n                    },\n                    end: {\n                        line: this.marker[4],\n                        column: this.marker[5]\n                    }\n                };\n                node = delegate.postProcess(node);\n            }\n            if (extra.attachComment) {\n                delegate.processComment(node);\n            }\n        }\n    };\n\n    function createLocationMarker() {\n        if (!extra.loc && !extra.range) {\n            return null;\n        }\n\n        skipComment();\n\n        return new LocationMarker();\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            token,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            token = lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    token = lex();\n                } catch (lexError) {\n                    token = lookahead;\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            markerStack: []\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.pendingComments = [];\n                extra.comments = [];\n            }\n        }\n\n        if (length > 0) {\n            if (typeof source[0] === 'undefined') {\n                // Try first to convert to a string. This is good as fast path\n                // for old IE which understands string indexing for string\n                // literals only and not for string object.\n                if (code instanceof String) {\n                    source = code.valueOf();\n                }\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n            if (extra.attachComment) {\n                attachComments();\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '1.1.0-dev';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar objectCreate = Object.create || objectCreatePolyfill\nvar objectKeys = Object.keys || objectKeysPolyfill\nvar bind = Function.prototype.bind || functionBindPolyfill\n\nfunction EventEmitter() {\n  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n    this._events = objectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nvar hasDefineProperty;\ntry {\n  var o = {};\n  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n  hasDefineProperty = o.x === 0;\n} catch (err) { hasDefineProperty = false }\nif (hasDefineProperty) {\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n      return defaultMaxListeners;\n    },\n    set: function(arg) {\n      // check whether the input is a positive number (whose value is zero or\n      // greater and not a NaN).\n      if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n        throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n      defaultMaxListeners = arg;\n    }\n  });\n} else {\n  EventEmitter.defaultMaxListeners = defaultMaxListeners;\n}\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n      // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n      // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = objectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n          listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n          prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n            existing.length + ' \"' + String(type) + '\" listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit.');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        if (typeof console === 'object' && console.warn) {\n          console.warn('%s: %s', w.name, w.message);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    switch (arguments.length) {\n      case 0:\n        return this.listener.call(this.target);\n      case 1:\n        return this.listener.call(this.target, arguments[0]);\n      case 2:\n        return this.listener.call(this.target, arguments[0], arguments[1]);\n      case 3:\n        return this.listener.call(this.target, arguments[0], arguments[1],\n            arguments[2]);\n      default:\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; ++i)\n          args[i] = arguments[i];\n        this.listener.apply(this.target, args);\n    }\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = bind.call(onceWrapper, state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = objectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = objectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = objectKeys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = objectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (!events)\n    return [];\n\n  var evlistener = events[type];\n  if (!evlistener)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction objectCreatePolyfill(proto) {\n  var F = function() {};\n  F.prototype = proto;\n  return new F;\n}\nfunction objectKeysPolyfill(obj) {\n  var keys = [];\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {\n    keys.push(k);\n  }\n  return k;\n}\nfunction functionBindPolyfill(context) {\n  var fn = this;\n  return function () {\n    return fn.apply(context, arguments);\n  };\n}\n",
    "'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n",
    "var parse = require('./parse');\n\nmodule.exports = {\n  parse: parse\n, unescapeEntities: unescapeEntities\n, isConditionalComment: isConditionalComment\n, trimLeading: trimLeading\n, trimText: trimText\n, trimTag: trimTag\n, minify: minify\n};\n\nvar replaceEntity;\nif (typeof document !== 'undefined') {\n  var entityContainer = document.createElement('div');\n  replaceEntity = function(match) {\n    // This use of innerHTML is only safe because the entity regular expression\n    // is sufficiently restrictive. Doing this with un-validated HTML would\n    // potentially introduce vulnerabilities\n    entityContainer.innerHTML = match;\n    return entityContainer.textContent || entityContainer.innerText;\n  };\n} else {\n  // Named character references from:\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/entities.json\n  //\n  // Only include this reference on the server, since it is a pretty large file,\n  // and we can use the browser's parser instead\n  var entities = module.require('./entities.json');\n  replaceEntity = function(match) {\n    var named = entities[match];\n    if (named) return named.characters;\n    if (match.charAt(1) !== '#') {\n      throw new Error('Unrecognized character reference: ' + match);\n    }\n    var charCode = (match.charAt(2) === 'x' || match.charAt(2) === 'X') ?\n      parseInt(match.slice(3, -1), 16) :\n      parseInt(match.slice(2, -1), 10);\n    return String.fromCharCode(charCode);\n  };\n}\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#character-references\nfunction unescapeEntities(html) {\n  return html.replace(/&#?[A-Za-z0-9]+;/g, replaceEntity);\n}\n\n// Assume any HTML comment that starts with `<!--[` or ends with `]-->`\n// is a conditional comment. This can also be used to keep comments in\n// minified HTML, such as `<!--[ Copyright John Doe, MIT Licensed ]-->`\nfunction isConditionalComment(tag) {\n  return /(?:^<!--\\[)|(?:\\]-->$)/.test(tag)\n}\n\n// Remove leading whitespace and newlines from a string. Whitespace at the end\n// of a line will be maintained\nfunction trimLeading(text) {\n  return text ? text.replace(/\\r?\\n\\s*/g, '') : ''\n}\n\n// Remove leading & trailing whitespace and newlines from a string\nfunction trimText(text) {\n  return text ? text.replace(/\\s*\\r?\\n\\s*/g, '') : ''\n}\n\n// Within a tag, remove leading & trailing whitespace. Keep a linebreak, since\n// this could be the separator between attributes\nfunction trimTag(tag) {\n  return tag.replace(/(?:\\s*\\r?\\n\\s*)+/g, '\\n')\n}\n\n// Remove linebreaks, leading & trailing space, and comments. Maintain a\n// linebreak between HTML tag attributes and maintain conditional comments.\nfunction minify(html) {\n  var minified = ''\n    , minifyContent = true\n\n  parse(html, {\n    start: function(tag, tagName, attrs) {\n      minifyContent = !('x-no-minify' in attrs)\n      minified += trimTag(tag)\n    }\n  , end: function(tag) {\n      minified += trimTag(tag)\n    }\n  , text: function(text) {\n      minified += minifyContent ? trimText(text) : text\n    }\n  , comment: function(tag) {\n      if (isConditionalComment(tag)) minified += tag\n    }\n  , other: function(tag) {\n      minified += tag\n    }\n  })\n  return minified\n}\n",
    "var startTag = /^<([^\\s=\\/!>]+)((?:\\s+[^\\s=\\/>]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+)?)?)*)\\s*(\\/?)\\s*>/\n  , endTag = /^<\\/([^\\s=\\/!>]+)[^>]*>/\n  , comment = /^<!--([\\s\\S]*?)-->/\n  , commentInside = /<!--[\\s\\S]*?-->/\n  , other = /^<([\\s\\S]*?)>/\n  , attr = /([^\\s=]+)(?:\\s*(=)\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+))?)?/g\n  , rawTagsDefault = /^(style|script)$/i\n\nfunction empty() {}\n\nfunction matchEndDefault(tagName) {\n  return new RegExp('</' + tagName, 'i')\n}\n\nfunction onStartTag(html, match, handler) {\n  var attrs = {}\n    , tag = match[0]\n    , tagName = match[1]\n    , remainder = match[2]\n    , selfClosing = !!match[3]\n  html = html.slice(tag.length)\n\n  remainder.replace(attr, function(match, name, equals, attr0, attr1, attr2) {\n    attrs[name] = attr0 || attr1 || attr2 || (equals ? '' : true)\n  })\n  handler(tag, tagName, attrs, selfClosing, html)\n\n  return html\n}\n\nfunction onTag(html, match, handler) {\n  var tag = match[0]\n    , data = match[1]\n  html = html.slice(tag.length)\n\n  handler(tag, data, html)\n\n  return html\n}\n\nfunction onText(html, index, isRawText, handler) {\n  var text\n  if (~index) {\n    text = html.slice(0, index)\n    html = html.slice(index)\n  } else {\n    text = html\n    html = ''\n  }\n\n  if (text) handler(text, isRawText, html)\n\n  return html\n}\n\nfunction rawEnd(html, ending, offset) {\n  offset || (offset = 0)\n  var index = html.search(ending)\n    , commentMatch = html.match(commentInside)\n    , commentEnd\n  // Make sure that the ending condition isn't inside of an HTML comment\n  if (commentMatch && commentMatch.index < index) {\n    commentEnd = commentMatch.index + commentMatch[0].length\n    offset += commentEnd\n    html = html.slice(commentEnd)\n    return rawEnd(html, ending, offset)\n  }\n  return index + offset\n}\n\nmodule.exports = function(html, options) {\n  if (options == null) options = {}\n\n  if (!html) return\n\n  var startHandler = options.start || empty\n    , endHandler = options.end || empty\n    , textHandler = options.text || empty\n    , commentHandler = options.comment || empty\n    , otherHandler = options.other || empty\n    , matchEnd = options.matchEnd || matchEndDefault\n    , errorHandler = options.error\n    , rawTags = options.rawTags || rawTagsDefault\n    , index, last, match, tagName, err\n\n  while (html) {\n    if (html === last) {\n      err = new Error('HTML parse error: ' + html)\n      if (errorHandler) {\n        errorHandler(err)\n      } else {\n        throw err\n      }\n    }\n    last = html\n\n    if (html[0] === '<') {\n      if (match = html.match(startTag)) {\n        html = onStartTag(html, match, startHandler)\n\n        tagName = match[1]\n        if (rawTags.test(tagName)) {\n          index = rawEnd(html, matchEnd(tagName))\n          html = onText(html, index, true, textHandler)\n        }\n        continue\n      }\n\n      if (match = html.match(endTag)) {\n        match[1] = match[1]  // tagName\n        html = onTag(html, match, endHandler)\n        continue\n      }\n\n      if (match = html.match(comment)) {\n        html = onTag(html, match, commentHandler)\n        continue\n      }\n\n      if (match = html.match(other)) {\n        html = onTag(html, match, otherHandler)\n        continue\n      }\n    }\n\n    index = html.indexOf('<')\n    html = onText(html, index, false, textHandler)\n  }\n}\n",
    "// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n",
    "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n",
    "/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n",
    "'use strict';\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nvar util = require('./utils');\n\nvar Format = {\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n\nmodule.exports = util.assign(\n    {\n        'default': Format.RFC3986,\n        formatters: {\n            RFC1738: function (value) {\n                return replace.call(value, percentTwenties, '+');\n            },\n            RFC3986: function (value) {\n                return String(value);\n            }\n        }\n    },\n    Format\n);\n",
    "'use strict';\n\nvar stringify = require('./stringify');\nvar parse = require('./parse');\nvar formats = require('./formats');\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n",
    "'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar defaults = {\n    allowDots: false,\n    allowPrototypes: false,\n    arrayLimit: 20,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    comma: false,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    ignoreQueryPrefix: false,\n    interpretNumericEntities: false,\n    parameterLimit: 1000,\n    parseArrays: true,\n    plainObjects: false,\n    strictNullHandling: false\n};\n\nvar interpretNumericEntities = function (str) {\n    return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n        return String.fromCharCode(parseInt(numberStr, 10));\n    });\n};\n\n// This is what browsers will submit when the  character occurs in an\n// application/x-www-form-urlencoded body and the encoding of the page containing\n// the form is iso-8859-1, or when the submitted form has an accept-charset\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n// the  character, such as us-ascii.\nvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\n\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\nvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = {};\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n    var parts = cleanStr.split(options.delimiter, limit);\n    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\n    var i;\n\n    var charset = options.charset;\n    if (options.charsetSentinel) {\n        for (i = 0; i < parts.length; ++i) {\n            if (parts[i].indexOf('utf8=') === 0) {\n                if (parts[i] === charsetSentinel) {\n                    charset = 'utf-8';\n                } else if (parts[i] === isoSentinel) {\n                    charset = 'iso-8859-1';\n                }\n                skipIndex = i;\n                i = parts.length; // The eslint settings do not allow break;\n            }\n        }\n    }\n\n    for (i = 0; i < parts.length; ++i) {\n        if (i === skipIndex) {\n            continue;\n        }\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder, charset, 'key');\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');\n            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset, 'value');\n        }\n\n        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n            val = interpretNumericEntities(val);\n        }\n\n        if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n            val = val.split(',');\n        }\n\n        if (part.indexOf('[]=') > -1) {\n            val = isArray(val) ? [val] : val;\n        }\n\n        if (has.call(obj, key)) {\n            obj[key] = utils.combine(obj[key], val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options) {\n    var leaf = val;\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]' && options.parseArrays) {\n            obj = [].concat(leaf);\n        } else {\n            obj = options.plainObjects ? Object.create(null) : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var index = parseInt(cleanRoot, 10);\n            if (!options.parseArrays && cleanRoot === '') {\n                obj = { 0: leaf };\n            } else if (\n                !isNaN(index)\n                && root !== cleanRoot\n                && String(index) === cleanRoot\n                && index >= 0\n                && (options.parseArrays && index <= options.arrayLimit)\n            ) {\n                obj = [];\n                obj[index] = leaf;\n            } else {\n                obj[cleanRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = options.depth > 0 && brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nvar normalizeParseOptions = function normalizeParseOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\n\n    return {\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\n        // eslint-disable-next-line no-implicit-coercion, no-extra-parens\n        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,\n        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\n        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n        parseArrays: opts.parseArrays !== false,\n        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (str, opts) {\n    var options = normalizeParseOptions(opts);\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    return utils.compact(obj);\n};\n",
    "'use strict';\n\nvar utils = require('./utils');\nvar formats = require('./formats');\nvar has = Object.prototype.hasOwnProperty;\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    comma: 'comma',\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar isArray = Array.isArray;\nvar push = Array.prototype.push;\nvar pushToArray = function (arr, valueOrArray) {\n    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaultFormat = formats['default'];\nvar defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    delimiter: '&',\n    encode: true,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    format: defaultFormat,\n    formatter: formats.formatters[defaultFormat],\n    // deprecated\n    indices: false,\n    serializeDate: function serializeDate(date) {\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar isNonNullishPrimitive = function isNonNullishPrimitive(v) {\n    return typeof v === 'string'\n        || typeof v === 'number'\n        || typeof v === 'boolean'\n        || typeof v === 'symbol'\n        || typeof v === 'bigint';\n};\n\nvar stringify = function stringify(\n    object,\n    prefix,\n    generateArrayPrefix,\n    strictNullHandling,\n    skipNulls,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    formatter,\n    encodeValuesOnly,\n    charset\n) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        obj = obj.join(',');\n    }\n\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key') : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key');\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value'))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (isArray(obj)) {\n            pushToArray(values, stringify(\n                obj[key],\n                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly,\n                charset\n            ));\n        } else {\n            pushToArray(values, stringify(\n                obj[key],\n                prefix + (allowDots ? '.' + key : '[' + key + ']'),\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly,\n                charset\n            ));\n        }\n    }\n\n    return values;\n};\n\nvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    var format = formats['default'];\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formats.formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    var formatter = formats.formatters[format];\n\n    var filter = defaults.filter;\n    if (typeof opts.filter === 'function' || isArray(opts.filter)) {\n        filter = opts.filter;\n    }\n\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = normalizeStringifyOptions(opts);\n\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (opts && opts.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = opts.arrayFormat;\n    } else if (opts && 'indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (options.sort) {\n        objKeys.sort(options.sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (options.skipNulls && obj[key] === null) {\n            continue;\n        }\n        pushToArray(keys, stringify(\n            obj[key],\n            key,\n            generateArrayPrefix,\n            options.strictNullHandling,\n            options.skipNulls,\n            options.encode ? options.encoder : null,\n            options.filter,\n            options.sort,\n            options.allowDots,\n            options.serializeDate,\n            options.formatter,\n            options.encodeValuesOnly,\n            options.charset\n        ));\n    }\n\n    var joined = keys.join(options.delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        } else {\n            // encodeURIComponent('')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n",
    "'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    while (queue.length > 1) {\n        var item = queue.pop();\n        var obj = item.obj[item.prop];\n\n        if (isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n};\n\nvar arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nvar merge = function merge(target, source, options) {\n    /* eslint no-param-reassign: 0 */\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (isArray(target)) {\n            target.push(source);\n        } else if (target && typeof target === 'object') {\n            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (isArray(target) && !isArray(source)) {\n        mergeTarget = arrayToObject(target, options);\n    }\n\n    if (isArray(target) && isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                var targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                } else {\n                    target.push(item);\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nvar assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nvar decode = function (str, decoder, charset) {\n    var strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    } catch (e) {\n        return strWithoutPlus;\n    }\n};\n\nvar encode = function encode(str, defaultEncoder, charset) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = str;\n    if (typeof str === 'symbol') {\n        string = Symbol.prototype.toString.call(str);\n    } else if (typeof str !== 'string') {\n        string = String(str);\n    }\n\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D // -\n            || c === 0x2E // .\n            || c === 0x5F // _\n            || c === 0x7E // ~\n            || (c >= 0x30 && c <= 0x39) // 0-9\n            || (c >= 0x41 && c <= 0x5A) // a-z\n            || (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)]\n            + hexTable[0x80 | ((c >> 12) & 0x3F)]\n            + hexTable[0x80 | ((c >> 6) & 0x3F)]\n            + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nvar compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n\n    compactQueue(queue);\n\n    return value;\n};\n\nvar isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar isBuffer = function isBuffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\nvar combine = function combine(a, b) {\n    return [].concat(a, b);\n};\n\nmodule.exports = {\n    arrayToObject: arrayToObject,\n    assign: assign,\n    combine: combine,\n    compact: compact,\n    decode: decode,\n    encode: encode,\n    isBuffer: isBuffer,\n    isRegExp: isRegExp,\n    merge: merge\n};\n",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n",
    "'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n",
    "module.exports = Doc;\n\nfunction Doc(model, collectionName, id) {\n  this.collectionName = collectionName;\n  this.id = id;\n  this.collectionData = model && model.data[collectionName];\n}\n\nDoc.prototype.path = function(segments) {\n  var path = this.collectionName + '.' + this.id;\n  if (segments && segments.length) path += '.' + segments.join('.');\n  return path;\n};\n\nDoc.prototype._errorMessage = function(description, segments, value) {\n  return description + ' at ' + this.path(segments) + ': ' +\n    JSON.stringify(value, null, 2);\n};\n",
    "var Doc = require('./Doc');\nvar util = require('../util');\n\nmodule.exports = LocalDoc;\n\nfunction LocalDoc(model, collectionName, id, data) {\n  Doc.call(this, model, collectionName, id);\n  this.data = data;\n  this._updateCollectionData();\n}\n\nLocalDoc.prototype = new Doc();\n\nLocalDoc.prototype._updateCollectionData = function() {\n  this.collectionData[this.id] = this.data;\n};\n\nLocalDoc.prototype.create = function(value, cb) {\n  if (this.data !== undefined) {\n    var message = this._errorMessage('create on local document with data', null, this.data);\n    var err = new Error(message);\n    return cb(err);\n  }\n  this.data = value;\n  this._updateCollectionData();\n  cb();\n};\n\nLocalDoc.prototype.set = function(segments, value, cb) {\n  function set(node, key) {\n    var previous = node[key];\n    node[key] = value;\n    return previous;\n  }\n  return this._apply(segments, set, cb);\n};\n\nLocalDoc.prototype.del = function(segments, cb) {\n  // Don't do anything if the value is already undefined, since\n  // apply creates objects as it traverses, and the del method\n  // should not create anything\n  var previous = this.get(segments);\n  if (previous === undefined) {\n    cb();\n    return;\n  }\n  function del(node, key) {\n    delete node[key];\n    return previous;\n  }\n  return this._apply(segments, del, cb);\n};\n\nLocalDoc.prototype.increment = function(segments, byNumber, cb) {\n  var self = this;\n  function validate(value) {\n    if (typeof value === 'number' || value == null) return;\n    return new TypeError(self._errorMessage(\n      'increment on non-number', segments, value\n    ));\n  }\n  function increment(node, key) {\n    var value = (node[key] || 0) + byNumber;\n    node[key] = value;\n    return value;\n  }\n  return this._validatedApply(segments, validate, increment, cb);\n};\n\nLocalDoc.prototype.push = function(segments, value, cb) {\n  function push(arr) {\n    return arr.push(value);\n  }\n  return this._arrayApply(segments, push, cb);\n};\n\nLocalDoc.prototype.unshift = function(segments, value, cb) {\n  function unshift(arr) {\n    return arr.unshift(value);\n  }\n  return this._arrayApply(segments, unshift, cb);\n};\n\nLocalDoc.prototype.insert = function(segments, index, values, cb) {\n  function insert(arr) {\n    arr.splice.apply(arr, [index, 0].concat(values));\n    return arr.length;\n  }\n  return this._arrayApply(segments, insert, cb);\n};\n\nLocalDoc.prototype.pop = function(segments, cb) {\n  function pop(arr) {\n    return arr.pop();\n  }\n  return this._arrayApply(segments, pop, cb);\n};\n\nLocalDoc.prototype.shift = function(segments, cb) {\n  function shift(arr) {\n    return arr.shift();\n  }\n  return this._arrayApply(segments, shift, cb);\n};\n\nLocalDoc.prototype.remove = function(segments, index, howMany, cb) {\n  function remove(arr) {\n    return arr.splice(index, howMany);\n  }\n  return this._arrayApply(segments, remove, cb);\n};\n\nLocalDoc.prototype.move = function(segments, from, to, howMany, cb) {\n  function move(arr) {\n    // Remove from old location\n    var values = arr.splice(from, howMany);\n    // Insert in new location\n    arr.splice.apply(arr, [to, 0].concat(values));\n    return values;\n  }\n  return this._arrayApply(segments, move, cb);\n};\n\nLocalDoc.prototype.stringInsert = function(segments, index, value, cb) {\n  var self = this;\n  function validate(value) {\n    if (typeof value === 'string' || value == null) return;\n    return new TypeError(self._errorMessage(\n      'stringInsert on non-string', segments, value\n    ));\n  }\n  function stringInsert(node, key) {\n    var previous = node[key];\n    if (previous == null) {\n      node[key] = value;\n      return previous;\n    }\n    node[key] = previous.slice(0, index) + value + previous.slice(index);\n    return previous;\n  }\n  return this._validatedApply(segments, validate, stringInsert, cb);\n};\n\nLocalDoc.prototype.stringRemove = function(segments, index, howMany, cb) {\n  var self = this;\n  function validate(value) {\n    if (typeof value === 'string' || value == null) return;\n    return new TypeError(self._errorMessage(\n      'stringRemove on non-string', segments, value\n    ));\n  }\n  function stringRemove(node, key) {\n    var previous = node[key];\n    if (previous == null) return previous;\n    if (index < 0) index += previous.length;\n    node[key] = previous.slice(0, index) + previous.slice(index + howMany);\n    return previous;\n  }\n  return this._validatedApply(segments, validate, stringRemove, cb);\n};\n\nLocalDoc.prototype.get = function(segments) {\n  return util.lookup(segments, this.data);\n};\n\n/**\n * @param {Array} segments is the array representing a path\n * @param {Function} fn(node, key) applies a mutation on node[key]\n * @return {Object} returns the return value of fn(node, key)\n */\nLocalDoc.prototype._createImplied = function(segments, fn) {\n  var node = this;\n  var key = 'data';\n  var i = 0;\n  var nextKey = segments[i++];\n  while (nextKey != null) {\n    // Get or create implied object or array\n    node = node[key] || (node[key] = /^\\d+$/.test(nextKey) ? [] : {});\n    key = nextKey;\n    nextKey = segments[i++];\n  }\n  return fn(node, key);\n};\n\nLocalDoc.prototype._apply = function(segments, fn, cb) {\n  var out = this._createImplied(segments, fn);\n  this._updateCollectionData();\n  cb();\n  return out;\n};\n\nLocalDoc.prototype._validatedApply = function(segments, validate, fn, cb) {\n  var out = this._createImplied(segments, function(node, key) {\n    var err = validate(node[key]);\n    if (err) return cb(err);\n    return fn(node, key);\n  });\n  this._updateCollectionData();\n  cb();\n  return out;\n};\n\nLocalDoc.prototype._arrayApply = function(segments, fn, cb) {\n  // Lookup a pointer to the property or nested property &\n  // return the current value or create a new array\n  var arr = this._createImplied(segments, nodeCreateArray);\n\n  if (!Array.isArray(arr)) {\n    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);\n    var err = new TypeError(message);\n    return cb(err);\n  }\n  var out = fn(arr);\n  this._updateCollectionData();\n  cb();\n  return out;\n};\n\nfunction nodeCreateArray(node, key) {\n  var node = node[key] || (node[key] = []);\n  return node;\n}\n",
    "var uuid = require('uuid');\n\nModel.INITS = [];\n\nmodule.exports = Model;\n\nfunction Model(options) {\n  this.root = this;\n\n  var inits = Model.INITS;\n  if (!options) options = {};\n  this.debug = options.debug || {};\n  for (var i = 0; i < inits.length; i++) {\n    inits[i](this, options);\n  }\n}\n\nModel.prototype.id = function() {\n  return uuid.v4();\n};\n\nModel.prototype._child = function() {\n  return new ChildModel(this);\n};\n\nModel.ChildModel = ChildModel;\n\nfunction ChildModel(model) {\n  // Shared properties should be accessed via the root. This makes inheritance\n  // cheap and easily extensible\n  this.root = model.root;\n\n  // EventEmitter methods access these properties directly, so they must be\n  // inherited manually instead of via the root\n  this._events = model._events;\n  this._maxListeners = model._maxListeners;\n\n  // Properties specific to a child instance\n  this._context = model._context;\n  this._at = model._at;\n  this._pass = model._pass;\n  this._silent = model._silent;\n  this._eventContext = model._eventContext;\n  this._preventCompose = model._preventCompose;\n}\nChildModel.prototype = new Model();\n",
    "module.exports = require('./Model');\n\nrequire('./events');\nrequire('./paths');\nrequire('./collections');\nrequire('./mutators');\nrequire('./setDiff');\n\nrequire('./fn');\nrequire('./filter');\nrequire('./refList');\nrequire('./ref');\n",
    "var Model = require('./Model');\nvar LocalDoc = require('./LocalDoc');\nvar util = require('../util');\n\nfunction CollectionMap() {}\nfunction ModelData() {}\nfunction DocMap() {}\nfunction CollectionData() {}\n\nModel.INITS.push(function(model) {\n  model.root.collections = new CollectionMap();\n  model.root.data = new ModelData();\n});\n\nModel.prototype.getCollection = function(collectionName) {\n  return this.root.collections[collectionName];\n};\nModel.prototype.getDoc = function(collectionName, id) {\n  var collection = this.root.collections[collectionName];\n  return collection && collection.docs[id];\n};\nModel.prototype.get = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._get(segments);\n};\nModel.prototype._get = function(segments) {\n  return util.lookup(segments, this.root.data);\n};\nModel.prototype.getCopy = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._getCopy(segments);\n};\nModel.prototype._getCopy = function(segments) {\n  var value = this._get(segments);\n  return util.copy(value);\n};\nModel.prototype.getDeepCopy = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._getDeepCopy(segments);\n};\nModel.prototype._getDeepCopy = function(segments) {\n  var value = this._get(segments);\n  return util.deepCopy(value);\n};\nModel.prototype.getOrCreateCollection = function(name) {\n  var collection = this.root.collections[name];\n  if (collection) return collection;\n  var Doc = this._getDocConstructor(name);\n  collection = new Collection(this.root, name, Doc);\n  this.root.collections[name] = collection;\n  return collection;\n};\nModel.prototype._getDocConstructor = function() {\n  // Only create local documents. This is overriden in ./connection.js, so that\n  // the RemoteDoc behavior can be selectively included\n  return LocalDoc;\n};\n\n/**\n * Returns an existing document with id in a collection. If the document does\n * not exist, then creates the document with id in a collection and returns the\n * new document.\n * @param {String} collectionName\n * @param {String} id\n * @param {Object} [data] data to create if doc with id does not exist in collection\n */\nModel.prototype.getOrCreateDoc = function(collectionName, id, data) {\n  var collection = this.getOrCreateCollection(collectionName);\n  return collection.docs[id] || collection.add(id, data);\n};\n\n/**\n * @param {String} subpath\n */\nModel.prototype.destroy = function(subpath) {\n  var segments = this._splitPath(subpath);\n  // Silently remove all types of listeners within subpath\n  var silentModel = this.silent();\n  silentModel.removeAllListeners(null, subpath);\n  silentModel._removeAllRefs(segments);\n  silentModel._stopAll(segments);\n  silentModel._removeAllFilters(segments);\n  // Silently remove all model data within subpath\n  if (segments.length === 0) {\n    this.root.collections = new CollectionMap();\n    // Delete each property of data instead of creating a new object so that\n    // it is possible to continue using a reference to the original data object\n    var data = this.root.data;\n    for (var key in data) {\n      delete data[key];\n    }\n  } else if (segments.length === 1) {\n    var collection = this.getCollection(segments[0]);\n    collection && collection.destroy();\n  } else {\n    silentModel._del(segments);\n  }\n};\n\nfunction Collection(model, name, Doc) {\n  this.model = model;\n  this.name = name;\n  this.Doc = Doc;\n  this.docs = new DocMap();\n  this.data = model.data[name] = new CollectionData();\n}\n\n/**\n * Adds a document with `id` and `data` to `this` Collection.\n * @param {String} id\n * @param {Object} data\n * @return {LocalDoc|RemoteDoc} doc\n */\nCollection.prototype.add = function(id, data) {\n  var doc = new this.Doc(this.model, this.name, id, data, this);\n  this.docs[id] = doc;\n  return doc;\n};\nCollection.prototype.destroy = function() {\n  delete this.model.collections[this.name];\n  delete this.model.data[this.name];\n};\n\n/**\n * Removes the document with `id` from `this` Collection. If there are no more\n * documents in the Collection after the given document is removed, then this\n * also destroys the Collection.\n * @param {String} id\n */\nCollection.prototype.remove = function(id) {\n  delete this.docs[id];\n  delete this.data[id];\n  if (noKeys(this.docs)) this.destroy();\n};\n\n/**\n * Returns an object that maps doc ids to fully resolved documents.\n * @return {Object}\n */\nCollection.prototype.get = function() {\n  return this.data;\n};\n\nfunction noKeys(object) {\n  // eslint-disable-next-line no-unused-vars\n  for (var key in object) {\n    return false;\n  }\n  return true;\n}\n",
    "var defaultFns = module.exports = new DefaultFns();\n\ndefaultFns.reverse = new FnPair(getReverse, setReverse);\ndefaultFns.asc = asc;\ndefaultFns.desc = desc;\n\nfunction DefaultFns() {}\nfunction FnPair(get, set) {\n  this.get = get;\n  this.set = set;\n}\n\nfunction getReverse(array) {\n  return array && array.slice().reverse();\n}\nfunction setReverse(values) {\n  return {0: getReverse(values)};\n}\n\nfunction asc(a, b) {\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n}\nfunction desc(a, b) {\n  if (a > b) return -1;\n  if (a < b) return 1;\n  return 0;\n}\n",
    "// @ts-check\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('../util');\n/** @type any */\nvar Model = require('./Model');\n\n// These events are re-emitted as 'all' events, and they are queued up and\n// emitted in sequence, so that events generated by other events are not\n// seen in a different order by later listeners\nModel.MUTATOR_EVENTS = {\n  change: true,\n  insert: true,\n  remove: true,\n  move: true,\n  load: true,\n  unload: true\n};\n\nModel.INITS.push(function(model) {\n  EventEmitter.call(this);\n\n  // Set max listeners to unlimited\n  model.setMaxListeners(0);\n\n  // Used in async methods to emit an error event if a callback is not supplied.\n  // This will throw if there is no handler for model.on('error')\n  model.root._defaultCallback = defaultCallback;\n  function defaultCallback(err) {\n    if (err) model._emitError(err);\n  }\n\n  model.root._mutatorEventQueue = null;\n  model.root._pass = new Passed({}, {});\n  model.root._silent = null;\n  model.root._eventContext = null;\n});\n\nutil.mergeInto(Model.prototype, EventEmitter.prototype);\n\nModel.prototype.wrapCallback = function(cb) {\n  if (!cb) return this.root._defaultCallback;\n  var model = this;\n  return function wrappedCallback() {\n    try {\n      return cb.apply(this, arguments);\n    } catch (err) {\n      model._emitError(err);\n    }\n  };\n};\n\nModel.prototype._emitError = function(err, context) {\n  var message = (err.message) ? err.message :\n    (typeof err === 'string') ? err :\n      'Unknown model error';\n  if (context) {\n    message += ' ' + context;\n  }\n  if (err.data) {\n    try {\n      message += ' ' + JSON.stringify(err.data);\n    } catch (stringifyErr) {}\n  }\n  if (err instanceof Error) {\n    err.message = message;\n  } else {\n    err = new Error(message);\n  }\n  this.emit('error', err);\n};\n\n// EventEmitter.prototype.on, EventEmitter.prototype.addListener, and\n// EventEmitter.prototype.once return `this`. The Model equivalents return\n// the listener instead, since it is made internally for method subscriptions\n// and may need to be passed to removeListener.\n\nModel.prototype._emit = EventEmitter.prototype.emit;\nModel.prototype.emit = function(type) {\n  if (type === 'error') {\n    return this._emit.apply(this, arguments);\n  }\n  if (Model.MUTATOR_EVENTS[type]) {\n    if (this._silent) return this;\n    // `segments` is almost definitely an array of strings.\n    //\n    // A search for `.emit(` shows that `segments` is generated from either\n    // `Model#_splitPath` or `Model#_dereference`, both of which return an array\n    // of strings.\n    var segments = arguments[1];\n    var eventArgs = arguments[2];\n    this._emit(type + 'Immediate', segments, eventArgs);\n    if (this.root._mutatorEventQueue) {\n      this.root._mutatorEventQueue.push([type, segments, eventArgs]);\n      return this;\n    }\n    this.root._mutatorEventQueue = [];\n    this._emit(type, segments, eventArgs);\n    this._emit('all', segments, [type].concat(eventArgs));\n    while (this.root._mutatorEventQueue.length) {\n      var queued = this.root._mutatorEventQueue.shift();\n      type = queued[0];\n      segments = queued[1];\n      eventArgs = queued[2];\n      this._emit(type, segments, eventArgs);\n      this._emit('all', segments, [type].concat(eventArgs));\n    }\n    this.root._mutatorEventQueue = null;\n    return this;\n  }\n  return this._emit.apply(this, arguments);\n};\n\nModel.prototype._on = EventEmitter.prototype.on;\nModel.prototype.addListener =\nModel.prototype.on = function(type, pattern, options, cb) {\n  var listener = eventListener(this, type, pattern, options, cb);\n  this._on(type, listener);\n  return listener;\n};\n\nModel.prototype.once = function(type, pattern, options, cb) {\n  var listener = eventListener(this, type, pattern, options, cb);\n  function g() {\n    var matches = listener.apply(null, arguments);\n    if (matches) this.removeListener(type, g);\n  }\n  this._on(type, g);\n  return g;\n};\n\n/**\n * @typedef {Object} ModelOnOptions\n * @property {boolean} [useEventObjects] - If true, the listener is called with\n *   `cb(event: ___Event, captures: string[])`, instead of the legacy var-args\n *   style `cb(captures..., [eventType], eventArgs..., passed)`.\n */\n\nModel.prototype._removeAllListeners = EventEmitter.prototype.removeAllListeners;\nModel.prototype.removeAllListeners = function(type, subpattern) {\n  // If a pattern is specified without an event type, remove all model event\n  // listeners under that pattern for all events\n  if (!type) {\n    for (var key in this._events) {\n      this.removeAllListeners(key, subpattern);\n    }\n    return this;\n  }\n\n  var pattern = this.path(subpattern);\n  // If no pattern is specified, remove all listeners like normal\n  if (!pattern) {\n    if (arguments.length === 0) {\n      return this._removeAllListeners();\n    }\n    return this._removeAllListeners(type);\n  }\n\n  // Remove all listeners for an event under a pattern\n  var listeners = this.listeners(type);\n  var segments = pattern.split('.');\n  // Make sure to iterate in reverse, since the array might be\n  // mutated as listeners are removed\n  for (var i = listeners.length; i--;) {\n    var listener = listeners[i];\n    if (patternContained(pattern, segments, listener)) {\n      this.removeListener(type, listener);\n    }\n  }\n  return this;\n};\n\nfunction patternContained(pattern, segments, listener) {\n  var listenerSegments = listener.patternSegments;\n  if (!listenerSegments) return false;\n  if (pattern === listener.pattern || pattern === '**') return true;\n  var len = segments.length;\n  if (len > listenerSegments.length) return false;\n  for (var i = 0; i < len; i++) {\n    if (segments[i] !== listenerSegments[i]) return false;\n  }\n  return true;\n}\n\nModel.prototype.pass = function(object, invert) {\n  var model = this._child();\n  model._pass = (invert) ?\n    new Passed(object, this._pass) :\n    new Passed(this._pass, object);\n  return model;\n};\n\nfunction Passed(previous, value) {\n  for (var key in previous) {\n    this[key] = previous[key];\n  }\n  for (var key in value) {\n    this[key] = value[key];\n  }\n}\n\n/**\n * The returned Model will or won't trigger event handlers when the model emits\n * events, depending on `value`\n * @param {Boolean|Null} value defaults to true\n * @return {Model}\n */\nModel.prototype.silent = function(value) {\n  var model = this._child();\n  model._silent = (value == null) ? true : value;\n  return model;\n};\n\nModel.prototype.eventContext = function(value) {\n  var model = this._child();\n  model._eventContext = value;\n  return model;\n};\n\nModel.prototype.removeContextListeners = function(value) {\n  if (arguments.length === 0) {\n    value = this._eventContext;\n  }\n  // Remove all events created within a given context\n  for (var type in this._events) {\n    var listeners = this.listeners(type);\n    // Make sure to iterate in reverse, since the array might be\n    // mutated as listeners are removed\n    for (var i = listeners.length; i--;) {\n      var listener = listeners[i];\n      if (listener.eventContext === value) {\n        this.removeListener(type, listener);\n      }\n    }\n  }\n  return this;\n};\n\n/**\n * @param {Model} model\n * @param {string} eventType\n */\nfunction eventListener(model, eventType, arg2, arg3, arg4) {\n  var subpattern, options, cb;\n  if (arg4) {\n    // on(eventType, path, options, cb)\n    subpattern = arg2;\n    options = arg3;\n    cb = arg4;\n  } else if (arg3) {\n    // on(eventType, path, cb)\n    // on(eventType, options, cb)\n    cb = arg3;\n    if (model.isPath(arg2)) {\n      subpattern = arg2;\n    } else {\n      options = arg2;\n    }\n  } else { // if (arg2)\n    // on(eventType, cb)\n    cb = arg2;\n  }\n  if (options) {\n    if (options.useEventObjects) {\n      var useEventObjects = true;\n    }\n  }\n\n  if (subpattern) {\n    // For signatures with pattern:\n    // model.on('change', 'example.subpath.**', callback)\n    // model.at('example').on('change', 'subpath', callback)\n    var pattern = model.path(subpattern);\n    return (useEventObjects) ?\n      modelEventListener(eventType, pattern, cb, model._eventContext) :\n      modelEventListenerLegacy(pattern, cb, model._eventContext);\n  }\n  // For signature without explicit pattern:\n  // model.at('example').on('change', callback)\n  /** @type string */\n  var path = model.path();\n  if (path) {\n    return (useEventObjects) ?\n      modelEventListener(eventType, path, cb, model._eventContext) :\n      modelEventListenerLegacy(path, cb, model._eventContext);\n  }\n  // For signature:\n  // model.on('normalEvent', callback)\n  return cb;\n}\n\n/**\n * Legacy version of `modelEventListener` that calls `cb` with var-args\n * `(captures..., [eventType], args..., passed)` instead of new-style\n * `___Event` objects.\n *\n * @param {string} pattern\n * @param {Function} cb\n * @param {*} eventContext\n * @return {ModelListenerFn & ModelListenerProps}\n */\nfunction modelEventListenerLegacy(pattern, cb, eventContext) {\n  var patternSegments = util.castSegments(pattern.split('.'));\n  var testFn = testPatternFn(pattern, patternSegments);\n\n  /** @type ModelListenerFn */\n  function modelListener(segments, eventArgs) {\n    var captures = testFn(segments);\n    if (!captures) return;\n\n    var args = (captures.length) ? captures.concat(eventArgs) : eventArgs;\n    cb.apply(null, args);\n    return true;\n  }\n\n  // Used in Model#removeAllListeners\n  modelListener.pattern = pattern;\n  modelListener.patternSegments = patternSegments;\n  modelListener.eventContext = eventContext;\n\n  return modelListener;\n}\n\n/**\n * Returns a function that can be passed to `EventEmitter#on`, with some\n * additional properties used for `Model#removeAllListeners`.\n *\n * When the function is called, it checks if the event matches `patternArg`, and\n * if there's a match, it calls `cb`.\n *\n * @param {string} eventType\n * @param {string} pattern\n * @param {Function} cb\n * @param {*} eventContext\n * @return {ModelListenerFn & ModelListenerProps}\n */\nfunction modelEventListener(eventType, pattern, cb, eventContext) {\n  var patternSegments = util.castSegments(pattern.split('.'));\n  var testFn = testPatternFn(pattern, patternSegments);\n\n  var eventFactory = getEventFactory(eventType);\n  /** @type ModelListenerFn */\n  function modelListener(segments, eventArgs) {\n    var captures = testFn(segments);\n    if (!captures) return;\n\n    var event = eventFactory(eventArgs);\n    cb(event, captures);\n    return true;\n  }\n\n  // Used in Model#removeAllListeners\n  modelListener.pattern = pattern;\n  modelListener.patternSegments = patternSegments;\n  modelListener.eventContext = eventContext;\n\n  return modelListener;\n}\n\n/** @typedef { (segments: string[], eventArgs: any[]) => (boolean | undefined) } ModelListenerFn */\n/** @typedef { {pattern: string, patternSegments: Array<string | number>, eventContext: any} } ModelListenerProps */\n\n/**\n * Returns a factory function that creates an `___Event` object based on an\n * old-style `eventArgs` array.\n *\n * @param {string} eventType\n * @return {(eventArgs: any[]) => ChangeEvent | InsertEvent | RemoveEvent | MoveEvent | LoadEvent | UnloadEvent}\n */\nfunction getEventFactory(eventType) {\n  switch (eventType) {\n    case 'change':\n      return function(eventArgs) {\n        return new ChangeEvent(eventArgs);\n      };\n    case 'insert':\n      return function(eventArgs) {\n        return new InsertEvent(eventArgs);\n      };\n    case 'remove':\n      return function(eventArgs) {\n        return new RemoveEvent(eventArgs);\n      };\n    case 'move':\n      return function(eventArgs) {\n        return new MoveEvent(eventArgs);\n      };\n    case 'load':\n      return function(eventArgs) {\n        return new LoadEvent(eventArgs);\n      };\n    case 'unload':\n      return function(eventArgs) {\n        return new UnloadEvent(eventArgs);\n      };\n    case 'all':\n      return function(eventArgs) {\n        var concreteEventType = eventArgs[0]; // 'change', 'insert', etc.\n        var concreteEventFactory = getEventFactory(concreteEventType);\n        return concreteEventFactory(eventArgs.slice(1));\n      };\n    default: throw new Error('Unknown event: ' + eventType);\n  }\n}\n\n// These constructors accept the `eventArgs` array format that Racer uses\n// internally when calling `Model#emit`.\n//\n// Eventually, Racer should switch to passing these events around directly,\n// but that will require updating all the places that parse the `eventArgs`\n// array format, to extract things like `passed`.\n\nfunction ChangeEvent(eventArgs) {\n  this.value = eventArgs[0];\n  this.previous = eventArgs[1];\n  this.passed = eventArgs[2];\n}\nChangeEvent.prototype.type = 'change';\n\nfunction InsertEvent(eventArgs) {\n  this.index = eventArgs[0];\n  this.values = eventArgs[1];\n  this.passed = eventArgs[2];\n}\nInsertEvent.prototype.type = 'insert';\n\nfunction RemoveEvent(eventArgs) {\n  this.index = eventArgs[0];\n  this.removed = eventArgs[1];\n  this.passed = eventArgs[2];\n}\nRemoveEvent.prototype.type = 'remove';\n\nfunction MoveEvent(eventArgs) {\n  this.from = eventArgs[0];\n  this.to = eventArgs[1];\n  this.howMany = eventArgs[2];\n  this.passed = eventArgs[3];\n}\nMoveEvent.prototype.type = 'move';\n\nfunction LoadEvent(eventArgs) {\n  this.document = eventArgs[0];\n  this.passed = eventArgs[1];\n}\nLoadEvent.prototype.type = 'load';\n\nfunction UnloadEvent(eventArgs) {\n  this.previousDocument = eventArgs[0];\n  this.passed = eventArgs[1];\n}\nUnloadEvent.prototype.type = 'unload';\n\n/**\n * Returns a function that tests an array of event segments against the\n * `patternSegments`. (`pattern` only matters if it's exactly `'**'`.)\n *\n * @param {string?} pattern\n * @param {Array<string | number>} patternSegments\n * @return {(segments: string[]) => (string[] | undefined)} A function to test\n *   an array of event segments. If the event segments match, an array of 0 or\n *   more segments captured by `'*'` / `'**'` is returned, one per wildcard. If\n *   the event segments don't match, `undefined` is returned.\n */\nfunction testPatternFn(pattern, patternSegments) {\n  if (pattern === '**') {\n    return function testPattern(segments) {\n      return [segments.join('.')];\n    };\n  }\n\n  var endingRest = stripRestWildcard(patternSegments);\n\n  return function testPattern(segments) {\n    // Any pattern with more segments does not match\n    var patternLen = patternSegments.length;\n    if (patternLen > segments.length) return;\n\n    // A pattern with the same number of segments matches if each\n    // of the segments are wildcards or equal. A shorter pattern matches\n    // if it ends in a rest wildcard and each of the corresponding\n    // segments are wildcards or equal.\n    if (patternLen === segments.length || endingRest) {\n      /** @type string[] */\n      var captures = [];\n      for (var i = 0; i < patternLen; i++) {\n        var patternSegment = patternSegments[i];\n        var segment = segments[i];\n        if (patternSegment === '*' || patternSegment === '**') {\n          captures.push(segment);\n          continue;\n        }\n        if (patternSegment !== segment) return;\n      }\n      if (endingRest) {\n        var remainder = segments.slice(i).join('.');\n        captures.push(remainder);\n      }\n      return captures;\n    }\n  };\n}\n\n/**\n * @param {Array<string | number>} segments\n */\nfunction stripRestWildcard(segments) {\n  // ['example', '**'] -> ['example']; return true\n  var lastIndex = segments.length - 1;\n  var lastSegment = segments[lastIndex];\n  if (lastSegment === '**') {\n    segments.pop();\n    return true;\n  }\n  // ['example', 'subpath**'] -> ['example', 'subpath']; return true\n  if (typeof lastSegment !== 'string') return false;\n  var match = /^([^\\*]+)\\*\\*$/.exec(lastSegment);\n  if (!match) return false;\n  segments[lastIndex] = match[1];\n  return true;\n}\n",
    "var util = require('../util');\nvar Model = require('./Model');\nvar defaultFns = require('./defaultFns');\n\nModel.INITS.push(function(model) {\n  model.root._filters = new Filters(model);\n  model.on('all', filterListener);\n  function filterListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    var map = model.root._filters.fromMap;\n    for (var path in map) {\n      var filter = map[path];\n      if (pass.$filter === filter) continue;\n      if (\n        util.mayImpact(filter.segments, segments) ||\n        (filter.inputsSegments && util.mayImpactAny(filter.inputsSegments, segments))\n      ) {\n        filter.update(pass);\n      }\n    }\n  }\n});\n\nfunction parseFilterArguments(model, args) {\n  var fn = args.pop();\n  var options;\n  if (!model.isPath(args[args.length - 1])) {\n    options = args.pop();\n  }\n  var path = model.path(args.shift());\n  var i = args.length;\n  while (i--) {\n    args[i] = model.path(args[i]);\n  }\n  return {\n    path: path,\n    inputPaths: (args.length) ? args : null,\n    options: options,\n    fn: fn\n  };\n}\n\nModel.prototype.filter = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseFilterArguments(this, args);\n  return this.root._filters.add(\n    parsed.path,\n    parsed.fn,\n    null,\n    parsed.inputPaths,\n    parsed.options\n  );\n};\n\nModel.prototype.sort = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseFilterArguments(this, args);\n  return this.root._filters.add(\n    parsed.path,\n    null,\n    parsed.fn || 'asc',\n    parsed.inputPaths,\n    parsed.options\n  );\n};\n\nModel.prototype.removeAllFilters = function(subpath) {\n  var segments = this._splitPath(subpath);\n  this._removeAllFilters(segments);\n};\nModel.prototype._removeAllFilters = function(segments) {\n  var filters = this.root._filters.fromMap;\n  for (var from in filters) {\n    if (util.contains(segments, filters[from].fromSegments)) {\n      filters[from].destroy();\n    }\n  }\n};\n\nfunction FromMap() {}\nfunction Filters(model) {\n  this.model = model;\n  this.fromMap = new FromMap();\n}\n\nFilters.prototype.add = function(path, filterFn, sortFn, inputPaths, options) {\n  return new Filter(this, path, filterFn, sortFn, inputPaths, options);\n};\n\nFilters.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var filter = this.fromMap[from];\n    // Don't try to bundle if functions were passed directly instead of by name\n    if (!filter.bundle) continue;\n    var args = [from, filter.path, filter.filterName, filter.sortName, filter.inputPaths];\n    if (filter.options) args.push(filter.options);\n    out.push(args);\n  }\n  return out;\n};\n\nfunction Filter(filters, path, filterFn, sortFn, inputPaths, options) {\n  this.filters = filters;\n  this.model = filters.model.pass({$filter: this});\n  this.path = path;\n  this.segments = path.split('.');\n  this.filterName = null;\n  this.sortName = null;\n  this.bundle = true;\n  this.filterFn = null;\n  this.sortFn = null;\n  this.inputPaths = inputPaths;\n  this.inputsSegments = null;\n  if (inputPaths) {\n    this.inputsSegments = [];\n    for (var i = 0; i < this.inputPaths.length; i++) {\n      var segments = this.inputPaths[i].split('.');\n      this.inputsSegments.push(segments);\n    }\n  }\n  this.options = options;\n  this.skip = options && options.skip;\n  this.limit = options && options.limit;\n  if (filterFn) this.filter(filterFn);\n  if (sortFn) this.sort(sortFn);\n  this.idsSegments = null;\n  this.from = null;\n  this.fromSegments = null;\n}\n\nFilter.prototype.filter = function(fn) {\n  if (typeof fn === 'function') {\n    this.filterFn = fn;\n    this.bundle = false;\n    return this;\n  } else if (typeof fn === 'string') {\n    this.filterName = fn;\n    this.filterFn = this.model.root._namedFns[fn] || defaultFns[fn];\n    if (!this.filterFn) {\n      throw new TypeError('Filter function not found: ' + fn);\n    }\n  }\n  return this;\n};\n\nFilter.prototype.sort = function(fn) {\n  if (!fn) fn = 'asc';\n  if (typeof fn === 'function') {\n    this.sortFn = fn;\n    this.bundle = false;\n    return this;\n  } else if (typeof fn === 'string') {\n    this.sortName = fn;\n    this.sortFn = this.model.root._namedFns[fn] || defaultFns[fn];\n    if (!this.sortFn) {\n      throw new TypeError('Sort function not found: ' + fn);\n    }\n  }\n  return this;\n};\n\nFilter.prototype._slice = function(results) {\n  if (this.skip == null && this.limit == null) return results;\n  var begin = this.skip || 0;\n  // A limit of zero is equivalent to setting no limit\n  var end;\n  if (this.limit) end = begin + this.limit;\n  return results.slice(begin, end);\n};\n\nFilter.prototype.getInputs = function() {\n  if (!this.inputsSegments) return;\n  var inputs = [];\n  for (var i = 0, len = this.inputsSegments.length; i < len; i++) {\n    var input = this.model._get(this.inputsSegments[i]);\n    inputs.push(input);\n  }\n  return inputs;\n};\n\nFilter.prototype.callFilter = function(items, key, inputs) {\n  var item = items[key];\n  return (inputs) ?\n    this.filterFn.apply(this.model, [item, key, items].concat(inputs)) :\n    this.filterFn.call(this.model, item, key, items);\n};\n\nFilter.prototype.ids = function() {\n  var items = this.model._get(this.segments);\n  var ids = [];\n  if (!items) return ids;\n  if (Array.isArray(items)) {\n    throw new Error('model.filter is not currently supported on arrays');\n  }\n  if (this.filterFn) {\n    var inputs = this.getInputs();\n    for (var key in items) {\n      if (items.hasOwnProperty(key) && this.callFilter(items, key, inputs)) {\n        ids.push(key);\n      }\n    }\n  } else {\n    ids = Object.keys(items);\n  }\n  var sortFn = this.sortFn;\n  if (sortFn) {\n    ids.sort(function(a, b) {\n      return sortFn(items[a], items[b]);\n    });\n  }\n  return this._slice(ids);\n};\n\nFilter.prototype.get = function() {\n  var items = this.model._get(this.segments);\n  var results = [];\n  if (Array.isArray(items)) {\n    throw new Error('model.filter is not currently supported on arrays');\n  }\n  if (this.filterFn) {\n    var inputs = this.getInputs();\n    for (var key in items) {\n      if (items.hasOwnProperty(key) && this.callFilter(items, key, inputs)) {\n        results.push(items[key]);\n      }\n    }\n  } else {\n    for (var key in items) {\n      if (items.hasOwnProperty(key)) {\n        results.push(items[key]);\n      }\n    }\n  }\n  if (this.sortFn) results.sort(this.sortFn);\n  return this._slice(results);\n};\n\nFilter.prototype.update = function(pass) {\n  var ids = this.ids();\n  this.model.pass(pass, true)._setArrayDiff(this.idsSegments, ids);\n};\n\nFilter.prototype.ref = function(from) {\n  from = this.model.path(from);\n  this.from = from;\n  this.fromSegments = from.split('.');\n  this.filters.fromMap[from] = this;\n  this.idsSegments = ['$filters', from.replace(/\\./g, '|')];\n  this.update();\n  return this.model.refList(from, this.path, this.idsSegments.join('.'));\n};\n\nFilter.prototype.destroy = function() {\n  delete this.filters.fromMap[this.from];\n  this.model._removeRef(this.idsSegments);\n  this.model._del(this.idsSegments);\n};\n",
    "var util = require('../util');\nvar Model = require('./Model');\nvar defaultFns = require('./defaultFns');\n\nfunction NamedFns() {}\n\nModel.INITS.push(function(model) {\n  model.root._namedFns = new NamedFns();\n  model.root._fns = new Fns(model);\n  model.on('all', fnListener);\n  function fnListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    var map = model.root._fns.fromMap;\n    for (var path in map) {\n      var fn = map[path];\n      if (pass.$fn === fn) continue;\n      if (util.mayImpactAny(fn.inputsSegments, segments)) {\n        // Mutation affecting input path\n        fn.onInput(pass);\n      } else if (util.mayImpact(fn.fromSegments, segments)) {\n        // Mutation affecting output path\n        fn.onOutput(pass);\n      }\n    }\n  }\n});\n\nModel.prototype.fn = function(name, fns) {\n  this.root._namedFns[name] = fns;\n};\n\nfunction parseStartArguments(model, args, hasPath) {\n  var last = args.pop();\n  var fns, name;\n  if (typeof last === 'string') {\n    name = last;\n  } else {\n    fns = last;\n  }\n  // For `Model#start`, the first parameter is the output path.\n  var path;\n  if (hasPath) {\n    path = model.path(args.shift());\n  }\n  // The second-to-last original argument could be an options object.\n  // If it's not an array and not path-like, then it's an options object.\n  last = args[args.length - 1];\n  var options;\n  if (!Array.isArray(last) && !model.isPath(last)) {\n    options = args.pop();\n  }\n\n  // `args` is just the input paths at this point.\n  var inputs;\n  if (args.length === 1 && Array.isArray(args[0])) {\n    // Inputs provided as one array:\n    //   model.start(outPath, [inPath1, inPath2], fn);\n    inputs = args[0];\n  } else {\n    // Inputs provided as var-args:\n    //   model.start(outPath, inPath1, inPath2, fn);\n    inputs = args;\n  }\n\n  // Normalize each input into a string path.\n  var i = inputs.length;\n  while (i--) {\n    inputs[i] = model.path(inputs[i]);\n  }\n  return {\n    name: name,\n    path: path,\n    inputPaths: inputs,\n    fns: fns,\n    options: options\n  };\n}\n\nModel.prototype.evaluate = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseStartArguments(this, args, false);\n  return this.root._fns.get(parsed.name, parsed.inputPaths, parsed.fns, parsed.options);\n};\n\nModel.prototype.start = function() {\n  var args = Array.prototype.slice.call(arguments);\n  var parsed = parseStartArguments(this, args, true);\n  return this.root._fns.start(parsed.name, parsed.path, parsed.inputPaths, parsed.fns, parsed.options);\n};\n\nModel.prototype.stop = function(subpath) {\n  var path = this.path(subpath);\n  this._stop(path);\n};\nModel.prototype._stop = function(fromPath) {\n  this.root._fns.stop(fromPath);\n};\n\nModel.prototype.stopAll = function(subpath) {\n  var segments = this._splitPath(subpath);\n  this._stopAll(segments);\n};\nModel.prototype._stopAll = function(segments) {\n  var fns = this.root._fns.fromMap;\n  for (var from in fns) {\n    var fromSegments = fns[from].fromSegments;\n    if (util.contains(segments, fromSegments)) {\n      this._stop(from);\n    }\n  }\n};\n\nfunction FromMap() {}\nfunction Fns(model) {\n  this.model = model;\n  this.nameMap = model.root._namedFns;\n  this.fromMap = new FromMap();\n}\n\nFns.prototype.get = function(name, inputPaths, fns, options) {\n  fns || (fns = this.nameMap[name] || defaultFns[name]);\n  var fn = new Fn(this.model, name, null, inputPaths, fns, options);\n  return fn.get();\n};\n\nFns.prototype.start = function(name, path, inputPaths, fns, options) {\n  fns || (fns = this.nameMap[name] || defaultFns[name]);\n  var fn = new Fn(this.model, name, path, inputPaths, fns, options);\n  this.fromMap[path] = fn;\n  return fn._onInput();\n};\n\nFns.prototype.stop = function(path) {\n  var fn = this.fromMap[path];\n  delete this.fromMap[path];\n  return fn;\n};\n\nFns.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var fn = this.fromMap[from];\n    // Don't try to bundle non-named functions that were started via\n    // model.start directly instead of by name\n    if (!fn.name) continue;\n    var args = [fn.from].concat(fn.inputPaths);\n    if (fn.options) args.push(fn.options);\n    args.push(fn.name);\n    out.push(args);\n  }\n  return out;\n};\n\nfunction Fn(model, name, from, inputPaths, fns, options) {\n  this.model = model.pass({$fn: this});\n  this.name = name;\n  this.from = from;\n  this.inputPaths = inputPaths;\n  this.options = options;\n  if (!fns) {\n    throw new TypeError('Model function not found: ' + name);\n  }\n  this.getFn = fns.get || fns;\n  this.setFn = fns.set;\n  this.fromSegments = from && from.split('.');\n  this.inputsSegments = [];\n  for (var i = 0; i < this.inputPaths.length; i++) {\n    var segments = this.inputPaths[i].split('.');\n    this.inputsSegments.push(segments);\n  }\n\n  // Copy can be 'output', 'input', 'both', or 'none'\n  var copy = (options && options.copy) || 'output';\n  this.copyInput = (copy === 'input' || copy === 'both');\n  this.copyOutput = (copy === 'output' || copy === 'both');\n\n  // Mode can be 'diffDeep', 'diff', 'arrayDeep', or 'array'\n  this.mode = (options && options.mode) || 'diffDeep';\n\n  this.async = !!(options && options.async);\n  this.eventPending = false;\n}\n\nFn.prototype.apply = function(fn, inputs) {\n  for (var i = 0, len = this.inputsSegments.length; i < len; i++) {\n    var input = this.model._get(this.inputsSegments[i]);\n    inputs.push(this.copyInput ? util.deepCopy(input) : input);\n  }\n  return fn.apply(this.model, inputs);\n};\n\nFn.prototype.get = function() {\n  return this.apply(this.getFn, []);\n};\n\nFn.prototype.set = function(value, pass) {\n  if (!this.setFn) return;\n  var out = this.apply(this.setFn, [value]);\n  if (!out) return;\n  var inputsSegments = this.inputsSegments;\n  var model = this.model.pass(pass, true);\n  for (var key in out) {\n    var value = (this.copyOutput) ? util.deepCopy(out[key]) : out[key];\n    this._setValue(model, inputsSegments[key], value);\n  }\n};\n\nFn.prototype.onInput = function(pass) {\n  if (this.async) {\n    if (this.eventPending) return;\n    this.eventPending = true;\n    var fn = this;\n    process.nextTick(function() {\n      fn._onInput(pass);\n      fn.eventPending = false;\n    });\n    return;\n  }\n  return this._onInput(pass);\n};\n\nFn.prototype._onInput = function(pass) {\n  var value = (this.copyOutput) ? util.deepCopy(this.get()) : this.get();\n  this._setValue(this.model.pass(pass, true), this.fromSegments, value);\n  return value;\n};\n\nFn.prototype.onOutput = function(pass) {\n  var value = this.model._get(this.fromSegments);\n  return this.set(value, pass);\n};\n\nFn.prototype._setValue = function(model, segments, value) {\n  if (this.mode === 'diffDeep') {\n    model._setDiffDeep(segments, value);\n  } else if (this.mode === 'arrayDeep') {\n    model._setArrayDiffDeep(segments, value);\n  } else if (this.mode === 'array') {\n    model._setArrayDiff(segments, value);\n  } else {\n    model._setDiff(segments, value);\n  }\n};\n",
    "var util = require('../util');\nvar Model = require('./Model');\n\nModel.prototype._mutate = function(segments, fn, cb) {\n  cb = this.wrapCallback(cb);\n  var collectionName = segments[0];\n  var id = segments[1];\n  if (!collectionName || !id) {\n    var message = fn.name + ' must be performed under a collection ' +\n      'and document id. Invalid path: ' + segments.join('.');\n    return cb(new Error(message));\n  }\n  var doc = this.getOrCreateDoc(collectionName, id);\n  var docSegments = segments.slice(2);\n  if (this._preventCompose && doc.shareDoc) {\n    var oldPreventCompose = doc.shareDoc.preventCompose;\n    doc.shareDoc.preventCompose = true;\n    var out = fn(doc, docSegments, cb);\n    doc.shareDoc.preventCompose = oldPreventCompose;\n    return out;\n  }\n  return fn(doc, docSegments, cb);\n};\n\nModel.prototype.set = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._set(segments, value, cb);\n};\nModel.prototype._set = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function set(doc, docSegments, fnCb) {\n    var previous = doc.set(docSegments, value, fnCb);\n    // On setting the entire doc, remote docs sometimes do a copy to add the\n    // id without it being stored in the database by ShareJS\n    if (docSegments.length === 0) value = doc.get(docSegments);\n    model.emit('change', segments, [value, previous, model._pass]);\n    return previous;\n  }\n  return this._mutate(segments, set, cb);\n};\n\nModel.prototype.setNull = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setNull(segments, value, cb);\n};\nModel.prototype._setNull = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function setNull(doc, docSegments, fnCb) {\n    var previous = doc.get(docSegments);\n    if (previous != null) {\n      fnCb();\n      return previous;\n    }\n    doc.set(docSegments, value, fnCb);\n    model.emit('change', segments, [value, previous, model._pass]);\n    return value;\n  }\n  return this._mutate(segments, setNull, cb);\n};\n\nModel.prototype.setEach = function() {\n  var subpath, object, cb;\n  if (arguments.length === 1) {\n    object = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    object = arguments[1];\n  } else {\n    subpath = arguments[0];\n    object = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setEach(segments, object, cb);\n};\nModel.prototype._setEach = function(segments, object, cb) {\n  segments = this._dereference(segments);\n  var group = util.asyncGroup(this.wrapCallback(cb));\n  for (var key in object) {\n    var value = object[key];\n    this._set(segments.concat(key), value, group());\n  }\n};\n\nModel.prototype.create = function() {\n  var subpath, value, cb;\n  if (arguments.length === 0) {\n    value = {};\n  } else if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      value = {};\n      cb = arguments[0];\n    } else {\n      value = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      value = arguments[0];\n      cb = arguments[1];\n    } else {\n      subpath = arguments[0];\n      value = arguments[1];\n    }\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._create(segments, value, cb);\n};\nModel.prototype._create = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  if (segments.length !== 2) {\n    var message = 'create may only be used on a document path. ' +\n      'Invalid path: ' + segments.join('.');\n    cb = this.wrapCallback(cb);\n    return cb(new Error(message));\n  }\n  var model = this;\n  function create(doc, docSegments, fnCb) {\n    var previous;\n    doc.create(value, fnCb);\n    // On creating the doc, remote docs do a copy to add the id without\n    // it being stored in the database by ShareJS\n    value = doc.get();\n    model.emit('change', segments, [value, previous, model._pass]);\n  }\n  this._mutate(segments, create, cb);\n};\n\nModel.prototype.createNull = function() {\n  var subpath, value, cb;\n  if (arguments.length === 0) {\n    value = {};\n  } else if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      value = {};\n      cb = arguments[0];\n    } else {\n      value = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      value = arguments[0];\n      cb = arguments[1];\n    } else {\n      subpath = arguments[0];\n      value = arguments[1];\n    }\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._createNull(segments, value, cb);\n};\nModel.prototype._createNull = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  var doc = this.getDoc(segments[0], segments[1]);\n  if (doc && doc.get() != null) return;\n  this._create(segments, value, cb);\n};\n\nModel.prototype.add = function() {\n  var subpath, value, cb;\n  if (arguments.length === 0) {\n    value = {};\n  } else if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      value = {};\n      cb = arguments[0];\n    } else {\n      value = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      value = arguments[0];\n      cb = arguments[1];\n    } else {\n      subpath = arguments[0];\n      value = arguments[1];\n    }\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._add(segments, value, cb);\n};\nModel.prototype._add = function(segments, value, cb) {\n  if (typeof value !== 'object') {\n    var message = 'add requires an object value. Invalid value: ' + value;\n    cb = this.wrapCallback(cb);\n    return cb(new Error(message));\n  }\n  var id = value.id || this.id();\n  value.id = id;\n  segments = this._dereference(segments.concat(id));\n  var model = this;\n  function add(doc, docSegments, fnCb) {\n    var previous;\n    if (docSegments.length) {\n      previous = doc.set(docSegments, value, fnCb);\n    } else {\n      doc.create(value, fnCb);\n      // On creating the doc, remote docs do a copy to add the id without\n      // it being stored in the database by ShareJS\n      value = doc.get();\n    }\n    model.emit('change', segments, [value, previous, model._pass]);\n  }\n  this._mutate(segments, add, cb);\n  return id;\n};\n\nModel.prototype.del = function() {\n  var subpath, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else {\n    subpath = arguments[0];\n    cb = arguments[1];\n  }\n  var segments = this._splitPath(subpath);\n  return this._del(segments, cb);\n};\nModel.prototype._del = function(segments, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function del(doc, docSegments, fnCb) {\n    var previous = doc.del(docSegments, fnCb);\n    // When deleting an entire document, also remove the reference to the\n    // document object from its collection\n    if (segments.length === 2) {\n      var collectionName = segments[0];\n      var id = segments[1];\n      model.root.collections[collectionName].remove(id);\n    }\n    model.emit('change', segments, [undefined, previous, model._pass]);\n    return previous;\n  }\n  return this._mutate(segments, del, cb);\n};\n\nModel.prototype.increment = function() {\n  var subpath, byNumber, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else if (typeof arguments[0] === 'number') {\n      byNumber = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      cb = arguments[1];\n      if (typeof arguments[0] === 'number') {\n        byNumber = arguments[0];\n      } else {\n        subpath = arguments[0];\n      }\n    } else {\n      subpath = arguments[0];\n      byNumber = arguments[1];\n    }\n  } else {\n    subpath = arguments[0];\n    byNumber = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._increment(segments, byNumber, cb);\n};\nModel.prototype._increment = function(segments, byNumber, cb) {\n  segments = this._dereference(segments);\n  if (byNumber == null) byNumber = 1;\n  var model = this;\n  function increment(doc, docSegments, fnCb) {\n    var value = doc.increment(docSegments, byNumber, fnCb);\n    var previous = value - byNumber;\n    model.emit('change', segments, [value, previous, model._pass]);\n    return value;\n  }\n  return this._mutate(segments, increment, cb);\n};\n\nModel.prototype.push = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._push(segments, value, cb);\n};\nModel.prototype._push = function(segments, value, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function push(doc, docSegments, fnCb) {\n    var length = doc.push(docSegments, value, fnCb);\n    model.emit('insert', segments, [length - 1, [value], model._pass]);\n    return length;\n  }\n  return this._mutate(segments, push, cb);\n};\n\nModel.prototype.unshift = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._unshift(segments, value, cb);\n};\nModel.prototype._unshift = function(segments, value, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function unshift(doc, docSegments, fnCb) {\n    var length = doc.unshift(docSegments, value, fnCb);\n    model.emit('insert', segments, [0, [value], model._pass]);\n    return length;\n  }\n  return this._mutate(segments, unshift, cb);\n};\n\nModel.prototype.insert = function() {\n  var subpath, index, values, cb;\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments for insert');\n  } else if (arguments.length === 2) {\n    index = arguments[0];\n    values = arguments[1];\n  } else if (arguments.length === 3) {\n    subpath = arguments[0];\n    index = arguments[1];\n    values = arguments[2];\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    values = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  return this._insert(segments, +index, values, cb);\n};\nModel.prototype._insert = function(segments, index, values, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function insert(doc, docSegments, fnCb) {\n    var inserted = (Array.isArray(values)) ? values : [values];\n    var length = doc.insert(docSegments, index, inserted, fnCb);\n    model.emit('insert', segments, [index, inserted, model._pass]);\n    return length;\n  }\n  return this._mutate(segments, insert, cb);\n};\n\nModel.prototype.pop = function() {\n  var subpath, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else {\n    subpath = arguments[0];\n    cb = arguments[1];\n  }\n  var segments = this._splitPath(subpath);\n  return this._pop(segments, cb);\n};\nModel.prototype._pop = function(segments, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function pop(doc, docSegments, fnCb) {\n    var arr = doc.get(docSegments);\n    var length = arr && arr.length;\n    if (!length) {\n      fnCb();\n      return;\n    }\n    var value = doc.pop(docSegments, fnCb);\n    model.emit('remove', segments, [length - 1, [value], model._pass]);\n    return value;\n  }\n  return this._mutate(segments, pop, cb);\n};\n\nModel.prototype.shift = function() {\n  var subpath, cb;\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'function') {\n      cb = arguments[0];\n    } else {\n      subpath = arguments[0];\n    }\n  } else {\n    subpath = arguments[0];\n    cb = arguments[1];\n  }\n  var segments = this._splitPath(subpath);\n  return this._shift(segments, cb);\n};\nModel.prototype._shift = function(segments, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  var model = this;\n  function shift(doc, docSegments, fnCb) {\n    var arr = doc.get(docSegments);\n    var length = arr && arr.length;\n    if (!length) {\n      fnCb();\n      return;\n    }\n    var value = doc.shift(docSegments, fnCb);\n    model.emit('remove', segments, [0, [value], model._pass]);\n    return value;\n  }\n  return this._mutate(segments, shift, cb);\n};\n\nModel.prototype.remove = function() {\n  var subpath, index, howMany, cb;\n  if (arguments.length < 2) {\n    index = arguments[0];\n  } else if (arguments.length === 2) {\n    if (typeof arguments[1] === 'function') {\n      cb = arguments[1];\n      if (typeof arguments[0] === 'number') {\n        index = arguments[0];\n      } else {\n        subpath = arguments[0];\n      }\n    } else {\n      // eslint-disable-next-line no-lonely-if\n      if (typeof arguments[0] === 'number') {\n        index = arguments[0];\n        howMany = arguments[1];\n      } else {\n        subpath = arguments[0];\n        index = arguments[1];\n      }\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      cb = arguments[2];\n      if (typeof arguments[0] === 'number') {\n        index = arguments[0];\n        howMany = arguments[1];\n      } else {\n        subpath = arguments[0];\n        index = arguments[1];\n      }\n    } else {\n      subpath = arguments[0];\n      index = arguments[1];\n      howMany = arguments[2];\n    }\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    howMany = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  if (index == null) index = segments.pop();\n  return this._remove(segments, +index, howMany, cb);\n};\nModel.prototype._remove = function(segments, index, howMany, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  if (howMany == null) howMany = 1;\n  var model = this;\n  function remove(doc, docSegments, fnCb) {\n    var removed = doc.remove(docSegments, index, howMany, fnCb);\n    model.emit('remove', segments, [index, removed, model._pass]);\n    return removed;\n  }\n  return this._mutate(segments, remove, cb);\n};\n\nModel.prototype.move = function() {\n  var subpath, from, to, howMany, cb;\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments for move');\n  } else if (arguments.length === 2) {\n    from = arguments[0];\n    to = arguments[1];\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      from = arguments[0];\n      to = arguments[1];\n      cb = arguments[2];\n    } else if (typeof arguments[0] === 'number') {\n      from = arguments[0];\n      to = arguments[1];\n      howMany = arguments[2];\n    } else {\n      subpath = arguments[0];\n      from = arguments[1];\n      to = arguments[2];\n    }\n  } else if (arguments.length === 4) {\n    if (typeof arguments[3] === 'function') {\n      cb = arguments[3];\n      if (typeof arguments[0] === 'number') {\n        from = arguments[0];\n        to = arguments[1];\n        howMany = arguments[2];\n      } else {\n        subpath = arguments[0];\n        from = arguments[1];\n        to = arguments[2];\n      }\n    } else {\n      subpath = arguments[0];\n      from = arguments[1];\n      to = arguments[2];\n      howMany = arguments[3];\n    }\n  } else {\n    subpath = arguments[0];\n    from = arguments[1];\n    to = arguments[2];\n    howMany = arguments[3];\n    cb = arguments[4];\n  }\n  var segments = this._splitPath(subpath);\n  return this._move(segments, from, to, howMany, cb);\n};\nModel.prototype._move = function(segments, from, to, howMany, cb) {\n  var forArrayMutator = true;\n  segments = this._dereference(segments, forArrayMutator);\n  if (howMany == null) howMany = 1;\n  var model = this;\n  function move(doc, docSegments, fnCb) {\n    // Cast to numbers\n    from = +from;\n    to = +to;\n    // Convert negative indices into positive\n    if (from < 0 || to < 0) {\n      var len = doc.get(docSegments).length;\n      if (from < 0) from += len;\n      if (to < 0) to += len;\n    }\n    var moved = doc.move(docSegments, from, to, howMany, fnCb);\n    model.emit('move', segments, [from, to, moved.length, model._pass]);\n    return moved;\n  }\n  return this._mutate(segments, move, cb);\n};\n\nModel.prototype.stringInsert = function() {\n  var subpath, index, text, cb;\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments for stringInsert');\n  } else if (arguments.length === 2) {\n    index = arguments[0];\n    text = arguments[1];\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      index = arguments[0];\n      text = arguments[1];\n      cb = arguments[2];\n    } else {\n      subpath = arguments[0];\n      index = arguments[1];\n      text = arguments[2];\n    }\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    text = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  return this._stringInsert(segments, index, text, cb);\n};\nModel.prototype._stringInsert = function(segments, index, text, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function stringInsert(doc, docSegments, fnCb) {\n    var previous = doc.stringInsert(docSegments, index, text, fnCb);\n    var value = doc.get(docSegments);\n    var pass = model.pass({$stringInsert: {index: index, text: text}})._pass;\n    model.emit('change', segments, [value, previous, pass]);\n    return;\n  }\n  return this._mutate(segments, stringInsert, cb);\n};\n\nModel.prototype.stringRemove = function() {\n  var subpath, index, howMany, cb;\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments for stringRemove');\n  } else if (arguments.length === 2) {\n    index = arguments[0];\n    howMany = arguments[1];\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      index = arguments[0];\n      howMany = arguments[1];\n      cb = arguments[2];\n    } else {\n      subpath = arguments[0];\n      index = arguments[1];\n      howMany = arguments[2];\n    }\n  } else {\n    subpath = arguments[0];\n    index = arguments[1];\n    howMany = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  return this._stringRemove(segments, index, howMany, cb);\n};\nModel.prototype._stringRemove = function(segments, index, howMany, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function stringRemove(doc, docSegments, fnCb) {\n    var previous = doc.stringRemove(docSegments, index, howMany, fnCb);\n    var value = doc.get(docSegments);\n    var pass = model.pass({$stringRemove: {index: index, howMany: howMany}})._pass;\n    model.emit('change', segments, [value, previous, pass]);\n    return;\n  }\n  return this._mutate(segments, stringRemove, cb);\n};\n\nModel.prototype.subtypeSubmit = function() {\n  var subpath, subtype, subtypeOp, cb;\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments for subtypeSubmit');\n  } else if (arguments.length === 2) {\n    subtype = arguments[0];\n    subtypeOp = arguments[1];\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'function') {\n      subtype = arguments[0];\n      subtypeOp = arguments[1];\n      cb = arguments[2];\n    } else {\n      subpath = arguments[0];\n      subtype = arguments[1];\n      subtypeOp = arguments[2];\n    }\n  } else {\n    subpath = arguments[0];\n    subtype = arguments[1];\n    subtypeOp = arguments[2];\n    cb = arguments[3];\n  }\n  var segments = this._splitPath(subpath);\n  return this._subtypeSubmit(segments, subtype, subtypeOp, cb);\n};\n\nModel.prototype._subtypeSubmit = function(segments, subtype, subtypeOp, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function subtypeSubmit(doc, docSegments, fnCb) {\n    var previous = doc.subtypeSubmit(docSegments, subtype, subtypeOp, fnCb);\n    var value = doc.get(docSegments);\n    var pass = model.pass({$subtype: {type: subtype, op: subtypeOp}})._pass;\n    // Emit undefined for the previous value, since we don't really know\n    // whether or not the previous value returned by the subtypeSubmit is the\n    // same object returned by reference or not. This may cause change\n    // listeners to over-trigger, but that is usually going to be better than\n    // under-triggering\n    model.emit('change', segments, [value, undefined, pass]);\n    return previous;\n  }\n  return this._mutate(segments, subtypeSubmit, cb);\n};\n",
    "var Model = require('./Model');\n\nexports.mixin = {};\n\nModel.prototype._splitPath = function(subpath) {\n  var path = this.path(subpath);\n  return (path && path.split('.')) || [];\n};\n\n/**\n * Returns the path equivalent to the path of the current scoped model plus\n * (optionally) a suffix subpath\n *\n * @optional @param {String} subpath\n * @return {String} absolute path\n * @api public\n */\nModel.prototype.path = function(subpath) {\n  if (subpath == null || subpath === '') return (this._at) ? this._at : '';\n  if (typeof subpath === 'string' || typeof subpath === 'number') {\n    return (this._at) ? this._at + '.' + subpath : '' + subpath;\n  }\n  if (typeof subpath.path === 'function') return subpath.path();\n};\n\nModel.prototype.isPath = function(subpath) {\n  return this.path(subpath) != null;\n};\n\nModel.prototype.scope = function(path) {\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      path = path + '.' + arguments[i];\n    }\n  }\n  return createScoped(this, path);\n};\n\n/**\n * Create a model object scoped to a particular path.\n * Example:\n *     var user = model.at('users.1');\n *     user.set('username', 'brian');\n *     user.on('push', 'todos', function(todo) {\n *       // ...\n *     });\n *\n *  @param {String} segment\n *  @return {Model} a scoped model\n *  @api public\n */\nModel.prototype.at = function(subpath) {\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      subpath = subpath + '.' + arguments[i];\n    }\n  }\n  var path = this.path(subpath);\n  return createScoped(this, path);\n};\n\nfunction createScoped(model, path) {\n  var scoped = model._child();\n  scoped._at = path;\n  return scoped;\n}\n\n/**\n * Returns a model scope that is a number of levels above the current scoped\n * path. Number of levels defaults to 1, so this method called without\n * arguments returns the model scope's parent model scope.\n *\n * @optional @param {Number} levels\n * @return {Model} a scoped model\n */\nModel.prototype.parent = function(levels) {\n  if (levels == null) levels = 1;\n  var segments = this._splitPath();\n  var len = Math.max(0, segments.length - levels);\n  var path = segments.slice(0, len).join('.');\n  return this.scope(path);\n};\n\n/**\n * Returns the last property segment of the current model scope path\n *\n * @optional @param {String} path\n * @return {String}\n */\nModel.prototype.leaf = function(path) {\n  if (!path) path = this.path();\n  var i = path.lastIndexOf('.');\n  return path.slice(i + 1);\n};\n",
    "var util = require('../util');\nvar Model = require('./Model');\n\nModel.INITS.push(function(model) {\n  var root = model.root;\n  root._refs = new Refs();\n  addIndexListeners(root);\n  addListener(root, 'change', refChange);\n  addListener(root, 'load', refLoad);\n  addListener(root, 'unload', refUnload);\n  addListener(root, 'insert', refInsert);\n  addListener(root, 'remove', refRemove);\n  addListener(root, 'move', refMove);\n});\n\nfunction addIndexListeners(model) {\n  model.on('insertImmediate', function refInsertIndex(segments, eventArgs) {\n    var index = eventArgs[0];\n    var howMany = eventArgs[1].length;\n    function patchInsert(refIndex) {\n      return (index <= refIndex) ? refIndex + howMany : refIndex;\n    }\n    onIndexChange(segments, patchInsert);\n  });\n  model.on('removeImmediate', function refRemoveIndex(segments, eventArgs) {\n    var index = eventArgs[0];\n    var howMany = eventArgs[1].length;\n    function patchRemove(refIndex) {\n      return (index <= refIndex) ? refIndex - howMany : refIndex;\n    }\n    onIndexChange(segments, patchRemove);\n  });\n  model.on('moveImmediate', function refMoveIndex(segments, eventArgs) {\n    var from = eventArgs[0];\n    var to = eventArgs[1];\n    var howMany = eventArgs[2];\n    function patchMove(refIndex) {\n      // If the index was moved itself\n      if (from <= refIndex && refIndex < from + howMany) {\n        return refIndex + to - from;\n      }\n      // Remove part of a move\n      if (from <= refIndex) refIndex -= howMany;\n      // Insert part of a move\n      if (to <= refIndex) refIndex += howMany;\n      return refIndex;\n    }\n    onIndexChange(segments, patchMove);\n  });\n  function onIndexChange(segments, patch) {\n    var fromMap = model._refs.fromMap;\n    for (var from in fromMap) {\n      var ref = fromMap[from];\n      if (!(ref.updateIndices &&\n        util.contains(segments, ref.toSegments) &&\n        ref.toSegments.length > segments.length)) continue;\n      var index = +ref.toSegments[segments.length];\n      var patched = patch(index);\n      if (index === patched) continue;\n      model._refs.remove(from);\n      ref.toSegments[segments.length] = '' + patched;\n      ref.to = ref.toSegments.join('.');\n      model._refs.add(ref);\n    }\n  }\n}\n\nfunction refChange(model, dereferenced, eventArgs, segments) {\n  var value = eventArgs[0];\n  // Detect if we are deleting vs. setting to undefined\n  if (value === undefined) {\n    var parentSegments = segments.slice();\n    var last = parentSegments.pop();\n    var parent = model._get(parentSegments);\n    if (!parent || !(last in parent)) {\n      model._del(dereferenced);\n      return;\n    }\n  }\n  model._set(dereferenced, value);\n}\nfunction refLoad(model, dereferenced, eventArgs) {\n  var value = eventArgs[0];\n  model._set(dereferenced, value);\n}\nfunction refUnload(model, dereferenced) {\n  model._del(dereferenced);\n}\nfunction refInsert(model, dereferenced, eventArgs) {\n  var index = eventArgs[0];\n  var values = eventArgs[1];\n  model._insert(dereferenced, index, values);\n}\nfunction refRemove(model, dereferenced, eventArgs) {\n  var index = eventArgs[0];\n  var howMany = eventArgs[1].length;\n  model._remove(dereferenced, index, howMany);\n}\nfunction refMove(model, dereferenced, eventArgs) {\n  var from = eventArgs[0];\n  var to = eventArgs[1];\n  var howMany = eventArgs[2];\n  model._move(dereferenced, from, to, howMany);\n}\n\nfunction addListener(model, type, fn) {\n  model.on(type + 'Immediate', refListener);\n  function refListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    // Find cases where an event is emitted on a path where a reference\n    // is pointing. All original mutations happen on the fully dereferenced\n    // location, so this detection only needs to happen in one direction\n    var toMap = model._refs.toMap;\n    var subpath;\n    for (var i = 0, len = segments.length; i < len; i++) {\n      subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];\n      // If a ref is found pointing to a matching subpath, re-emit on the\n      // place where the reference is coming from as if the mutation also\n      // occured at that path\n      var refs = toMap[subpath];\n      if (!refs) continue;\n\n      // Shallow clone refs in case a ref is removed while going through\n      // the loop\n      refs = refs.slice();\n      var remaining = segments.slice(i + 1);\n      for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {\n        var ref = refs[refIndex];\n        var dereferenced = ref.fromSegments.concat(remaining);\n        // The value may already be up to date via object reference. If so,\n        // simply re-emit the event. Otherwise, perform the same mutation on\n        // the ref's path\n        if (model._get(dereferenced) === model._get(segments)) {\n          model.emit(type, dereferenced, eventArgs);\n        } else {\n          var setterModel = ref.model.pass(pass, true);\n          setterModel._dereference = noopDereference;\n          fn(setterModel, dereferenced, eventArgs, segments);\n        }\n      }\n    }\n    // If a ref points to a child of a matching subpath, get the value in\n    // case it has changed and set if different\n    var parentToMap = model._refs.parentToMap;\n    var refs = parentToMap[subpath];\n    if (!refs) return;\n    for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {\n      var ref = refs[refIndex];\n      var value = model._get(ref.toSegments);\n      var previous = model._get(ref.fromSegments);\n      if (previous !== value) {\n        var setterModel = ref.model.pass(pass, true);\n        setterModel._dereference = noopDereference;\n        setterModel._set(ref.fromSegments, value);\n      }\n    }\n  }\n}\n\nModel.prototype._canRefTo = function(value) {\n  return this.isPath(value) || (value && typeof value.ref === 'function');\n};\n\nModel.prototype.ref = function() {\n  var from, to, options;\n  if (arguments.length === 1) {\n    to = arguments[0];\n  } else if (arguments.length === 2) {\n    if (this._canRefTo(arguments[1])) {\n      from = arguments[0];\n      to = arguments[1];\n    } else {\n      to = arguments[0];\n      options = arguments[1];\n    }\n  } else {\n    from = arguments[0];\n    to = arguments[1];\n    options = arguments[2];\n  }\n  var fromPath = this.path(from);\n  var toPath = this.path(to);\n  // Make ref to reffable object, such as query or filter\n  if (!toPath) return to.ref(fromPath);\n  var ref = new Ref(this.root, fromPath, toPath, options);\n  if (ref.fromSegments.length < 2) {\n    throw new Error('ref must be performed under a collection ' +\n      'and document id. Invalid path: ' + fromPath);\n  }\n  this.root._refs.remove(fromPath);\n  this.root._refLists.remove(fromPath);\n  var value = this.get(to);\n  ref.model._set(ref.fromSegments, value);\n  this.root._refs.add(ref);\n  return this.scope(fromPath);\n};\n\nModel.prototype.removeRef = function(subpath) {\n  var segments = this._splitPath(subpath);\n  var fromPath = segments.join('.');\n  this._removeRef(segments, fromPath);\n};\nModel.prototype._removeRef = function(segments, fromPath) {\n  this.root._refs.remove(fromPath);\n  this.root._refLists.remove(fromPath);\n  this._del(segments);\n};\n\nModel.prototype.removeAllRefs = function(subpath) {\n  var segments = this._splitPath(subpath);\n  this._removeAllRefs(segments);\n};\nModel.prototype._removeAllRefs = function(segments) {\n  this._removeMapRefs(segments, this.root._refs.fromMap);\n  this._removeMapRefs(segments, this.root._refLists.fromMap);\n};\nModel.prototype._removeMapRefs = function(segments, map) {\n  for (var from in map) {\n    var fromSegments = map[from].fromSegments;\n    if (util.contains(segments, fromSegments)) {\n      this._removeRef(fromSegments, from);\n    }\n  }\n};\n\nModel.prototype.dereference = function(subpath) {\n  var segments = this._splitPath(subpath);\n  return this._dereference(segments).join('.');\n};\n\nModel.prototype._dereference = function(segments, forArrayMutator, ignore) {\n  if (segments.length === 0) return segments;\n  var refs = this.root._refs.fromMap;\n  var refLists = this.root._refLists.fromMap;\n  var doAgain;\n  do {\n    var subpath = '';\n    doAgain = false;\n    for (var i = 0, len = segments.length; i < len; i++) {\n      subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];\n\n      var ref = refs[subpath];\n      if (ref) {\n        var remaining = segments.slice(i + 1);\n        segments = ref.toSegments.concat(remaining);\n        doAgain = true;\n        break;\n      }\n\n      var refList = refLists[subpath];\n      if (refList && refList !== ignore) {\n        var belowDescendant = i + 2 < len;\n        var belowChild = i + 1 < len;\n        if (!(belowDescendant || forArrayMutator && belowChild)) continue;\n        segments = refList.dereference(segments, i);\n        doAgain = true;\n        break;\n      }\n    }\n  } while (doAgain);\n  // If a dereference fails, return a path that will result in a null value\n  // instead of a path to everything in the model\n  if (segments.length === 0) return ['$null'];\n  return segments;\n};\n\nfunction noopDereference(segments) {\n  return segments;\n}\n\nfunction Ref(model, from, to, options) {\n  this.model = model && model.pass({$ref: this});\n  this.from = from;\n  this.to = to;\n  this.fromSegments = from.split('.');\n  this.toSegments = to.split('.');\n  this.parentTos = [];\n  for (var i = 1, len = this.toSegments.length; i < len; i++) {\n    var parentTo = this.toSegments.slice(0, i).join('.');\n    this.parentTos.push(parentTo);\n  }\n  this.updateIndices = options && options.updateIndices;\n}\nfunction FromMap() {}\nfunction ToMap() {}\n\nfunction Refs() {\n  this.fromMap = new FromMap();\n  this.toMap = new ToMap();\n  this.parentToMap = new ToMap();\n}\n\nRefs.prototype.add = function(ref) {\n  this.fromMap[ref.from] = ref;\n  listMapAdd(this.toMap, ref.to, ref);\n  for (var i = 0, len = ref.parentTos.length; i < len; i++) {\n    listMapAdd(this.parentToMap, ref.parentTos[i], ref);\n  }\n};\n\nRefs.prototype.remove = function(from) {\n  var ref = this.fromMap[from];\n  if (!ref) return;\n  delete this.fromMap[from];\n  listMapRemove(this.toMap, ref.to, ref);\n  for (var i = 0, len = ref.parentTos.length; i < len; i++) {\n    listMapRemove(this.parentToMap, ref.parentTos[i], ref);\n  }\n  return ref;\n};\n\nRefs.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var ref = this.fromMap[from];\n    out.push([ref.from, ref.to]);\n  }\n  return out;\n};\n\nfunction listMapAdd(map, name, item) {\n  map[name] || (map[name] = []);\n  map[name].push(item);\n}\n\nfunction listMapRemove(map, name, item) {\n  var items = map[name];\n  if (!items) return;\n  var index = items.indexOf(item);\n  if (index === -1) return;\n  items.splice(index, 1);\n  if (!items.length) delete map[name];\n}\n",
    "var util = require('../util');\nvar Model = require('./Model');\n\nModel.INITS.push(function(model) {\n  var root = model.root;\n  root._refLists = new RefLists();\n  for (var type in Model.MUTATOR_EVENTS) {\n    addListener(root, type);\n  }\n});\n\nfunction addListener(model, type) {\n  model.on(type + 'Immediate', refListListener);\n  function refListListener(segments, eventArgs) {\n    var pass = eventArgs[eventArgs.length - 1];\n    // Check for updates on or underneath paths\n    var fromMap = model._refLists.fromMap;\n    for (var from in fromMap) {\n      var refList = fromMap[from];\n      if (pass.$refList === refList) continue;\n      refList.onMutation(type, segments, eventArgs);\n    }\n  }\n}\n\n/**\n * @param {String} type\n * @param {Array} segments\n * @param {Array} eventArgs\n * @param {RefList} refList\n */\nfunction patchFromEvent(type, segments, eventArgs, refList) {\n  var fromLength = refList.fromSegments.length;\n  var segmentsLength = segments.length;\n  var pass = eventArgs[eventArgs.length - 1];\n  var model = refList.model.pass(pass, true);\n\n  // Mutation on the `from` output itself\n  if (segmentsLength === fromLength) {\n    if (type === 'insert') {\n      var index = eventArgs[0];\n      var values = eventArgs[1];\n      var ids = setNewToValues(model, refList, values);\n      model._insert(refList.idsSegments, index, ids);\n      return;\n    }\n\n    if (type === 'remove') {\n      var index = eventArgs[0];\n      var howMany = eventArgs[1].length;\n      var ids = model._remove(refList.idsSegments, index, howMany);\n      // Delete the appropriate items underneath `to` if the `deleteRemoved`\n      // option was set true\n      if (refList.deleteRemoved) {\n        for (var i = 0; i < ids.length; i++) {\n          var item = refList.itemById(ids[i]);\n          model._del(refList.toSegmentsByItem(item));\n        }\n      }\n      return;\n    }\n\n    if (type === 'move') {\n      var from = eventArgs[0];\n      var to = eventArgs[1];\n      var howMany = eventArgs[2];\n      model._move(refList.idsSegments, from, to, howMany);\n      return;\n    }\n\n    // Change of the entire output\n    var values = (type === 'change') ?\n      eventArgs[0] : model._get(refList.fromSegments);\n    // Set ids to empty list if output is set to null\n    if (!values) {\n      model._set(refList.idsSegments, []);\n      return;\n    }\n    // If the entire output is set, create a list of ids based on the output,\n    // and update the corresponding items\n    var ids = setNewToValues(model, refList, values);\n    model._set(refList.idsSegments, ids);\n    return;\n  }\n\n  // If mutation is on a parent of `from`, we might need to re-create the\n  // entire refList output\n  if (segmentsLength < fromLength) {\n    model._setArrayDiff(refList.fromSegments, refList.get());\n    return;\n  }\n\n  var index = segments[fromLength];\n  var value = model._get(refList.fromSegments.concat(index));\n  var toSegments = refList.toSegmentsByItem(value);\n\n  // Mutation underneath a child of the `from` object.\n  if (segmentsLength > fromLength + 1) {\n    throw new Error('Mutation on descendant of refList `from`' +\n      ' should have been dereferenced: ' + segments.join('.'));\n  }\n\n  // Otherwise, mutation of a child of the `from` object\n\n  // If changing the item itself, it will also have to be re-set on the\n  // original object\n  if (type === 'change') {\n    model._set(toSegments, value);\n    updateIdForValue(model, refList, index, value);\n    return;\n  }\n  if (type === 'insert' || type === 'remove' || type === 'move') {\n    throw new Error('Array mutation on child of refList `from`' +\n      'should have been dereferenced: ' + segments.join('.'));\n  }\n}\n\n/**\n * @private\n * @param {Model} model\n * @param {RefList} refList\n * @param {Array} values\n */\nfunction setNewToValues(model, refList, values) {\n  var ids = [];\n  for (var i = 0; i < values.length; i++) {\n    var value = values[i];\n    var id = refList.idByItem(value);\n    if (id === undefined && typeof value === 'object') {\n      id = value.id = model.id();\n    }\n    var toSegments = refList.toSegmentsByItem(value);\n    if (id === undefined || toSegments === undefined) {\n      throw new Error('Unable to add item to refList: ' + value);\n    }\n    if (model._get(toSegments) !== value) {\n      model._set(toSegments, value);\n    }\n    ids.push(id);\n  }\n  return ids;\n}\nfunction updateIdForValue(model, refList, index, value) {\n  var id = refList.idByItem(value);\n  var outSegments = refList.idsSegments.concat(index);\n  model._set(outSegments, id);\n}\n\nfunction patchToEvent(type, segments, eventArgs, refList) {\n  var toLength = refList.toSegments.length;\n  var segmentsLength = segments.length;\n  var pass = eventArgs[eventArgs.length - 1];\n  var model = refList.model.pass(pass, true);\n\n  // Mutation on the `to` object itself\n  if (segmentsLength === toLength) {\n    if (type === 'insert') {\n      var values = eventArgs[1];\n      for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        var indices = refList.indicesByItem(value);\n        if (!indices) continue;\n        for (var j = 0; j < indices.length; j++) {\n          var outSegments = refList.fromSegments.concat(indices[j]);\n          model._set(outSegments, value);\n        }\n      }\n      return;\n    }\n\n    if (type === 'remove') {\n      var removeIndex = eventArgs[0];\n      var values = eventArgs[1];\n      var howMany = values.length;\n      for (var i = removeIndex, len = removeIndex + howMany; i < len; i++) {\n        var indices = refList.indicesByItem(values[i]);\n        if (!indices) continue;\n        for (var j = 0, indicesLen = indices.length; j < indicesLen; j++) {\n          var outSegments = refList.fromSegments.concat(indices[j]);\n          model._set(outSegments, undefined);\n        }\n      }\n      return;\n    }\n\n    if (type === 'move') {\n      // Moving items in the `to` object should have no effect on the output\n      return;\n    }\n  }\n\n  // Mutation on or above the `to` object\n  if (segmentsLength <= toLength) {\n    // If the entire `to` object is updated, we need to re-create the\n    // entire refList output and apply what is different\n    model._setArrayDiff(refList.fromSegments, refList.get());\n    return;\n  }\n\n  // Mutation underneath a child of the `to` object. The item will already\n  // be up to date, since it is under an object reference. Just re-emit\n  if (segmentsLength > toLength + 1) {\n    var value = model._get(segments.slice(0, toLength + 1));\n    var indices = refList.indicesByItem(value);\n    if (!indices) return;\n    var remaining = segments.slice(toLength + 1);\n    for (var i = 0; i < indices.length; i++) {\n      var index = indices[i];\n      var dereferenced = refList.fromSegments.concat(index, remaining);\n      dereferenced = model._dereference(dereferenced, null, refList);\n      eventArgs = eventArgs.slice();\n      eventArgs[eventArgs.length - 1] = model._pass;\n      model.emit(type, dereferenced, eventArgs);\n    }\n    return;\n  }\n\n  // Otherwise, mutation of a child of the `to` object\n\n  // If changing the item itself, it will also have to be re-set on the\n  // array created by the refList\n  if (type === 'change' || type === 'load' || type === 'unload') {\n    var value, previous;\n    if (type === 'change') {\n      value = eventArgs[0];\n      previous = eventArgs[1];\n    } else if (type === 'load') {\n      value = eventArgs[0];\n      previous = undefined;\n    } else if (type === 'unload') {\n      value = undefined;\n      previous = eventArgs[0];\n    }\n    var newIndices = refList.indicesByItem(value);\n    var oldIndices = refList.indicesByItem(previous);\n    if (!newIndices && !oldIndices) return;\n    if (oldIndices && !equivalentArrays(oldIndices, newIndices)) {\n      // The changed item used to refer to some indices, but no longer does\n      for (var i = 0; i < oldIndices.length; i++) {\n        var outSegments = refList.fromSegments.concat(oldIndices[i]);\n        model._set(outSegments, undefined);\n      }\n    }\n    if (newIndices) {\n      for (var i = 0; i < newIndices.length; i++) {\n        var outSegments = refList.fromSegments.concat(newIndices[i]);\n        model._set(outSegments, value);\n      }\n    }\n    return;\n  }\n\n  var value = model._get(segments.slice(0, toLength + 1));\n  var indices = refList.indicesByItem(value);\n  if (!indices) return;\n\n  if (type === 'insert' || type === 'remove' || type === 'move') {\n    // Array mutations will have already been updated via an object\n    // reference, so only re-emit\n    for (var i = 0; i < indices.length; i++) {\n      var dereferenced = refList.fromSegments.concat(indices[i]);\n      dereferenced = model._dereference(dereferenced, null, refList);\n      eventArgs = eventArgs.slice();\n      eventArgs[eventArgs.length - 1] = model._pass;\n      model.emit(type, dereferenced, eventArgs);\n    }\n  }\n}\nfunction equivalentArrays(a, b) {\n  if (!a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\n\nfunction patchIdsEvent(type, segments, eventArgs, refList) {\n  var idsLength = refList.idsSegments.length;\n  var segmentsLength = segments.length;\n  var pass = eventArgs[eventArgs.length - 1];\n  var model = refList.model.pass(pass, true);\n\n  // An array mutation of the ids should be mirrored with a like change in\n  // the output array\n  if (segmentsLength === idsLength) {\n    if (type === 'insert') {\n      var index = eventArgs[0];\n      var inserted = eventArgs[1];\n      var values = [];\n      for (var i = 0; i < inserted.length; i++) {\n        var value = refList.itemById(inserted[i]);\n        values.push(value);\n      }\n      model._insert(refList.fromSegments, index, values);\n      return;\n    }\n\n    if (type === 'remove') {\n      var index = eventArgs[0];\n      var howMany = eventArgs[1].length;\n      model._remove(refList.fromSegments, index, howMany);\n      return;\n    }\n\n    if (type === 'move') {\n      var from = eventArgs[0];\n      var to = eventArgs[1];\n      var howMany = eventArgs[2];\n      model._move(refList.fromSegments, from, to, howMany);\n      return;\n    }\n  }\n\n  // Mutation on the `ids` list itself\n  if (segmentsLength <= idsLength) {\n    // If the entire `ids` array is updated, we need to re-create the\n    // entire refList output and apply what is different\n    model._setArrayDiff(refList.fromSegments, refList.get());\n    return;\n  }\n\n  // Otherwise, direct mutation of a child in the `ids` object or mutation\n  // underneath an item in the `ids` list. Update the item for the appropriate\n  // id if it has changed\n  var index = segments[idsLength];\n  var id = refList.idByIndex(index);\n  var item = refList.itemById(id);\n  var itemSegments = refList.fromSegments.concat(index);\n  if (model._get(itemSegments) !== item) {\n    model._set(itemSegments, item);\n  }\n}\n\nModel.prototype.refList = function() {\n  var from, to, ids, options;\n  if (arguments.length === 2) {\n    to = arguments[0];\n    ids = arguments[1];\n  } else if (arguments.length === 3) {\n    if (this.isPath(arguments[2])) {\n      from = arguments[0];\n      to = arguments[1];\n      ids = arguments[2];\n    } else {\n      to = arguments[0];\n      ids = arguments[1];\n      options = arguments[2];\n    }\n  } else {\n    from = arguments[0];\n    to = arguments[1];\n    ids = arguments[2];\n    options = arguments[3];\n  }\n  var fromPath = this.path(from);\n  var toPath;\n  if (Array.isArray(to)) {\n    toPath = [];\n    for (var i = 0; i < to.length; i++) {\n      toPath.push(this.path(to[i]));\n    }\n  } else {\n    toPath = this.path(to);\n  }\n  var idsPath = this.path(ids);\n  var refList = new RefList(this.root, fromPath, toPath, idsPath, options);\n  this.root._refLists.remove(fromPath);\n  refList.model._setArrayDiff(refList.fromSegments, refList.get());\n  this.root._refLists.add(refList);\n  return this.scope(fromPath);\n};\n\nfunction RefList(model, from, to, ids, options) {\n  this.model = model && model.pass({$refList: this});\n  this.from = from;\n  this.to = to;\n  this.ids = ids;\n  this.fromSegments = from && from.split('.');\n  this.toSegments = to && to.split('.');\n  this.idsSegments = ids && ids.split('.');\n  this.options = options;\n  this.deleteRemoved = options && options.deleteRemoved;\n}\n\n// The default implementation assumes that the ids array is a flat list of\n// keys on the to object. Ideally, this mapping could be customized via\n// inheriting from RefList and overriding these methods without having to\n// modify the above event handling code.\n//\n// In the default refList implementation, `key` and `id` are equal.\n//\n// Terms in the below methods:\n//   `item`  - Object on the `to` path, which gets mirrored on the `from` path\n//   `key`   - The property under `to` at which an item is located\n//   `id`    - String or object in the array at the `ids` path\n//   `index` - The index of an id, which corresponds to an index on `from`\nRefList.prototype.get = function() {\n  var ids = this.model._get(this.idsSegments);\n  if (!ids) return [];\n  var items = this.model._get(this.toSegments);\n  var out = [];\n  for (var i = 0; i < ids.length; i++) {\n    var key = ids[i];\n    out.push(items && items[key]);\n  }\n  return out;\n};\nRefList.prototype.dereference = function(segments, i) {\n  var remaining = segments.slice(i + 1);\n  var key = this.idByIndex(remaining[0]);\n  if (key == null) return [];\n  remaining[0] = key;\n  return this.toSegments.concat(remaining);\n};\nRefList.prototype.toSegmentsByItem = function(item) {\n  var key = this.idByItem(item);\n  if (key === undefined) return;\n  return this.toSegments.concat(key);\n};\nRefList.prototype.idByItem = function(item) {\n  if (item && item.id) return item.id;\n  var items = this.model._get(this.toSegments);\n  for (var key in items) {\n    if (item === items[key]) return key;\n  }\n};\nRefList.prototype.indicesByItem = function(item) {\n  var id = this.idByItem(item);\n  var ids = this.model._get(this.idsSegments);\n  if (!ids) return;\n  var indices;\n  var index = -1;\n  for (;;) {\n    index = ids.indexOf(id, index + 1);\n    if (index === -1) break;\n    if (indices) {\n      indices.push(index);\n    } else {\n      indices = [index];\n    }\n  }\n  return indices;\n};\nRefList.prototype.itemById = function(id) {\n  return this.model._get(this.toSegments.concat(id));\n};\nRefList.prototype.idByIndex = function(index) {\n  return this.model._get(this.idsSegments.concat(index));\n};\nRefList.prototype.onMutation = function(type, segments, eventArgs) {\n  if (util.mayImpact(this.toSegments, segments)) {\n    patchToEvent(type, segments, eventArgs, this);\n  } else if (util.mayImpact(this.idsSegments, segments)) {\n    patchIdsEvent(type, segments, eventArgs, this);\n  } else if (util.mayImpact(this.fromSegments, segments)) {\n    patchFromEvent(type, segments, eventArgs, this);\n  }\n};\n\nfunction FromMap() {}\n\nfunction RefLists() {\n  this.fromMap = new FromMap();\n}\n\nRefLists.prototype.add = function(refList) {\n  this.fromMap[refList.from] = refList;\n};\n\nRefLists.prototype.remove = function(from) {\n  var refList = this.fromMap[from];\n  delete this.fromMap[from];\n  return refList;\n};\n\nRefLists.prototype.toJSON = function() {\n  var out = [];\n  for (var from in this.fromMap) {\n    var refList = this.fromMap[from];\n    out.push([refList.from, refList.to, refList.ids, refList.options]);\n  }\n  return out;\n};\n",
    "var util = require('../util');\nvar Model = require('./Model');\nvar arrayDiff = require('arraydiff');\n\nModel.prototype.setDiff = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setDiff(segments, value, cb);\n};\nModel.prototype._setDiff = function(segments, value, cb) {\n  segments = this._dereference(segments);\n  var model = this;\n  function setDiff(doc, docSegments, fnCb) {\n    var previous = doc.get(docSegments);\n    if (util.equal(previous, value)) {\n      fnCb();\n      return previous;\n    }\n    doc.set(docSegments, value, fnCb);\n    model.emit('change', segments, [value, previous, model._pass]);\n    return previous;\n  }\n  return this._mutate(segments, setDiff, cb);\n};\n\nModel.prototype.setDiffDeep = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setDiffDeep(segments, value, cb);\n};\nModel.prototype._setDiffDeep = function(segments, value, cb) {\n  var before = this._get(segments);\n  cb = this.wrapCallback(cb);\n  var group = util.asyncGroup(cb);\n  var finished = group();\n  diffDeep(this, segments, before, value, group);\n  finished();\n};\nfunction diffDeep(model, segments, before, after, group) {\n  if (typeof before !== 'object' || !before ||\n      typeof after !== 'object' || !after) {\n    // Diff the entire value if not diffable objects\n    model._setDiff(segments, after, group());\n    return;\n  }\n  if (Array.isArray(before) && Array.isArray(after)) {\n    var diff = arrayDiff(before, after, util.deepEqual);\n    if (!diff.length) return;\n    // If the only change is a single item replacement, diff the item instead\n    if (\n      diff.length === 2 &&\n      diff[0].index === diff[1].index &&\n      diff[0] instanceof arrayDiff.RemoveDiff &&\n      diff[0].howMany === 1 &&\n      diff[1] instanceof arrayDiff.InsertDiff &&\n      diff[1].values.length === 1\n    ) {\n      var index = diff[0].index;\n      var itemSegments = segments.concat(index);\n      diffDeep(model, itemSegments, before[index], after[index], group);\n      return;\n    }\n    model._applyArrayDiff(segments, diff, group());\n    return;\n  }\n\n  // Delete keys that were in before but not after\n  for (var key in before) {\n    if (key in after) continue;\n    var itemSegments = segments.concat(key);\n    model._del(itemSegments, group());\n  }\n\n  // Diff each property in after\n  for (var key in after) {\n    if (util.deepEqual(before[key], after[key])) continue;\n    var itemSegments = segments.concat(key);\n    diffDeep(model, itemSegments, before[key], after[key], group);\n  }\n}\n\nModel.prototype.setArrayDiff = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setArrayDiff(segments, value, cb);\n};\nModel.prototype.setArrayDiffDeep = function() {\n  var subpath, value, cb;\n  if (arguments.length === 1) {\n    value = arguments[0];\n  } else if (arguments.length === 2) {\n    subpath = arguments[0];\n    value = arguments[1];\n  } else {\n    subpath = arguments[0];\n    value = arguments[1];\n    cb = arguments[2];\n  }\n  var segments = this._splitPath(subpath);\n  return this._setArrayDiffDeep(segments, value, cb);\n};\nModel.prototype._setArrayDiffDeep = function(segments, value, cb) {\n  return this._setArrayDiff(segments, value, cb, util.deepEqual);\n};\nModel.prototype._setArrayDiff = function(segments, value, cb, _equalFn) {\n  var before = this._get(segments);\n  if (before === value) return this.wrapCallback(cb)();\n  if (!Array.isArray(before) || !Array.isArray(value)) {\n    this._set(segments, value, cb);\n    return;\n  }\n  var diff = arrayDiff(before, value, _equalFn);\n  this._applyArrayDiff(segments, diff, cb);\n};\nModel.prototype._applyArrayDiff = function(segments, diff, cb) {\n  if (!diff.length) return this.wrapCallback(cb)();\n  segments = this._dereference(segments);\n  var model = this;\n  function applyArrayDiff(doc, docSegments, fnCb) {\n    var group = util.asyncGroup(fnCb);\n    for (var i = 0, len = diff.length; i < len; i++) {\n      var item = diff[i];\n      if (item instanceof arrayDiff.InsertDiff) {\n        // Insert\n        doc.insert(docSegments, item.index, item.values, group());\n        model.emit('insert', segments, [item.index, item.values, model._pass]);\n      } else if (item instanceof arrayDiff.RemoveDiff) {\n        // Remove\n        var removed = doc.remove(docSegments, item.index, item.howMany, group());\n        model.emit('remove', segments, [item.index, removed, model._pass]);\n      } else if (item instanceof arrayDiff.MoveDiff) {\n        // Move\n        var moved = doc.move(docSegments, item.from, item.to, item.howMany, group());\n        model.emit('move', segments, [item.from, item.to, moved.length, model._pass]);\n      }\n    }\n  }\n  return this._mutate(segments, applyArrayDiff, cb);\n};\n",
    "var deepEqual = require('fast-deep-equal');\n\nvar isServer = process.title !== 'browser';\nexports.isServer = isServer;\n\nexports.asyncGroup = asyncGroup;\nexports.castSegments = castSegments;\nexports.contains = contains;\nexports.copy = copy;\nexports.copyObject = copyObject;\nexports.deepCopy = deepCopy;\nexports.deepEqual = deepEqual;\nexports.equal = equal;\nexports.equalsNaN = equalsNaN;\nexports.isArrayIndex = isArrayIndex;\nexports.lookup = lookup;\nexports.mergeInto = mergeInto;\nexports.mayImpact = mayImpact;\nexports.mayImpactAny = mayImpactAny;\nexports.serverRequire = serverRequire;\nexports.serverUse = serverUse;\nexports.use = use;\n\nfunction asyncGroup(cb) {\n  var group = new AsyncGroup(cb);\n  return function asyncGroupAdd() {\n    return group.add();\n  };\n}\n\n/**\n * @constructor\n * @param {Function} cb(err)\n */\nfunction AsyncGroup(cb) {\n  this.cb = cb;\n  this.isDone = false;\n  this.count = 0;\n}\nAsyncGroup.prototype.add = function() {\n  this.count++;\n  var self = this;\n  return function(err) {\n    self.count--;\n    if (self.isDone) return;\n    if (err) {\n      self.isDone = true;\n      self.cb(err);\n      return;\n    }\n    if (self.count > 0) return;\n    self.isDone = true;\n    self.cb();\n  };\n};\n\n/**\n * @param {Array<string | number>} segments\n * @return {Array<string | number>}\n */\nfunction castSegments(segments) {\n  // Cast number path segments from strings to numbers\n  for (var i = segments.length; i--;) {\n    var segment = segments[i];\n    if (typeof segment === 'string' && isArrayIndex(segment)) {\n      segments[i] = +segment;\n    }\n  }\n  return segments;\n}\n\nfunction contains(segments, testSegments) {\n  for (var i = 0; i < segments.length; i++) {\n    if (segments[i] !== testSegments[i]) return false;\n  }\n  return true;\n}\n\nfunction copy(value) {\n  if (value instanceof Date) return new Date(value);\n  if (typeof value === 'object') {\n    if (value === null) return null;\n    if (Array.isArray(value)) return value.slice();\n    return copyObject(value);\n  }\n  return value;\n}\n\nfunction copyObject(object) {\n  var out = new object.constructor();\n  for (var key in object) {\n    if (object.hasOwnProperty(key)) {\n      out[key] = object[key];\n    }\n  }\n  return out;\n}\n\nfunction deepCopy(value) {\n  if (value instanceof Date) return new Date(value);\n  if (typeof value === 'object') {\n    if (value === null) return null;\n    if (Array.isArray(value)) {\n      var array = [];\n      for (var i = value.length; i--;) {\n        array[i] = deepCopy(value[i]);\n      }\n      return array;\n    }\n    var object = new value.constructor();\n    for (var key in value) {\n      if (value.hasOwnProperty(key)) {\n        object[key] = deepCopy(value[key]);\n      }\n    }\n    return object;\n  }\n  return value;\n}\n\nfunction equal(a, b) {\n  return (a === b) || (equalsNaN(a) && equalsNaN(b));\n}\n\nfunction equalsNaN(x) {\n  // eslint-disable-next-line no-self-compare\n  return x !== x;\n}\n\nfunction isArrayIndex(segment) {\n  return (/^[0-9]+$/).test(segment);\n}\n\nfunction lookup(segments, value) {\n  if (!segments) return value;\n\n  for (var i = 0, len = segments.length; i < len; i++) {\n    if (value == null) return value;\n    value = value[segments[i]];\n  }\n  return value;\n}\n\nfunction mayImpactAny(segmentsList, testSegments) {\n  for (var i = 0, len = segmentsList.length; i < len; i++) {\n    if (mayImpact(segmentsList[i], testSegments)) return true;\n  }\n  return false;\n}\n\nfunction mayImpact(segments, testSegments) {\n  var len = Math.min(segments.length, testSegments.length);\n  for (var i = 0; i < len; i++) {\n    if (segments[i] !== testSegments[i]) return false;\n  }\n  return true;\n}\n\nfunction mergeInto(to, from) {\n  for (var key in from) {\n    to[key] = from[key];\n  }\n  return to;\n}\n\nfunction serverRequire(module, id) {\n  if (!isServer) return;\n  return module.require(id);\n}\n\nfunction serverUse(module, id, options) {\n  if (!isServer) return this;\n  var plugin = module.require(id);\n  return this.use(plugin, options);\n}\n\nfunction use(plugin, options) {\n  // Don't include a plugin more than once\n  var plugins = this._plugins || (this._plugins = []);\n  if (plugins.indexOf(plugin) === -1) {\n    plugins.push(plugin);\n    plugin(this, options);\n  }\n  return this;\n}\n",
    "if (typeof require === 'function') {\n  var serializeObject = require('serialize-object');\n}\n\n// UPDATE_PROPERTIES map HTML attribute names to an Element DOM property that\n// should be used for setting on bindings updates instead of setAttribute.\n//\n// https://github.com/jquery/jquery/blob/1.x-master/src/attributes/prop.js\n// https://github.com/jquery/jquery/blob/master/src/attributes/prop.js\n// http://webbugtrack.blogspot.com/2007/08/bug-242-setattribute-doesnt-always-work.html\nvar BOOLEAN_PROPERTIES = {\n  checked: 'checked'\n, disabled: 'disabled'\n, readonly: 'readOnly'\n, selected: 'selected'\n};\nvar INTEGER_PROPERTIES = {\n  colspan: 'colSpan'\n, maxlength: 'maxLength'\n, rowspan: 'rowSpan'\n, tabindex: 'tabIndex'\n};\nvar STRING_PROPERTIES = {\n  cellpadding: 'cellPadding'\n, cellspacing: 'cellSpacing'\n, 'class': 'className'\n, contenteditable: 'contentEditable'\n, enctype: 'encoding'\n, 'for': 'htmlFor'\n, frameborder: 'frameBorder'\n, id: 'id'\n, title: 'title'\n, type: 'type'\n, usemap: 'useMap'\n, value: 'value'\n};\nvar UPDATE_PROPERTIES = {};\nmergeInto(BOOLEAN_PROPERTIES, UPDATE_PROPERTIES);\nmergeInto(INTEGER_PROPERTIES, UPDATE_PROPERTIES);\nmergeInto(STRING_PROPERTIES, UPDATE_PROPERTIES);\n\n// CREATE_PROPERTIES map HTML attribute names to an Element DOM property that\n// should be used for setting on Element rendering instead of setAttribute.\n// input.defaultChecked and input.defaultValue affect the attribute, so we want\n// to use these for initial dynamic rendering. For binding updates,\n// input.checked and input.value are modified.\nvar CREATE_PROPERTIES = {};\nmergeInto(UPDATE_PROPERTIES, CREATE_PROPERTIES);\nCREATE_PROPERTIES.checked = 'defaultChecked';\nCREATE_PROPERTIES.value = 'defaultValue';\n\n// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\nvar VOID_ELEMENTS = {\n  area: true\n, base: true\n, br: true\n, col: true\n, embed: true\n, hr: true\n, img: true\n, input: true\n, keygen: true\n, link: true\n, menuitem: true\n, meta: true\n, param: true\n, source: true\n, track: true\n, wbr: true\n};\n\nvar NAMESPACE_URIS = {\n  svg: 'http://www.w3.org/2000/svg'\n, xlink: 'http://www.w3.org/1999/xlink'\n, xmlns: 'http://www.w3.org/2000/xmlns/'\n};\n\nexports.CREATE_PROPERTIES = CREATE_PROPERTIES;\nexports.BOOLEAN_PROPERTIES = BOOLEAN_PROPERTIES;\nexports.INTEGER_PROPERTIES = INTEGER_PROPERTIES;\nexports.STRING_PROPERTIES = STRING_PROPERTIES;\nexports.UPDATE_PROPERTIES = UPDATE_PROPERTIES;\nexports.VOID_ELEMENTS = VOID_ELEMENTS;\nexports.NAMESPACE_URIS = NAMESPACE_URIS;\n\n// Template Classes\nexports.Template = Template;\nexports.Doctype = Doctype;\nexports.Text = Text;\nexports.DynamicText = DynamicText;\nexports.Comment = Comment;\nexports.DynamicComment = DynamicComment;\nexports.Html = Html;\nexports.DynamicHtml = DynamicHtml;\nexports.Element = Element;\nexports.DynamicElement = DynamicElement;\nexports.Block = Block;\nexports.ConditionalBlock = ConditionalBlock;\nexports.EachBlock = EachBlock;\n\nexports.Attribute = Attribute;\nexports.DynamicAttribute = DynamicAttribute;\n\n// Binding Classes\nexports.Binding = Binding;\nexports.NodeBinding = NodeBinding;\nexports.AttributeBinding = AttributeBinding;\nexports.RangeBinding = RangeBinding;\n\nfunction Template(content, source) {\n  this.content = content;\n  this.source = source;\n}\nTemplate.prototype.toString = function() {\n  return this.source;\n};\nTemplate.prototype.get = function(context, unescaped) {\n  return contentHtml(this.content, context, unescaped);\n};\nTemplate.prototype.getFragment = function(context, binding) {\n  var fragment = document.createDocumentFragment();\n  this.appendTo(fragment, context, binding);\n  return fragment;\n};\nTemplate.prototype.appendTo = function(parent, context) {\n  context.pause();\n  appendContent(parent, this.content, context);\n  context.unpause();\n};\nTemplate.prototype.attachTo = function(parent, node, context) {\n  context.pause();\n  var node = attachContent(parent, node, this.content, context);\n  context.unpause();\n  return node;\n};\nTemplate.prototype.update = function() {};\nTemplate.prototype.stringify = function(value) {\n  return (value == null) ? '' : value + '';\n};\nTemplate.prototype.equals = function(other) {\n  return this === other;\n};\nTemplate.prototype.module = 'templates';\nTemplate.prototype.type = 'Template';\nTemplate.prototype.serialize = function() {\n  return serializeObject.instance(this, this.content, this.source);\n};\n\n\nfunction Doctype(name, publicId, systemId) {\n  this.name = name;\n  this.publicId = publicId;\n  this.systemId = systemId;\n}\nDoctype.prototype = Object.create(Template.prototype);\nDoctype.prototype.constructor = Doctype;\nDoctype.prototype.get = function() {\n  var publicText = (this.publicId) ?\n    ' PUBLIC \"' + this.publicId  + '\"' :\n    '';\n  var systemText = (this.systemId) ?\n    (this.publicId) ?\n      ' \"' + this.systemId + '\"' :\n      ' SYSTEM \"' + this.systemId + '\"' :\n    '';\n  return '<!DOCTYPE ' + this.name + publicText + systemText + '>';\n};\nDoctype.prototype.appendTo = function() {\n  // Doctype could be created via:\n  //   document.implementation.createDocumentType(this.name, this.publicId, this.systemId)\n  // However, it does not appear possible or useful to append it to the\n  // document fragment. Therefore, just don't render it in the browser\n};\nDoctype.prototype.attachTo = function(parent, node) {\n  if (!node || node.nodeType !== 10) {\n    throw attachError(parent, node);\n  }\n  return node.nextSibling;\n};\nDoctype.prototype.type = 'Doctype';\nDoctype.prototype.serialize = function() {\n  return serializeObject.instance(this, this.name, this.publicId, this.systemId);\n};\n\nfunction Text(data) {\n  this.data = data;\n  this.escaped = escapeHtml(data);\n}\nText.prototype = Object.create(Template.prototype);\nText.prototype.constructor = Text;\nText.prototype.get = function(context, unescaped) {\n  return (unescaped) ? this.data : this.escaped;\n};\nText.prototype.appendTo = function(parent) {\n  var node = document.createTextNode(this.data);\n  parent.appendChild(node);\n};\nText.prototype.attachTo = function(parent, node) {\n  return attachText(parent, node, this.data, this);\n};\nText.prototype.type = 'Text';\nText.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data);\n};\n\n// DynamicText might be more accurately named DynamicContent. When its\n// expression returns a template, it acts similar to a Block, and it renders\n// the template surrounded by comment markers for range replacement. When its\n// expression returns any other type, it renders a DOM Text node with no\n// markers. Text nodes are bound by updating their data property dynamically.\n// The update method must take care to switch between these types of bindings\n// in case the expression return type changes dynamically.\nfunction DynamicText(expression) {\n  this.expression = expression;\n  this.unbound = false;\n}\nDynamicText.prototype = Object.create(Template.prototype);\nDynamicText.prototype.constructor = DynamicText;\nDynamicText.prototype.get = function(context, unescaped) {\n  var value = this.expression.get(context);\n  if (value instanceof Template) {\n    do {\n      value = value.get(context, unescaped);\n    } while (value instanceof Template);\n    return value;\n  }\n  var data = this.stringify(value);\n  return (unescaped) ? data : escapeHtml(data);\n};\nDynamicText.prototype.appendTo = function(parent, context, binding) {\n  var value = this.expression.get(context);\n  if (value instanceof Template) {\n    var start = document.createComment(this.expression);\n    var end = document.createComment('/' + this.expression);\n    var condition = this.getCondition(context);\n    parent.appendChild(start);\n    value.appendTo(parent, context);\n    parent.appendChild(end);\n    updateRange(context, binding, this, start, end, null, condition);\n    return;\n  }\n  var data = this.stringify(value);\n  var node = document.createTextNode(data);\n  parent.appendChild(node);\n  addNodeBinding(this, context, node);\n};\nDynamicText.prototype.attachTo = function(parent, node, context) {\n  var value = this.expression.get(context);\n  if (value instanceof Template) {\n    var start = document.createComment(this.expression);\n    var end = document.createComment('/' + this.expression);\n    var condition = this.getCondition(context);\n    parent.insertBefore(start, node || null);\n    node = value.attachTo(parent, node, context);\n    parent.insertBefore(end, node || null);\n    updateRange(context, null, this, start, end, null, condition);\n    return node;\n  }\n  var data = this.stringify(value);\n  return attachText(parent, node, data, this, context);\n};\nDynamicText.prototype.update = function(context, binding) {\n  if (binding instanceof RangeBinding) {\n    this._blockUpdate(context, binding);\n    return;\n  }\n  var value = this.expression.get(context);\n  if (value instanceof Template) {\n    var start = binding.node;\n    if (!start.parentNode) return;\n    var end = start;\n    var fragment = this.getFragment(context);\n    replaceRange(context, start, end, fragment, binding);\n    return;\n  }\n  binding.node.data = this.stringify(value);\n};\nDynamicText.prototype.getCondition = function(context) {\n  return this.expression.get(context);\n};\nDynamicText.prototype.type = 'DynamicText';\nDynamicText.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression);\n};\n\nfunction attachText(parent, node, data, template, context) {\n  if (!node) {\n    var newNode = document.createTextNode(data);\n    parent.appendChild(newNode);\n    addNodeBinding(template, context, newNode);\n    return;\n  }\n  if (node.nodeType === 3) {\n    // Proceed if nodes already match\n    if (node.data === data) {\n      addNodeBinding(template, context, node);\n      return node.nextSibling;\n    }\n    data = normalizeLineBreaks(data);\n    // Split adjacent text nodes that would have been merged together in HTML\n    var nextNode = splitData(node, data.length);\n    if (node.data !== data) {\n      throw attachError(parent, node);\n    }\n    addNodeBinding(template, context, node);\n    return nextNode;\n  }\n  // An empty text node might not be created at the end of some text\n  if (data === '') {\n    var newNode = document.createTextNode('');\n    parent.insertBefore(newNode, node || null);\n    addNodeBinding(template, context, newNode);\n    return node;\n  }\n  throw attachError(parent, node);\n}\n\nfunction Comment(data, hooks) {\n  this.data = data;\n  this.hooks = hooks;\n}\nComment.prototype = Object.create(Template.prototype);\nComment.prototype.constructor = Comment;\nComment.prototype.get = function() {\n  return '<!--' + this.data + '-->';\n};\nComment.prototype.appendTo = function(parent, context) {\n  var node = document.createComment(this.data);\n  parent.appendChild(node);\n  emitHooks(this.hooks, context, node);\n};\nComment.prototype.attachTo = function(parent, node, context) {\n  return attachComment(parent, node, this.data, this, context);\n};\nComment.prototype.type = 'Comment';\nComment.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data, this.hooks);\n}\n\nfunction DynamicComment(expression, hooks) {\n  this.expression = expression;\n  this.hooks = hooks;\n}\nDynamicComment.prototype = Object.create(Template.prototype);\nDynamicComment.prototype.constructor = DynamicComment;\nDynamicComment.prototype.get = function(context) {\n  var value = getUnescapedValue(this.expression, context);\n  var data = this.stringify(value);\n  return '<!--' + data + '-->';\n};\nDynamicComment.prototype.appendTo = function(parent, context) {\n  var value = getUnescapedValue(this.expression, context);\n  var data = this.stringify(value);\n  var node = document.createComment(data);\n  parent.appendChild(node);\n  addNodeBinding(this, context, node);\n};\nDynamicComment.prototype.attachTo = function(parent, node, context) {\n  var value = getUnescapedValue(this.expression, context);\n  var data = this.stringify(value);\n  return attachComment(parent, node, data, this, context);\n};\nDynamicComment.prototype.update = function(context, binding) {\n  var value = getUnescapedValue(this.expression, context);\n  binding.node.data = this.stringify(value);\n};\nDynamicComment.prototype.type = 'DynamicComment';\nDynamicComment.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.hooks);\n}\n\nfunction attachComment(parent, node, data, template, context) {\n  // Sometimes IE fails to create Comment nodes from HTML or innerHTML.\n  // This is an issue inside of <select> elements, for example.\n  if (!node || node.nodeType !== 8) {\n    var newNode = document.createComment(data);\n    parent.insertBefore(newNode, node || null);\n    addNodeBinding(template, context, newNode);\n    return node;\n  }\n  // Proceed if nodes already match\n  if (node.data === data) {\n    addNodeBinding(template, context, node);\n    return node.nextSibling;\n  }\n  throw attachError(parent, node);\n}\n\nfunction addNodeBinding(template, context, node) {\n  if (template.expression && !template.unbound) {\n    context.addBinding(new NodeBinding(template, context, node));\n  }\n  emitHooks(template.hooks, context, node);\n}\n\nfunction Html(data) {\n  this.data = data;\n}\nHtml.prototype = Object.create(Template.prototype);\nHtml.prototype.constructor = Html;\nHtml.prototype.get = function() {\n  return this.data;\n};\nHtml.prototype.appendTo = function(parent) {\n  var fragment = createHtmlFragment(parent, this.data);\n  parent.appendChild(fragment);\n};\nHtml.prototype.attachTo = function(parent, node) {\n  return attachHtml(parent, node, this.data);\n};\nHtml.prototype.type = \"Html\";\nHtml.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data);\n};\n\nfunction DynamicHtml(expression) {\n  this.expression = expression;\n  this.ending = '/' + expression;\n}\nDynamicHtml.prototype = Object.create(Template.prototype);\nDynamicHtml.prototype.constructor = DynamicHtml;\nDynamicHtml.prototype.get = function(context) {\n  var value = getUnescapedValue(this.expression, context);\n  return this.stringify(value);\n};\nDynamicHtml.prototype.appendTo = function(parent, context, binding) {\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var value = getUnescapedValue(this.expression, context);\n  var html = this.stringify(value);\n  var fragment = createHtmlFragment(parent, html);\n  parent.appendChild(start);\n  parent.appendChild(fragment);\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end);\n};\nDynamicHtml.prototype.attachTo = function(parent, node, context) {\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var value = getUnescapedValue(this.expression, context);\n  var html = this.stringify(value);\n  parent.insertBefore(start, node || null);\n  node = attachHtml(parent, node, html);\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end);\n  return node;\n};\nDynamicHtml.prototype.update = function(context, binding) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  // Get start and end in advance, since binding is mutated in getFragment\n  var start = binding.start;\n  var end = binding.end;\n  var value = getUnescapedValue(this.expression, context);\n  var html = this.stringify(value);\n  var fragment = createHtmlFragment(parent, html);\n  var innerOnly = true;\n  replaceRange(context, start, end, fragment, binding, innerOnly);\n};\nDynamicHtml.prototype.type = 'DynamicHtml';\nDynamicHtml.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression);\n};\n\nfunction createHtmlFragment(parent, html) {\n  if (parent && parent.nodeType === 1) {\n    var range = document.createRange();\n    range.selectNodeContents(parent);\n    return range.createContextualFragment(html);\n  }\n  var div = document.createElement('div');\n  var range = document.createRange();\n  div.innerHTML = html;\n  range.selectNodeContents(div);\n  return range.extractContents();\n}\nfunction attachHtml(parent, node, html) {\n  var fragment = createHtmlFragment(parent, html);\n  for (var i = 0, len = fragment.childNodes.length; i < len; i++) {\n    if (!node) throw attachError(parent, node);\n    node = node.nextSibling;\n  }\n  return node;\n}\n\nfunction Attribute(data, ns) {\n  this.data = data;\n  this.ns = ns;\n}\nAttribute.prototype = Object.create(Template.prototype);\nAttribute.prototype.constructor = Attribute;\nAttribute.prototype.get = Attribute.prototype.getBound = function(context) {\n  return this.data;\n};\nAttribute.prototype.type = 'Attribute';\nAttribute.prototype.serialize = function() {\n  return serializeObject.instance(this, this.data, this.ns);\n};\n\nfunction DynamicAttribute(expression, ns) {\n  // In attributes, expression may be an instance of Template or Expression\n  this.expression = expression;\n  this.ns = ns;\n  this.elementNs = null;\n}\nDynamicAttribute.prototype = Object.create(Attribute.prototype);\nDynamicAttribute.prototype.constructor = DynamicAttribute;\nDynamicAttribute.prototype.get = function(context) {\n  return getUnescapedValue(this.expression, context);\n};\nDynamicAttribute.prototype.getBound = function(context, element, name, elementNs) {\n  this.elementNs = elementNs;\n  context.addBinding(new AttributeBinding(this, context, element, name));\n  return getUnescapedValue(this.expression, context);\n};\nDynamicAttribute.prototype.update = function(context, binding) {\n  var value = getUnescapedValue(this.expression, context);\n  var element = binding.element;\n  var propertyName = !this.elementNs && UPDATE_PROPERTIES[binding.name];\n  if (propertyName) {\n    var propertyValue = (STRING_PROPERTIES[binding.name]) ?\n      this.stringify(value) : value;\n    if (element[propertyName] === propertyValue) return;\n    element[propertyName] = propertyValue;\n    return;\n  }\n  if (value === false || value == null) {\n    if (this.ns) {\n      element.removeAttributeNS(this.ns, binding.name);\n    } else {\n      element.removeAttribute(binding.name);\n    }\n    return;\n  }\n  if (value === true) value = binding.name;\n  if (this.ns) {\n    element.setAttributeNS(this.ns, binding.name, value);\n  } else {\n    element.setAttribute(binding.name, value);\n  }\n};\nDynamicAttribute.prototype.type = 'DynamicAttribute';\nDynamicAttribute.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.ns);\n};\n\nfunction getUnescapedValue(expression, context) {\n  var unescaped = true;\n  var value = expression.get(context, unescaped);\n  while (value instanceof Template) {\n    value = value.get(context, unescaped);\n  }\n  return value;\n}\n\nfunction Element(tagName, attributes, content, hooks, selfClosing, notClosed, ns) {\n  this.tagName = tagName;\n  this.attributes = attributes;\n  this.content = content;\n  this.hooks = hooks;\n  this.selfClosing = selfClosing;\n  this.notClosed = notClosed;\n  this.ns = ns;\n\n  this.endTag = getEndTag(tagName, selfClosing, notClosed);\n  this.startClose = getStartClose(selfClosing);\n  var lowerTagName = tagName && tagName.toLowerCase();\n  this.unescapedContent = (lowerTagName === 'script' || lowerTagName === 'style');\n  this.bindContentToValue = (lowerTagName === 'textarea');\n}\nElement.prototype = Object.create(Template.prototype);\nElement.prototype.constructor = Element;\nElement.prototype.getTagName = function() {\n  return this.tagName;\n};\nElement.prototype.getEndTag = function() {\n  return this.endTag;\n};\nElement.prototype.get = function(context) {\n  var tagName = this.getTagName(context);\n  var endTag = this.getEndTag(tagName);\n  var tagItems = [tagName];\n  for (var key in this.attributes) {\n    var value = this.attributes[key].get(context);\n    if (value === true) {\n      tagItems.push(key);\n    } else if (value !== false && value != null) {\n      tagItems.push(key + '=\"' + escapeAttribute(value) + '\"');\n    }\n  }\n  var startTag = '<' + tagItems.join(' ') + this.startClose;\n  if (this.content) {\n    var inner = contentHtml(this.content, context, this.unescapedContent);\n    return startTag + inner + endTag;\n  }\n  return startTag + endTag;\n};\nElement.prototype.appendTo = function(parent, context) {\n  var tagName = this.getTagName(context);\n  var element = (this.ns) ?\n    document.createElementNS(this.ns, tagName) :\n    document.createElement(tagName);\n  for (var key in this.attributes) {\n    var attribute = this.attributes[key];\n    var value = attribute.getBound(context, element, key, this.ns);\n    if (value === false || value == null) continue;\n    var propertyName = !this.ns && CREATE_PROPERTIES[key];\n    if (propertyName) {\n      element[propertyName] = value;\n      continue;\n    }\n    if (value === true) value = key;\n    if (attribute.ns) {\n      element.setAttributeNS(attribute.ns, key, value);\n    } else {\n      element.setAttribute(key, value);\n    }\n  }\n  if (this.content) {\n    this._bindContent(context, element);\n    appendContent(element, this.content, context);\n  }\n  parent.appendChild(element);\n  emitHooks(this.hooks, context, element);\n};\nElement.prototype.attachTo = function(parent, node, context) {\n  var tagName = this.getTagName(context);\n  if (\n    !node ||\n    node.nodeType !== 1 ||\n    node.tagName.toLowerCase() !== tagName.toLowerCase()\n  ) {\n    throw attachError(parent, node);\n  }\n  for (var key in this.attributes) {\n    // Get each attribute to create bindings\n    this.attributes[key].getBound(context, node, key, this.ns);\n    // TODO: Ideally, this would also check that the node's current attributes\n    // are equivalent, but there are some tricky edge cases\n  }\n  if (this.content) {\n    this._bindContent(context, node);\n    attachContent(node, node.firstChild, this.content, context);\n  }\n  emitHooks(this.hooks, context, node);\n  return node.nextSibling;\n};\nElement.prototype._bindContent = function(context, element) {\n  // For textareas with dynamic text content, bind to the value property\n  var child = this.bindContentToValue &&\n    this.content.length === 1 &&\n    this.content[0];\n  if (child instanceof DynamicText) {\n    child.unbound = true;\n    var template = new DynamicAttribute(child.expression);\n    context.addBinding(new AttributeBinding(template, context, element, 'value'));\n  }\n};\nElement.prototype.type = 'Element';\nElement.prototype.serialize = function() {\n  return serializeObject.instance(\n    this\n  , this.tagName\n  , this.attributes\n  , this.content\n  , this.hooks\n  , this.selfClosing\n  , this.notClosed\n  , this.ns\n  );\n};\n\nfunction DynamicElement(tagName, attributes, content, hooks, selfClosing, notClosed, ns) {\n  this.tagName = tagName;\n  this.attributes = attributes;\n  this.content = content;\n  this.hooks = hooks;\n  this.selfClosing = selfClosing;\n  this.notClosed = notClosed;\n  this.ns = ns;\n\n  this.startClose = getStartClose(selfClosing);\n  this.unescapedContent = false;\n}\nDynamicElement.prototype = Object.create(Element.prototype);\nDynamicElement.prototype.constructor = DynamicElement;\nDynamicElement.prototype.getTagName = function(context) {\n  return getUnescapedValue(this.tagName, context);\n};\nDynamicElement.prototype.getEndTag = function(tagName) {\n  return getEndTag(tagName, this.selfClosing, this.notClosed);\n};\nDynamicElement.prototype.type = 'DynamicElement';\n\nfunction getStartClose(selfClosing) {\n  return (selfClosing) ? ' />' : '>';\n}\n\nfunction getEndTag(tagName, selfClosing, notClosed) {\n  var lowerTagName = tagName && tagName.toLowerCase();\n  var isVoid = VOID_ELEMENTS[lowerTagName];\n  return (isVoid || selfClosing || notClosed) ? '' : '</' + tagName + '>';\n}\n\nfunction getAttributeValue(element, name) {\n  var propertyName = UPDATE_PROPERTIES[name];\n  return (propertyName) ? element[propertyName] : element.getAttribute(name);\n}\n\nfunction emitHooks(hooks, context, value) {\n  if (!hooks) return;\n  context.queue(function queuedHooks() {\n    for (var i = 0, len = hooks.length; i < len; i++) {\n      hooks[i].emit(context, value);\n    }\n  });\n}\n\nfunction Block(expression, content) {\n  this.expression = expression;\n  this.ending = '/' + expression;\n  this.content = content;\n}\nBlock.prototype = Object.create(Template.prototype);\nBlock.prototype.constructor = Block;\nBlock.prototype.get = function(context, unescaped) {\n  var blockContext = context.child(this.expression);\n  return contentHtml(this.content, blockContext, unescaped);\n};\nBlock.prototype.appendTo = function(parent, context, binding) {\n  var blockContext = context.child(this.expression);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var condition = this.getCondition(context);\n  parent.appendChild(start);\n  appendContent(parent, this.content, blockContext);\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end, null, condition);\n};\nBlock.prototype.attachTo = function(parent, node, context) {\n  var blockContext = context.child(this.expression);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  var condition = this.getCondition(context);\n  parent.insertBefore(start, node || null);\n  node = attachContent(parent, node, this.content, blockContext);\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end, null, condition);\n  return node;\n};\nBlock.prototype.type = 'Block';\nBlock.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.content);\n};\nBlock.prototype.update = function(context, binding) {\n  if (!binding.start.parentNode) return;\n  var condition = this.getCondition(context);\n  // Cancel update if prior condition is equivalent to current value\n  if (equalConditions(condition, binding.condition)) return;\n  binding.condition = condition;\n  // Get start and end in advance, since binding is mutated in getFragment\n  var start = binding.start;\n  var end = binding.end;\n  var fragment = this.getFragment(context, binding);\n  replaceRange(context, start, end, fragment, binding);\n};\nBlock.prototype.getCondition = function(context) {\n  // We do an identity check to see if the value has changed before updating.\n  // With objects, the object would still be the same, so this identity check\n  // would fail to update enough. Thus, return NaN, which never equals anything\n  // including itself, so that we always update on objects.\n  //\n  // We could also JSON stringify or use some other hashing approach. However,\n  // that could be really expensive on gets of things that never change, and\n  // is probably not a good tradeoff. Perhaps there should be a separate block\n  // type that is only used in the case of dynamic updates\n  var value = this.expression.get(context);\n  return (typeof value === 'object') ? NaN : value;\n};\nDynamicText.prototype._blockUpdate = Block.prototype.update;\n\nfunction ConditionalBlock(expressions, contents) {\n  this.expressions = expressions;\n  this.beginning = expressions.join('; ');\n  this.ending = '/' + this.beginning;\n  this.contents = contents;\n}\nConditionalBlock.prototype = Object.create(Block.prototype);\nConditionalBlock.prototype.constructor = ConditionalBlock;\nConditionalBlock.prototype.get = function(context, unescaped) {\n  var condition = this.getCondition(context);\n  if (condition == null) return '';\n  var expression = this.expressions[condition];\n  var blockContext = context.child(expression);\n  return contentHtml(this.contents[condition], blockContext, unescaped);\n};\nConditionalBlock.prototype.appendTo = function(parent, context, binding) {\n  var start = document.createComment(this.beginning);\n  var end = document.createComment(this.ending);\n  parent.appendChild(start);\n  var condition = this.getCondition(context);\n  if (condition != null) {\n    var expression = this.expressions[condition];\n    var blockContext = context.child(expression);\n    appendContent(parent, this.contents[condition], blockContext);\n  }\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end, null, condition);\n};\nConditionalBlock.prototype.attachTo = function(parent, node, context) {\n  var start = document.createComment(this.beginning);\n  var end = document.createComment(this.ending);\n  parent.insertBefore(start, node || null);\n  var condition = this.getCondition(context);\n  if (condition != null) {\n    var expression = this.expressions[condition];\n    var blockContext = context.child(expression);\n    node = attachContent(parent, node, this.contents[condition], blockContext);\n  }\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end, null, condition);\n  return node;\n};\nConditionalBlock.prototype.type = 'ConditionalBlock';\nConditionalBlock.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expressions, this.contents);\n};\nConditionalBlock.prototype.update = function(context, binding) {\n  if (!binding.start.parentNode) return;\n  var condition = this.getCondition(context);\n  // Cancel update if prior condition is equivalent to current value\n  if (equalConditions(condition, binding.condition)) return;\n  binding.condition = condition;\n  // Get start and end in advance, since binding is mutated in getFragment\n  var start = binding.start;\n  var end = binding.end;\n  var fragment = this.getFragment(context, binding);\n  replaceRange(context, start, end, fragment, binding);\n};\nConditionalBlock.prototype.getCondition = function(context) {\n  for (var i = 0, len = this.expressions.length; i < len; i++) {\n    if (this.expressions[i].truthy(context)) {\n      return i;\n    }\n  }\n};\n\nfunction EachBlock(expression, content, elseContent) {\n  this.expression = expression;\n  this.ending = '/' + expression;\n  this.content = content;\n  this.elseContent = elseContent;\n}\nEachBlock.prototype = Object.create(Block.prototype);\nEachBlock.prototype.constructor = EachBlock;\nEachBlock.prototype.get = function(context, unescaped) {\n  var items = this.expression.get(context);\n  if (items && items.length) {\n    var html = '';\n    for (var i = 0, len = items.length; i < len; i++) {\n      var itemContext = context.eachChild(this.expression, i);\n      html += contentHtml(this.content, itemContext, unescaped);\n    }\n    return html;\n  } else if (this.elseContent) {\n    return contentHtml(this.elseContent, context, unescaped);\n  }\n  return '';\n};\nEachBlock.prototype.appendTo = function(parent, context, binding) {\n  var items = this.expression.get(context);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  parent.appendChild(start);\n  if (items && items.length) {\n    for (var i = 0, len = items.length; i < len; i++) {\n      var itemContext = context.eachChild(this.expression, i);\n      this.appendItemTo(parent, itemContext, start);\n    }\n  } else if (this.elseContent) {\n    appendContent(parent, this.elseContent, context);\n  }\n  parent.appendChild(end);\n  updateRange(context, binding, this, start, end);\n};\nEachBlock.prototype.appendItemTo = function(parent, context, itemFor, binding) {\n  var before = parent.lastChild;\n  var start, end;\n  appendContent(parent, this.content, context);\n  if (before === parent.lastChild) {\n    start = end = document.createComment('empty');\n    parent.appendChild(start);\n  } else {\n    start = (before && before.nextSibling) || parent.firstChild;\n    end = parent.lastChild;\n  }\n  updateRange(context, binding, this, start, end, itemFor);\n};\nEachBlock.prototype.attachTo = function(parent, node, context) {\n  var items = this.expression.get(context);\n  var start = document.createComment(this.expression);\n  var end = document.createComment(this.ending);\n  parent.insertBefore(start, node || null);\n  if (items && items.length) {\n    for (var i = 0, len = items.length; i < len; i++) {\n      var itemContext = context.eachChild(this.expression, i);\n      node = this.attachItemTo(parent, node, itemContext, start);\n    }\n  } else if (this.elseContent) {\n    node = attachContent(parent, node, this.elseContent, context);\n  }\n  parent.insertBefore(end, node || null);\n  updateRange(context, null, this, start, end);\n  return node;\n};\nEachBlock.prototype.attachItemTo = function(parent, node, context, itemFor) {\n  var start, end;\n  var oldPrevious = node && node.previousSibling;\n  var nextNode = attachContent(parent, node, this.content, context);\n  if (nextNode === node) {\n    start = end = document.createComment('empty');\n    parent.insertBefore(start, node || null);\n  } else {\n    start = (oldPrevious && oldPrevious.nextSibling) || parent.firstChild;\n    end = (nextNode && nextNode.previousSibling) || parent.lastChild;\n  }\n  updateRange(context, null, this, start, end, itemFor);\n  return nextNode;\n};\nEachBlock.prototype.update = function(context, binding) {\n  if (!binding.start.parentNode) return;\n  var start = binding.start;\n  var end = binding.end;\n  if (binding.itemFor) {\n    var fragment = document.createDocumentFragment();\n    this.appendItemTo(fragment, context, binding.itemFor, binding);\n  } else {\n    var fragment = this.getFragment(context, binding);\n  }\n  replaceRange(context, start, end, fragment, binding);\n};\nEachBlock.prototype.insert = function(context, binding, index, howMany) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  // In case we are inserting all of the items, update instead. This is needed\n  // when we were previously rendering elseContent so that it is replaced\n  if (index === 0 && this.expression.get(context).length === howMany) {\n    return this.update(context, binding);\n  }\n  var node = indexStartNode(binding, index);\n  var fragment = document.createDocumentFragment();\n  for (var i = index, len = index + howMany; i < len; i++) {\n    var itemContext = context.eachChild(this.expression, i);\n    this.appendItemTo(fragment, itemContext, binding.start);\n  }\n  parent.insertBefore(fragment, node || null);\n};\nEachBlock.prototype.remove = function(context, binding, index, howMany) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  // In case we are removing all of the items, update instead. This is needed\n  // when elseContent should be rendered\n  if (index === 0 && this.expression.get(context).length === 0) {\n    return this.update(context, binding);\n  }\n  var node = indexStartNode(binding, index);\n  var i = 0;\n  while (node) {\n    if (node === binding.end) return;\n    if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {\n      if (howMany === i++) return;\n    }\n    var nextNode = node.nextSibling;\n    parent.removeChild(node);\n    emitRemoved(context, node, binding);\n    node = nextNode;\n  }\n};\nEachBlock.prototype.move = function(context, binding, from, to, howMany) {\n  var parent = binding.start.parentNode;\n  if (!parent) return;\n  var node = indexStartNode(binding, from);\n  var fragment = document.createDocumentFragment();\n  var i = 0;\n  while (node) {\n    if (node === binding.end) break;\n    if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {\n      if (howMany === i++) break;\n    }\n    var nextNode = node.nextSibling;\n    fragment.appendChild(node);\n    node = nextNode;\n  }\n  node = indexStartNode(binding, to);\n  parent.insertBefore(fragment, node || null);\n};\nEachBlock.prototype.type = 'EachBlock';\nEachBlock.prototype.serialize = function() {\n  return serializeObject.instance(this, this.expression, this.content, this.elseContent);\n};\n\nfunction indexStartNode(binding, index) {\n  var node = binding.start;\n  var i = 0;\n  while (node = node.nextSibling) {\n    if (node === binding.end) return node;\n    if (node.$bindItemStart && node.$bindItemStart.itemFor === binding.start) {\n      if (index === i) return node;\n      i++;\n    }\n  }\n}\n\nfunction updateRange(context, binding, template, start, end, itemFor, condition) {\n  if (binding) {\n    binding.start = start;\n    binding.end = end;\n    binding.condition = condition;\n    setNodeBounds(binding, start, itemFor);\n  } else {\n    context.addBinding(new RangeBinding(template, context, start, end, itemFor, condition));\n  }\n}\nfunction setNodeBounds(binding, start, itemFor) {\n  if (itemFor) {\n    setNodeProperty(start, '$bindItemStart', binding);\n  } else {\n    setNodeProperty(start, '$bindStart', binding);\n  }\n}\n\nfunction appendContent(parent, content, context) {\n  for (var i = 0, len = content.length; i < len; i++) {\n    content[i].appendTo(parent, context);\n  }\n}\nfunction attachContent(parent, node, content, context) {\n  for (var i = 0, len = content.length; i < len; i++) {\n    while (node && node.hasAttribute && node.hasAttribute('data-no-attach')) {\n      node = node.nextSibling;\n    }\n    node = content[i].attachTo(parent, node, context);\n  }\n  return node;\n}\nfunction contentHtml(content, context, unescaped) {\n  var html = '';\n  for (var i = 0, len = content.length; i < len; i++) {\n    html += content[i].get(context, unescaped);\n  }\n  return html;\n}\nfunction replaceRange(context, start, end, fragment, binding, innerOnly) {\n  // Note: the calling function must make sure to check that there is a parent\n  var parent = start.parentNode;\n  // Copy item binding from old start to fragment being inserted\n  if (start.$bindItemStart && fragment.firstChild) {\n    setNodeProperty(fragment.firstChild, '$bindItemStart', start.$bindItemStart);\n    start.$bindItemStart.start = fragment.firstChild;\n  }\n  // Fast path for single node replacements\n  if (start === end) {\n    parent.replaceChild(fragment, start);\n    emitRemoved(context, start, binding);\n    return;\n  }\n  // Remove all nodes from start to end\n  var node = (innerOnly) ? start.nextSibling : start;\n  var nextNode;\n  while (node) {\n    nextNode = node.nextSibling;\n    emitRemoved(context, node, binding);\n    if (innerOnly && node === end) {\n      nextNode = end;\n      break;\n    }\n    parent.removeChild(node);\n    if (node === end) break;\n    node = nextNode;\n  }\n  // This also works if nextNode is null, by doing an append\n  parent.insertBefore(fragment, nextNode || null);\n}\nfunction emitRemoved(context, node, ignore) {\n  context.removeNode(node);\n  emitRemovedBinding(context, ignore, node, '$bindNode');\n  emitRemovedBinding(context, ignore, node, '$bindStart');\n  emitRemovedBinding(context, ignore, node, '$bindItemStart');\n  var attributes = node.$bindAttributes;\n  if (attributes) {\n    node.$bindAttributes = null;\n    for (var key in attributes) {\n      context.removeBinding(attributes[key]);\n    }\n  }\n  for (node = node.firstChild; node; node = node.nextSibling) {\n    emitRemoved(context, node, ignore);\n  }\n}\nfunction emitRemovedBinding(context, ignore, node, property) {\n  var binding = node[property];\n  if (binding) {\n    node[property] = null;\n    if (binding !== ignore) {\n      context.removeBinding(binding);\n    }\n  }\n}\n\nfunction attachError(parent, node) {\n  if (typeof console !== 'undefined') {\n    console.error('Attach failed for', node, 'within', parent);\n  }\n  return new Error('Attaching bindings failed, because HTML structure ' +\n    'does not match client rendering.'\n  );\n}\n\nfunction Binding() {\n  this.meta = null;\n}\nBinding.prototype.type = 'Binding';\nBinding.prototype.update = function() {\n  this.context.pause();\n  this.template.update(this.context, this);\n  this.context.unpause();\n};\nBinding.prototype.insert = function() {\n  this.update();\n};\nBinding.prototype.remove = function() {\n  this.update();\n};\nBinding.prototype.move = function() {\n  this.update();\n};\n\nfunction NodeBinding(template, context, node) {\n  this.template = template;\n  this.context = context;\n  this.node = node;\n  this.meta = null;\n  setNodeProperty(node, '$bindNode', this);\n}\nNodeBinding.prototype = Object.create(Binding.prototype);\nNodeBinding.prototype.constructor = NodeBinding;\nNodeBinding.prototype.type = 'NodeBinding';\n\nfunction AttributeBindingsMap() {}\nfunction AttributeBinding(template, context, element, name) {\n  this.template = template;\n  this.context = context;\n  this.element = element;\n  this.name = name;\n  this.meta = null;\n  var map = element.$bindAttributes ||\n    (element.$bindAttributes = new AttributeBindingsMap());\n  map[name] = this;\n}\nAttributeBinding.prototype = Object.create(Binding.prototype);\nAttributeBinding.prototype.constructor = AttributeBinding;\nAttributeBinding.prototype.type = 'AttributeBinding';\n\nfunction RangeBinding(template, context, start, end, itemFor, condition) {\n  this.template = template;\n  this.context = context;\n  this.start = start;\n  this.end = end;\n  this.itemFor = itemFor;\n  this.condition = condition;\n  this.meta = null;\n  setNodeBounds(this, start, itemFor);\n}\nRangeBinding.prototype = Object.create(Binding.prototype);\nRangeBinding.prototype.constructor = RangeBinding;\nRangeBinding.prototype.type = 'RangeBinding';\nRangeBinding.prototype.insert = function(index, howMany) {\n  this.context.pause();\n  if (this.template.insert) {\n    this.template.insert(this.context, this, index, howMany);\n  } else {\n    this.template.update(this.context, this);\n  }\n  this.context.unpause();\n};\nRangeBinding.prototype.remove = function(index, howMany) {\n  this.context.pause();\n  if (this.template.remove) {\n    this.template.remove(this.context, this, index, howMany);\n  } else {\n    this.template.update(this.context, this);\n  }\n  this.context.unpause();\n};\nRangeBinding.prototype.move = function(from, to, howMany) {\n  this.context.pause();\n  if (this.template.move) {\n    this.template.move(this.context, this, from, to, howMany);\n  } else {\n    this.template.update(this.context, this);\n  }\n  this.context.unpause();\n};\n\n\n//// Utility functions ////\n\nfunction noop() {}\n\nfunction mergeInto(from, to) {\n  for (var key in from) {\n    to[key] = from[key];\n  }\n}\n\nfunction escapeHtml(string) {\n  string = string + '';\n  return string.replace(/[&<]/g, function(match) {\n    return (match === '&') ? '&amp;' : '&lt;';\n  });\n}\n\nfunction escapeAttribute(string) {\n  string = string + '';\n  return string.replace(/[&\"]/g, function(match) {\n    return (match === '&') ? '&amp;' : '&quot;';\n  });\n}\n\nfunction equalConditions(a, b) {\n  // First, test for strict equality\n  if (a === b) return true;\n  // Failing that, allow for template objects used as a condition to define a\n  // custom `equals()` method to indicate equivalence\n  return (a instanceof Template) && a.equals(b);\n}\n\n\n//// Shims & workarounds ////\n\n// General notes:\n//\n// In all cases, Node.insertBefore should have `|| null` after its second\n// argument. IE works correctly when the argument is ommitted or equal\n// to null, but it throws and error if it is equal to undefined.\n\nif (!Array.isArray) {\n  Array.isArray = function(value) {\n    return Object.prototype.toString.call(value) === '[object Array]';\n  };\n}\n\n// Equivalent to textNode.splitText, which is buggy in IE <=9\nfunction splitData(node, index) {\n  var newNode = node.cloneNode(false);\n  newNode.deleteData(0, index);\n  node.deleteData(index, node.length - index);\n  node.parentNode.insertBefore(newNode, node.nextSibling || null);\n  return newNode;\n}\n\n// Defined so that it can be overriden in IE <=8\nfunction setNodeProperty(node, key, value) {\n  return node[key] = value;\n}\n\nfunction normalizeLineBreaks(string) {\n  return string;\n}\n\n(function() {\n  // Don't try to shim in Node.js environment\n  if (typeof document === 'undefined') return;\n\n  var div = document.createElement('div');\n  div.innerHTML = '\\r\\n<br>\\n'\n  var windowsLength = div.firstChild.data.length;\n  var unixLength = div.lastChild.data.length;\n  if (windowsLength === 1 && unixLength === 1) {\n    normalizeLineBreaks = function(string) {\n      return string.replace(/\\r\\n/g, '\\n');\n    };\n  } else if (windowsLength === 2 && unixLength === 2) {\n    normalizeLineBreaks = function(string) {\n      return string.replace(/(^|[^\\r])(\\n+)/g, function(match, value, newLines) {\n        for (var i = newLines.length; i--;) {\n          value += '\\r\\n';\n        }\n        return value;\n      });\n    };\n  }\n\n  // TODO: Shim createHtmlFragment for old IE\n\n  // TODO: Shim setAttribute('style'), which doesn't work in IE <=7\n  // http://webbugtrack.blogspot.com/2007/10/bug-245-setattribute-style-does-not.html\n\n  // TODO: Investigate whether input name attribute works in IE <=7. We could\n  // override Element::appendTo to use IE's alternative createElement syntax:\n  // document.createElement('<input name=\"xxx\">')\n  // http://webbugtrack.blogspot.com/2007/10/bug-235-createelement-is-broken-in-ie.html\n\n  // In IE, input.defaultValue doesn't work correctly, so use input.value,\n  // which mistakenly but conveniently sets both the value property and attribute.\n  //\n  // Surprisingly, in IE <=7, input.defaultChecked must be used instead of\n  // input.checked before the input is in the document.\n  // http://webbugtrack.blogspot.com/2007/11/bug-299-setattribute-checked-does-not.html\n  var input = document.createElement('input');\n  input.defaultValue = 'x';\n  if (input.value !== 'x') {\n    CREATE_PROPERTIES.value = 'value';\n  }\n\n  try {\n    // TextNodes are not expando in IE <=8\n    document.createTextNode('').$try = 0;\n  } catch (err) {\n    setNodeProperty = function(node, key, value) {\n      // If trying to set a property on a TextNode, create a proxy CommentNode\n      // and set the property on that node instead. Put the proxy after the\n      // TextNode if marking the end of a range, and before otherwise.\n      if (node.nodeType === 3) {\n        var proxyNode = node.previousSibling;\n        if (!proxyNode || proxyNode.$bindProxy !== node) {\n          proxyNode = document.createComment('proxy');\n          proxyNode.$bindProxy = node;\n          node.parentNode.insertBefore(proxyNode, node || null);\n        }\n        return proxyNode[key] = value;\n      }\n      // Set the property directly on other node types\n      return node[key] = value;\n    };\n  }\n})();\n",
    "exports.instance = serializeInstance;\nexports.args = serializeArgs;\nexports.value = serializeValue;\n\nfunction serializeInstance(instance) {\n  var args = Array.prototype.slice.call(arguments, 1);\n  return 'new ' + instance.module + '.' + instance.type +\n    '(' + serializeArgs(args) + ')';\n}\n\nfunction serializeArgs(args) {\n  // Map each argument into its string representation\n  var items = [];\n  for (var i = args.length; i--;) {\n    var item = serializeValue(args[i]);\n    items.unshift(item);\n  }\n  // Remove trailing null values, assuming they are optional\n  for (var i = items.length; i--;) {\n    var item = items[i];\n    if (item !== 'void 0' && item !== 'null') break;\n    items.pop();\n  }\n  return items.join(', ');\n}\n\nfunction serializeValue(input) {\n  if (input && input.serialize) {\n    return input.serialize();\n\n  } else if (typeof input === 'undefined') {\n    return 'void 0';\n\n  } else if (input === null) {\n    return 'null';\n\n  } else if (typeof input === 'string') {\n    return formatString(input);\n\n  } else if (typeof input === 'number' || typeof input === 'boolean') {\n    return input + '';\n\n  } else if (Array.isArray(input)) {\n    var items = [];\n    for (var i = 0; i < input.length; i++) {\n      var value = serializeValue(input[i]);\n      items.push(value);\n    }\n    return '[' + items.join(', ') + ']';\n\n  } else if (typeof input === 'object') {\n    var items = [];\n    for (var key in input) {\n      var value = serializeValue(input[key]);\n      items.push(formatString(key) + ': ' + value);\n    }\n    return '{' + items.join(', ') + '}';\n  }\n}\nfunction formatString(value) {\n  var escaped = value.replace(/['\\r\\n\\\\]/g, function(match) {\n    return (match === '\\'') ? '\\\\\\'' :\n      (match === '\\r') ? '\\\\r' :\n      (match === '\\n') ? '\\\\n' :\n      (match === '\\\\') ? '\\\\\\\\' :\n      '';\n  });\n  return '\\'' + escaped + '\\'';\n}\n",
    "var qs = require('qs')\nvar parseUrl = require('url').parse\nvar resolveUrl = require('url').resolve\nvar router = require('./router')\nvar currentPath = window.location.pathname + window.location.search\n\n// Replace the initial state with the current URL immediately,\n// so that it will be rendered if the state is later popped\nif (window.history.replaceState) {\n  window.history.replaceState({\n    $render: true,\n    $method: 'get'\n  }, null, window.location.href)\n}\n\nmodule.exports = History\n\nfunction History(app, routes) {\n  this.app = app\n  this.routes = routes\n\n  if (window.history.pushState) {\n    addListeners(this)\n    return\n  }\n  this.push = function(url) {\n    window.location.assign(url)\n  }\n  this.replace = function(url) {\n    window.location.replace(url)\n  }\n}\n\nHistory.prototype.push = function(url, render, state, e) {\n  this._update('pushState', url, render, state, e)\n}\n\nHistory.prototype.replace = function(url, render, state, e) {\n  this._update('replaceState', url, render, state, e)\n}\n\n// Rerender the current url locally\nHistory.prototype.refresh = function() {\n  var path = routePath(window.location.href)\n  // Note that we don't pass previous to avoid triggering transitions\n  router.render(this, {url: path, method: 'get'})\n}\n\nHistory.prototype.back = function() {\n  window.history.back()\n}\n\nHistory.prototype.forward = function() {\n  window.history.forward()\n}\n\nHistory.prototype.go = function(i) {\n  window.history.go(i)\n}\n\nHistory.prototype._update = function(historyMethod, relativeUrl, render, state, e) {\n  var url = resolveUrl(window.location.href, relativeUrl)\n  var path = routePath(url)\n\n  // TODO: history.push should set the window.location with external urls\n  if (!path) return\n  if (render == null) render = true\n  if (state == null) state = {}\n\n  // Update the URL\n  var options = renderOptions(e, path)\n  state.$render = true\n  state.$method = options.method\n  window.history[historyMethod](state, null, options.url)\n  currentPath = window.location.pathname + window.location.search\n  if (render) router.render(this, options, e)\n}\n\nHistory.prototype.page = function() {\n  var page = this.app.createPage()\n  var history = this\n\n  function redirect(url) {\n    if (url === 'back') return history.back()\n    // TODO: Add support for `basepath` option like Express\n    if (url === 'home') url = '\\\\'\n    history.replace(url, true)\n  }\n\n  page.redirect = redirect\n  return page\n}\n\n// Get the pathname if it is on the same protocol and domain\nfunction routePath(url) {\n  var match = parseUrl(url)\n  return match &&\n    match.protocol === window.location.protocol &&\n    match.host === window.location.host &&\n    match.pathname + (match.search || '')\n}\n\nfunction renderOptions(e, path) {\n  // If this is a form submission, extract the form data and\n  // append it to the url for a get or params.body for a post\n  if (e && e.type === 'submit') {\n    var form = e.target\n    var elements = form.elements\n    var query = []\n    for (var i = 0, len = elements.length, el; i < len; i++) {\n      el = elements[i]\n      var name = el.name\n      if (!name) continue\n      var value = el.value\n      query.push(encodeURIComponent(name) + '=' + encodeURIComponent(value))\n      if (name === '_method') {\n        var override = value.toLowerCase()\n        if (override === 'delete') override = 'del'\n      }\n    }\n    query = query.join('&')\n    if (form.method.toLowerCase() === 'post') {\n      var method = override || 'post'\n      var body = qs.parse(query)\n    } else {\n      method = 'get'\n      path += '?' + query\n    }\n  } else {\n    method = 'get'\n  }\n  return {\n    method: method\n  , url: path\n  , previous: window.location.pathname + window.location.search\n  , body: body\n  , form: form\n  , link: e && e._tracksLink\n  }\n}\n\nfunction addListeners(history) {\n\n  // Detect clicks on links\n  function onClick(e) {\n    var el = e.target\n\n    // Ignore command click, control click, and non-left click\n    if (e.metaKey || e.which !== 1) return\n\n    // Ignore if already prevented\n    if (e.defaultPrevented) return\n\n    // Also look up for parent links (<a><img></a>)\n    while (el) {\n      var url = el.href\n      if (url) {\n\n        // Ignore if created by Tracks\n        if (el.hasAttribute && el.hasAttribute('data-router-ignore')) return\n\n        // Ignore links meant to open in a different window or frame\n        if (el.target && el.target !== '_self') return\n\n        // Ignore hash links to the same page\n        var hashIndex = url.indexOf('#')\n        if (~hashIndex && url.slice(0, hashIndex) === window.location.href.replace(/#.*/, '')) {\n          return\n        }\n\n        e._tracksLink = el\n        history.push(url, true, null, e)\n        return\n      }\n\n      el = el.parentNode\n    }\n  }\n\n  function onSubmit(e) {\n    var target = e.target\n\n    // Ignore if already prevented\n    if (e.defaultPrevented) return\n\n    // Only handle if emitted on a form element that isn't multipart\n    if (target.tagName.toLowerCase() !== 'form') return\n    if (target.enctype === 'multipart/form-data') return\n\n    // Ignore if created by Tracks\n    if (target.hasAttribute && target.hasAttribute('data-router-ignore')) return\n\n    // Use the url from the form action, defaulting to the current url\n    var url = target.action || window.location.href\n    history.push(url, true, null, e)\n  }\n\n  function onPopState(e) {\n    // HACK: Chrome sometimes does a pop state before the app is set up properly\n    if (!history.app.page) return\n\n    var previous = currentPath\n    var state = e.state\n    currentPath = window.location.pathname + window.location.search\n\n    var options = {\n      previous: previous\n    , url: currentPath\n    }\n\n    if (state) {\n      if (!state.$render) return\n      options.method = state.$method\n      // Note that the post body is only sent on the initial reqest\n      // and it is empty if the state is later popped\n      return router.render(history, options)\n    }\n\n    // The state object will be null for states created by jump links.\n    // window.location.hash cannot be used, because it returns nothing\n    // if the url ends in just a hash character\n    var url = window.location.href\n      , hashIndex = url.indexOf('#')\n      , el, id\n    if (~hashIndex && currentPath !== previous) {\n      options.method = 'get'\n      router.render(history, options)\n      id = url.slice(hashIndex + 1)\n      if (el = document.getElementById(id) || document.getElementsByName(id)[0]) {\n        el.scrollIntoView()\n      }\n    }\n  }\n\n  document.addEventListener('click', onClick, true)\n  document.addEventListener('submit', onSubmit, false)\n  window.addEventListener('popstate', onPopState, true)\n}\n",
    "var Route = require('../vendor/express/router/route')\nvar History = require('./History')\nvar router = module.exports = require('./router')\n\nrouter.setup = setup\n\nfunction setup(app) {\n  var routes = {\n    queue: {}\n  , transitional: {}\n  , app: app\n  }\n  app.history = new History(app, routes)\n\n  ;['get', 'post', 'put', 'del', 'enter', 'exit'].forEach(function(method) {\n    var queue = routes.queue[method] = []\n    var transitional = routes.transitional[method] = []\n\n    app[method] = function(pattern, callback) {\n      if (Array.isArray(pattern)) {\n        pattern.forEach(function(item) {\n          app[method](item, callback)\n        })\n        return app\n      }\n\n      if (router.isTransitional(pattern)) {\n        var from = pattern.from\n        var to = pattern.to\n        var forward = pattern.forward || (callback && callback.forward) || callback\n        var back = pattern.back || (callback && callback.back)\n\n        var fromRoute = new Route(method, from, back)\n        var toRoute = new Route(method, to, forward)\n        fromRoute.isTransitional = true\n        toRoute.isTransitional = true\n        transitional.push({\n          from: fromRoute\n        , to: toRoute\n        })\n        if (back) transitional.push({\n          from: toRoute\n        , to: fromRoute\n        })\n\n        return app\n      }\n\n      queue.push(new Route(method, pattern, callback))\n      return app\n    }\n  })\n}\n",
    "var qs = require('qs')\nvar nodeUrl = require('url');\n\nmodule.exports = {\n  render: render\n, isTransitional: isTransitional\n, mapRoute: mapRoute\n}\n\nfunction isTransitional(pattern) {\n  return pattern.hasOwnProperty('from') && pattern.hasOwnProperty('to')\n}\n\nfunction mapRoute(from, params) {\n  var i = params.url.indexOf('?')\n  var queryString = (~i) ? params.url.slice(i) : ''\n  // If the route looks like /:a/:b?/:c/:d?\n  // and :b and :d are missing, return /a/c\n  // Thus, skip the / if the value is missing\n  var i = 0\n  var path = from.replace(/\\/(?:(?:\\:([^?\\/:*(]+)(?:\\([^)]+\\))?)|\\*)(\\?)?/g, onMatch)\n  function onMatch(match, key, optional) {\n    var value = key ? params[key] : params[i++]\n    return (optional && value == null) ? '' : '/' + encodeURIComponent(value)\n  }\n  return path + queryString\n}\n\nfunction render(history, options, e) {\n  var req = new RenderReq(history.app.page, history.routes, options, e)\n  req.routeTransitional(0, function() {\n    req.page = history.page()\n    req.routeQueue(0, function() {\n      // Cancel rendering by this app if no routes match\n      req.cancel()\n    })\n  })\n}\n\nfunction RenderReq(page, routes, options, e) {\n  this.page = page\n  this.options = options\n  this.e = e\n  this.setUrl(options.url.replace(/#.*/, ''))\n  var queryString = nodeUrl.parse(this.url).query;\n  this.query = queryString ? qs.parse(queryString) : {}\n  this.method = options.method\n  this.body = options.body || {}\n  this.setPrevious(options.previous)\n  this.transitional = routes.transitional[this.method]\n  this.queue = routes.queue[this.method]\n  this.app = routes.app\n}\n\nRenderReq.prototype.cancel = function() {\n  var options = this.options\n  // Don't do anything if this is the result of an event, since the\n  // appropriate action will happen by default\n  if (this.e || options.noNavigate) return\n  // Otherwise, manually perform appropriate action\n  if (options.form) {\n    options.form.setAttribute('data-router-ignore', '')\n    options.form.submit()\n  } else {\n    window.location.assign(options.url)\n  }\n}\n\nRenderReq.prototype.setUrl = function(url) {\n  this.url = url\n  this.path = url.replace(/\\?.*/, '')\n}\nRenderReq.prototype.setPrevious = function(previous) {\n  this.previous = previous\n  this.previousPath = previous && previous.replace(/\\?.*/, '')\n}\n\nRenderReq.prototype.routeTransitional = function(i, next) {\n  i || (i = 0)\n  var item\n  while (item = this.transitional[i++]) {\n    if (!item.to.match(this.path) || !item.from.match(this.previousPath)) continue\n    var req = this\n    var params = this.routeParams(item.to)\n    // Even though we don't need to do anything after a done, pass a\n    // no op function, so that routes can expect it to be defined\n    function done() {}\n    this.onMatch(item.to, params, function(err) {\n      if (err) return req.cancel()\n      req.routeTransitional(i, next)\n    }, done)\n    return\n  }\n  next()\n}\n\nRenderReq.prototype.routeQueue = function(i, next) {\n  i || (i = 0)\n  var route\n  while (route = this.queue[i++]) {\n    if (!route.match(this.path)) continue\n    var req = this\n    var params = this.routeParams(route)\n    this.onMatch(route, params, function(err) {\n      if (err) return req.cancel()\n      req.routeQueue(i, next)\n    })\n    return\n  }\n  next()\n}\n\nRenderReq.prototype.onMatch = function(route, params, next, done) {\n  if (!this.page) return next()\n  // Stop the default browser action, such as clicking a link or submitting a form\n  if (this.e) {\n    this.e.preventDefault()\n    this.e = null\n  }\n  this.page.params = params\n  if (route.isTransitional) {\n    this.app.onRoute(route.callbacks, this.page, next, done)\n  } else {\n    this.app.onRoute(route.callbacks, this.page, next)\n  }\n}\n\nRenderReq.prototype.routeParams = function(route) {\n  var routeParams = route.params\n  var params = routeParams.slice()\n\n  for (var key in routeParams) {\n    params[key] = routeParams[key]\n  }\n  params.previous = this.previous\n  params.url = this.url\n  params.body = this.body\n  params.query = this.query\n  params.method = this.method\n  return params\n}\n",
    "\n/**\n * Module dependencies.\n */\n\nvar utils = require('../utils');\n\n/**\n * Expose `Route`.\n */\n\nmodule.exports = Route;\n\n/**\n * Initialize `Route` with the given HTTP `method`, `path`,\n * and an array of `callbacks` and `options`.\n *\n * Options:\n *\n *   - `sensitive`    enable case-sensitive routes\n *   - `strict`       enable strict matching for trailing slashes\n *\n * @param {String} method\n * @param {String} path\n * @param {Array} callbacks\n * @param {Object} options.\n * @api private\n */\n\nfunction Route(method, path, callbacks, options) {\n  options = options || {};\n  this.path = path;\n  this.method = method;\n  this.callbacks = callbacks;\n  this.regexp = utils.pathRegexp(path\n    , this.keys = []\n    , options.sensitive\n    , options.strict);\n}\n\n/**\n * Check if this route matches `path`, if so\n * populate `.params`.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nRoute.prototype.match = function(path){\n  var keys = this.keys\n    , params = this.params = []\n    , m = this.regexp.exec(path);\n\n  if (!m) return false;\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = keys[i - 1];\n\n    var val = 'string' == typeof m[i]\n      ? decodeURIComponent(m[i])\n      : m[i];\n\n    if (key) {\n      params[key.name] = val;\n    } else {\n      params.push(val);\n    }\n  }\n\n  return true;\n};\n",
    "\n/**\n * Module dependencies.\n */\n\n/**\n * toString ref.\n */\n\nvar toString = {}.toString;\n\n/**\n * Return ETag for `body`.\n *\n * @param {String|Buffer} body\n * @return {String}\n * @api private\n */\n\nexports.etag = function(body){\n  return '\"' + crc32.signed(body) + '\"';\n};\n\n/**\n * Make `locals()` bound to the given `obj`.\n *\n * This is used for `app.locals` and `res.locals`.\n *\n * @param {Object} obj\n * @return {Function}\n * @api private\n */\n\nexports.locals = function(obj){\n  function locals(obj){\n    for (var key in obj) locals[key] = obj[key];\n    return obj;\n  };\n\n  return locals;\n};\n\n/**\n * Check if `path` looks absolute.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nexports.isAbsolute = function(path){\n  if ('/' == path[0]) return true;\n  if (':' == path[1] && '\\\\' == path[2]) return true;\n};\n\n/**\n * Flatten the given `arr`.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.flatten = function(arr, ret){\n  var ret = ret || []\n    , len = arr.length;\n  for (var i = 0; i < len; ++i) {\n    if (Array.isArray(arr[i])) {\n      exports.flatten(arr[i], ret);\n    } else {\n      ret.push(arr[i]);\n    }\n  }\n  return ret;\n};\n\n/**\n * Normalize the given `type`, for example \"html\" becomes \"text/html\".\n *\n * @param {String} type\n * @return {Object}\n * @api private\n */\n\nexports.normalizeType = function(type){\n  return ~type.indexOf('/')\n    ? acceptParams(type)\n    : { value: mime.lookup(type), params: {} };\n};\n\n/**\n * Normalize `types`, for example \"html\" becomes \"text/html\".\n *\n * @param {Array} types\n * @return {Array}\n * @api private\n */\n\nexports.normalizeTypes = function(types){\n  var ret = [];\n\n  for (var i = 0; i < types.length; ++i) {\n    ret.push(exports.normalizeType(types[i]));\n  }\n\n  return ret;\n};\n\n/**\n * Return the acceptable type in `types`, if any.\n *\n * @param {Array} types\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.acceptsArray = function(types, str){\n  // accept anything when Accept is not present\n  if (!str) return types[0];\n\n  // parse\n  var accepted = exports.parseAccept(str)\n    , normalized = exports.normalizeTypes(types)\n    , len = accepted.length;\n\n  for (var i = 0; i < len; ++i) {\n    for (var j = 0, jlen = types.length; j < jlen; ++j) {\n      if (exports.accept(normalized[j], accepted[i])) {\n        return types[j];\n      }\n    }\n  }\n};\n\n/**\n * Check if `type(s)` are acceptable based on\n * the given `str`.\n *\n * @param {String|Array} type(s)\n * @param {String} str\n * @return {Boolean|String}\n * @api private\n */\n\nexports.accepts = function(type, str){\n  if ('string' == typeof type) type = type.split(/ *, */);\n  return exports.acceptsArray(type, str);\n};\n\n/**\n * Check if `type` array is acceptable for `other`.\n *\n * @param {Object} type\n * @param {Object} other\n * @return {Boolean}\n * @api private\n */\n\nexports.accept = function(type, other){\n  var t = type.value.split('/');\n  return (t[0] == other.type || '*' == other.type)\n    && (t[1] == other.subtype || '*' == other.subtype)\n    && paramsEqual(type.params, other.params);\n};\n\n/**\n * Check if accept params are equal.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Boolean}\n * @api private\n */\n\nfunction paramsEqual(a, b){\n  return !Object.keys(a).some(function(k) {\n    return a[k] != b[k];\n  });\n}\n\n/**\n * Parse accept `str`, returning\n * an array objects containing\n * `.type` and `.subtype` along\n * with the values provided by\n * `parseQuality()`.\n *\n * @param {Type} name\n * @return {Type}\n * @api private\n */\n\nexports.parseAccept = function(str){\n  return exports\n    .parseParams(str)\n    .map(function(obj){\n      var parts = obj.value.split('/');\n      obj.type = parts[0];\n      obj.subtype = parts[1];\n      return obj;\n    });\n};\n\n/**\n * Parse quality `str`, returning an\n * array of objects with `.value`,\n * `.quality` and optional `.params`\n *\n * @param {String} str\n * @return {Array}\n * @api private\n */\n\nexports.parseParams = function(str){\n  return str\n    .split(/ *, */)\n    .map(acceptParams)\n    .filter(function(obj){\n      return obj.quality;\n    })\n    .sort(function(a, b){\n      if (a.quality === b.quality) {\n        return a.originalIndex - b.originalIndex;\n      } else {\n        return b.quality - a.quality;\n      }\n    });\n};\n\n/**\n * Parse accept params `str` returning an\n * object with `.value`, `.quality` and `.params`.\n * also includes `.originalIndex` for stable sorting\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction acceptParams(str, index) {\n  var parts = str.split(/ *; */);\n  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };\n\n  for (var i = 1; i < parts.length; ++i) {\n    var pms = parts[i].split(/ *= */);\n    if ('q' == pms[0]) {\n      ret.quality = parseFloat(pms[1]);\n    } else {\n      ret.params[pms[0]] = pms[1];\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {String} html\n * @return {String}\n * @api private\n */\n\nexports.escape = function(html) {\n  return String(html)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n};\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Boolean} sensitive\n * @param  {Boolean} strict\n * @return {RegExp}\n * @api private\n */\n\nexports.pathRegexp = function(path, keys, sensitive, strict) {\n  if (toString.call(path) == '[object RegExp]') return path;\n  if (Array.isArray(path)) path = '(' + path.join('|') + ')';\n  path = path\n    .concat(strict ? '' : '/?')\n    .replace(/\\/\\(/g, '(?:/')\n    .replace(/(\\/)?(\\.)?:(\\w+)(?:(\\(.*?\\)))?(\\?)?(\\*)?/g, function(_, slash, format, key, capture, optional, star){\n      keys.push({ name: key, optional: !! optional });\n      slash = slash || '';\n      return ''\n        + (optional ? '' : slash)\n        + '(?:'\n        + (optional ? slash : '')\n        + (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')'\n        + (optional || '')\n        + (star ? '(/*)?' : '');\n    })\n    .replace(/([\\/.])/g, '\\\\$1')\n    .replace(/\\*/g, '(.*)');\n  return new RegExp('^' + path + '$', sensitive ? '' : 'i');\n}\n",
    "// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n",
    "'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n",
    "\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n",
    "//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n"
  ]
}